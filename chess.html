<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess with AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 4px solid #8b4513;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 4px;
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .square.white {
            background-color: #f0d9b5;
        }

        .square.black {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fff00 !important;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
        }

        .square.valid-move {
            background-color: #90ee90 !important;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
        }

        .square.valid-capture {
            background-color: #ff6b6b !important;
        }

        .square.thinking {
            animation: thinking-pulse 0.5s ease-in-out infinite;
        }

        .square.thinking-from {
            background-color: #ffd700 !important;
        }

        .square.thinking-to {
            background-color: #ff8c00 !important;
        }

        .square.best-move {
            background-color: #00ffff !important;
            animation: best-move-glow 0.8s ease-in-out infinite;
        }

        .square.last-move {
            box-shadow: inset 0 0 10px rgba(255, 215, 0, 0.6);
        }

        .square.check {
            background: radial-gradient(circle, #ff0000 0%, transparent 70%) !important;
        }

        @keyframes thinking-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes best-move-glow {
            0%, 100% { box-shadow: inset 0 0 10px #00ffff; }
            50% { box-shadow: inset 0 0 25px #00ffff; }
        }

        .piece {
            user-select: none;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        .square:hover .piece {
            transform: scale(1.1);
        }

        .controls {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            color: white;
            min-width: 300px;
            max-width: 350px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ffd700;
        }

        .difficulty-slider {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(to right, #4ade80, #facc15, #f87171);
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .difficulty-display {
            text-align: center;
            margin-top: 10px;
            font-size: 18px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-cheat {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            color: white;
        }

        .btn-cheat:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,65,108,0.4);
        }

        .btn-hint {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
        }

        .btn-hint:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56,239,125,0.4);
        }

        .btn-new {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-new:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102,126,234,0.4);
        }

        .btn-undo {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-undo:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(240,147,251,0.4);
        }

        .thinking-display {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            min-height: 150px;
            max-height: 250px;
            overflow-y: auto;
        }

        .thinking-display h3 {
            color: #ffd700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .thinking-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,215,0,0.3);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        .thinking-spinner.active {
            display: block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .thinking-log {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #aaa;
        }

        .thinking-log .move-eval {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .thinking-log .best {
            color: #4ade80;
            font-weight: bold;
        }

        .status {
            text-align: center;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
        }

        .status.your-turn {
            background: linear-gradient(135deg, #11998e, #38ef7d);
        }

        .status.ai-turn {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }

        .status.game-over {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .captured-pieces {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .captured-pieces h4 {
            color: #ffd700;
            margin-bottom: 5px;
        }

        .captured-white, .captured-black {
            font-size: 24px;
            min-height: 30px;
        }

        .stats {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-size: 14px;
        }

        .stats div {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }

        .cheat-menu {
            background: rgba(255,0,0,0.2);
            border: 1px solid #ff416c;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            display: none;
        }

        .cheat-menu.active {
            display: block;
        }

        .cheat-menu button {
            font-size: 12px;
            padding: 8px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
        }

        .toggle {
            width: 50px;
            height: 26px;
            background: #555;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle.active {
            background: #4ade80;
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle.active::after {
            transform: translateX(24px);
        }

        .eval-bar-container {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .eval-bar {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #fff, #ddd);
            transition: width 0.5s ease;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            opacity: 0.7;
        }

        .coord-file {
            bottom: 2px;
            right: 4px;
        }

        .coord-rank {
            top: 2px;
            left: 4px;
        }

        .square.white .coordinates { color: #b58863; }
        .square.black .coordinates { color: #f0d9b5; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="board-section">
            <h1>‚ôî Chess vs AI ‚ôö</h1>
            <div class="board" id="board"></div>
        </div>

        <div class="controls">
            <div class="status your-turn" id="status">Your Turn (White)</div>

            <div class="control-group">
                <label>üéØ AI Difficulty: <span id="difficultyLabel">Medium (3)</span></label>
                <input type="range" class="difficulty-slider" id="difficulty" min="1" max="5" value="3">
                <div class="difficulty-display" id="difficultyDesc">Balanced gameplay</div>
            </div>

            <div class="control-group">
                <label>üìä Position Evaluation</label>
                <div class="eval-bar-container">
                    <div class="eval-bar" id="evalBar"></div>
                </div>
                <div style="text-align: center; margin-top: 5px;">
                    <span id="evalScore">0.0</span>
                </div>
            </div>

            <button class="btn-new" onclick="newGame()">üîÑ New Game</button>
            <button class="btn-hint" onclick="showHint()">üí° Show Hint</button>
            <button class="btn-undo" onclick="undoMove()">‚Ü©Ô∏è Undo Move</button>
            <button class="btn-cheat" onclick="toggleCheatMenu()">üéÆ Cheat Menu</button>

            <div class="cheat-menu" id="cheatMenu">
                <div class="toggle-container">
                    <span>üëÅÔ∏è See AI Thinking</span>
                    <div class="toggle active" id="toggleThinking" onclick="toggleThinkingVisual()"></div>
                </div>
                <div class="toggle-container">
                    <span>üîÆ Show Best Moves</span>
                    <div class="toggle" id="toggleBestMoves" onclick="toggleBestMoves()"></div>
                </div>
                <button class="btn-cheat" onclick="autoWin()">üëë Auto-Win Move</button>
                <button class="btn-cheat" onclick="skipTurn()">‚è≠Ô∏è Skip AI Turn</button>
                <button class="btn-cheat" onclick="removeRandomPiece()">üíÄ Remove Random Enemy</button>
                <button class="btn-cheat" onclick="promoteRandomPawn()">‚¨ÜÔ∏è Promote Random Pawn</button>
            </div>

            <div class="thinking-display">
                <h3>
                    üß† AI Thinking
                    <div class="thinking-spinner" id="spinner"></div>
                </h3>
                <div class="thinking-log" id="thinkingLog">
                    Waiting for your move...
                </div>
            </div>

            <div class="captured-pieces">
                <h4>Captured Pieces</h4>
                <div class="captured-white" id="capturedWhite"></div>
                <div class="captured-black" id="capturedBlack"></div>
            </div>

            <div class="stats">
                <div><span>Moves:</span><span id="moveCount">0</span></div>
                <div><span>AI Nodes Evaluated:</span><span id="nodesEval">0</span></div>
                <div><span>AI Think Time:</span><span id="thinkTime">0ms</span></div>
            </div>
        </div>
    </div>

    <script>
        // Chess pieces Unicode
        const PIECES = {
            K: '‚ôî', Q: '‚ôï', R: '‚ôñ', B: '‚ôó', N: '‚ôò', P: '‚ôô',
            k: '‚ôö', q: '‚ôõ', r: '‚ôú', b: '‚ôù', n: '‚ôû', p: '‚ôü'
        };

        // Piece values for evaluation
        const PIECE_VALUES = {
            p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000,
            P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000
        };

        // Position tables for piece-square evaluation
        const PST = {
            p: [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ],
            n: [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            b: [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5,  5,  5,  5,  5,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ],
            r: [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ],
            q: [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ],
            k: [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ]
        };

        // Game state
        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let moveHistory = [];
        let capturedWhite = [];
        let capturedBlack = [];
        let nodesEvaluated = 0;
        let showThinking = true;
        let showBestMoves = false;
        let gameOver = false;
        let castlingRights = { K: true, Q: true, k: true, q: true };
        let enPassantSquare = null;
        let lastMove = null;

        // Initialize board
        function initBoard() {
            board = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
        }

        function isWhitePiece(piece) {
            return piece && piece === piece.toUpperCase();
        }

        function isBlackPiece(piece) {
            return piece && piece === piece.toLowerCase();
        }

        function getPieceColor(piece) {
            if (!piece) return null;
            return isWhitePiece(piece) ? 'white' : 'black';
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'white' : 'black'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Add coordinates
                    if (col === 0) {
                        const rank = document.createElement('span');
                        rank.className = 'coordinates coord-rank';
                        rank.textContent = 8 - row;
                        square.appendChild(rank);
                    }
                    if (row === 7) {
                        const file = document.createElement('span');
                        file.className = 'coordinates coord-file';
                        file.textContent = String.fromCharCode(97 + col);
                        square.appendChild(file);
                    }

                    const piece = board[row][col];
                    if (piece) {
                        const pieceEl = document.createElement('span');
                        pieceEl.className = 'piece';
                        pieceEl.textContent = PIECES[piece];
                        square.appendChild(pieceEl);
                    }

                    // Highlight last move
                    if (lastMove) {
                        if ((row === lastMove.fromRow && col === lastMove.fromCol) ||
                            (row === lastMove.toRow && col === lastMove.toCol)) {
                            square.classList.add('last-move');
                        }
                    }

                    // Highlight king in check
                    if (piece && piece.toLowerCase() === 'k') {
                        const color = getPieceColor(piece);
                        if (isInCheck(color)) {
                            square.classList.add('check');
                        }
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardEl.appendChild(square);
                }
            }

            updateEvalBar();
        }

        function handleSquareClick(row, col) {
            if (gameOver || currentPlayer !== 'white') return;

            const piece = board[row][col];
            const squares = document.querySelectorAll('.square');

            // Clear previous selections
            squares.forEach(sq => {
                sq.classList.remove('selected', 'valid-move', 'valid-capture', 'best-move');
            });

            if (selectedSquare) {
                const [fromRow, fromCol] = selectedSquare;
                const validMoves = getValidMoves(fromRow, fromCol);
                const isValidMove = validMoves.some(m => m.row === row && m.col === col);

                if (isValidMove) {
                    makeMove(fromRow, fromCol, row, col);
                    selectedSquare = null;
                    renderBoard();

                    if (!gameOver) {
                        setTimeout(() => aiMove(), 300);
                    }
                    return;
                }
            }

            if (piece && isWhitePiece(piece)) {
                selectedSquare = [row, col];
                const squareEl = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                squareEl.classList.add('selected');

                const validMoves = getValidMoves(row, col);
                validMoves.forEach(move => {
                    const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                    if (board[move.row][move.col]) {
                        moveSquare.classList.add('valid-capture');
                    } else {
                        moveSquare.classList.add('valid-move');
                    }
                });
            } else {
                selectedSquare = null;
            }
        }

        function getValidMoves(row, col, checkKingSafety = true) {
            const piece = board[row][col];
            if (!piece) return [];

            const moves = [];
            const color = getPieceColor(piece);
            const pieceType = piece.toLowerCase();

            const addMove = (r, c) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const target = board[r][c];
                    if (!target || getPieceColor(target) !== color) {
                        moves.push({ row: r, col: c });
                        return !target;
                    }
                }
                return false;
            };

            switch (pieceType) {
                case 'p':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;

                    // Forward move
                    if (!board[row + direction]?.[col]) {
                        moves.push({ row: row + direction, col });
                        // Double move from start
                        if (row === startRow && !board[row + 2 * direction]?.[col]) {
                            moves.push({ row: row + 2 * direction, col });
                        }
                    }

                    // Captures
                    [-1, 1].forEach(dc => {
                        const newCol = col + dc;
                        const newRow = row + direction;
                        if (newCol >= 0 && newCol < 8) {
                            const target = board[newRow]?.[newCol];
                            if (target && getPieceColor(target) !== color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            // En passant
                            if (enPassantSquare && enPassantSquare.row === newRow && enPassantSquare.col === newCol) {
                                moves.push({ row: newRow, col: newCol, enPassant: true });
                            }
                        }
                    });
                    break;

                case 'n':
                    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });
                    break;

                case 'b':
                    [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + dr*i, col + dc*i)) break;
                            if (board[row + dr*i]?.[col + dc*i]) break;
                        }
                    });
                    break;

                case 'r':
                    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + dr*i, col + dc*i)) break;
                            if (board[row + dr*i]?.[col + dc*i]) break;
                        }
                    });
                    break;

                case 'q':
                    [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + dr*i, col + dc*i)) break;
                            if (board[row + dr*i]?.[col + dc*i]) break;
                        }
                    });
                    break;

                case 'k':
                    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });

                    // Castling
                    if (checkKingSafety && !isInCheck(color)) {
                        const homeRow = color === 'white' ? 7 : 0;
                        if (row === homeRow && col === 4) {
                            // Kingside
                            const canCastleK = color === 'white' ? castlingRights.K : castlingRights.k;
                            if (canCastleK && !board[row][5] && !board[row][6] && board[row][7]?.toLowerCase() === 'r') {
                                if (!isSquareAttacked(row, 5, color) && !isSquareAttacked(row, 6, color)) {
                                    moves.push({ row, col: 6, castling: 'K' });
                                }
                            }
                            // Queenside
                            const canCastleQ = color === 'white' ? castlingRights.Q : castlingRights.q;
                            if (canCastleQ && !board[row][1] && !board[row][2] && !board[row][3] && board[row][0]?.toLowerCase() === 'r') {
                                if (!isSquareAttacked(row, 2, color) && !isSquareAttacked(row, 3, color)) {
                                    moves.push({ row, col: 2, castling: 'Q' });
                                }
                            }
                        }
                    }
                    break;
            }

            // Filter moves that would leave king in check
            if (checkKingSafety) {
                return moves.filter(move => {
                    const savedBoard = board.map(r => [...r]);
                    const savedEnPassant = enPassantSquare;

                    board[move.row][move.col] = piece;
                    board[row][col] = '';

                    if (move.enPassant) {
                        const captureRow = color === 'white' ? move.row + 1 : move.row - 1;
                        board[captureRow][move.col] = '';
                    }

                    const safe = !isInCheck(color);

                    board.forEach((r, i) => r.forEach((_, j) => board[i][j] = savedBoard[i][j]));
                    enPassantSquare = savedEnPassant;

                    return safe;
                });
            }

            return moves;
        }

        function isSquareAttacked(row, col, byColor) {
            const enemyColor = byColor === 'white' ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && getPieceColor(piece) === enemyColor) {
                        const moves = getValidMoves(r, c, false);
                        if (moves.some(m => m.row === row && m.col === col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isInCheck(color) {
            let kingRow, kingCol;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.toLowerCase() === 'k' && getPieceColor(piece) === color) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
            }

            if (kingRow === undefined) return false;

            return isSquareAttacked(kingRow, kingCol, color);
        }

        function hasLegalMoves(color) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && getPieceColor(piece) === color) {
                        if (getValidMoves(r, c).length > 0) return true;
                    }
                }
            }
            return false;
        }

        function makeMove(fromRow, fromCol, toRow, toCol, isAI = false) {
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];
            const color = getPieceColor(piece);

            // Save state for undo
            moveHistory.push({
                fromRow, fromCol, toRow, toCol,
                piece, captured,
                castlingRights: { ...castlingRights },
                enPassantSquare,
                board: board.map(r => [...r])
            });

            // Handle en passant capture
            const move = getValidMoves(fromRow, fromCol).find(m => m.row === toRow && m.col === toCol);
            if (move?.enPassant) {
                const captureRow = color === 'white' ? toRow + 1 : toRow - 1;
                const capturedPawn = board[captureRow][toCol];
                if (color === 'white') capturedBlack.push(capturedPawn);
                else capturedWhite.push(capturedPawn);
                board[captureRow][toCol] = '';
            }

            // Handle castling
            if (move?.castling) {
                if (move.castling === 'K') {
                    board[toRow][5] = board[toRow][7];
                    board[toRow][7] = '';
                } else {
                    board[toRow][3] = board[toRow][0];
                    board[toRow][0] = '';
                }
            }

            // Update castling rights
            if (piece === 'K') { castlingRights.K = false; castlingRights.Q = false; }
            if (piece === 'k') { castlingRights.k = false; castlingRights.q = false; }
            if (piece === 'R' && fromCol === 0) castlingRights.Q = false;
            if (piece === 'R' && fromCol === 7) castlingRights.K = false;
            if (piece === 'r' && fromCol === 0) castlingRights.q = false;
            if (piece === 'r' && fromCol === 7) castlingRights.k = false;

            // Update en passant square
            enPassantSquare = null;
            if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantSquare = { row: (fromRow + toRow) / 2, col: fromCol };
            }

            // Make the move
            if (captured) {
                if (color === 'white') capturedBlack.push(captured);
                else capturedWhite.push(captured);
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';

            // Handle pawn promotion
            if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                board[toRow][toCol] = color === 'white' ? 'Q' : 'q';
            }

            lastMove = { fromRow, fromCol, toRow, toCol };
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

            updateStatus();
            updateCaptured();
            document.getElementById('moveCount').textContent = moveHistory.length;
        }

        function updateStatus() {
            const statusEl = document.getElementById('status');
            const inCheck = isInCheck(currentPlayer);
            const hasMovesLeft = hasLegalMoves(currentPlayer);

            if (!hasMovesLeft) {
                gameOver = true;
                if (inCheck) {
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    statusEl.textContent = `Checkmate! ${winner} Wins!`;
                } else {
                    statusEl.textContent = 'Stalemate! Draw!';
                }
                statusEl.className = 'status game-over';
            } else if (inCheck) {
                statusEl.textContent = `${currentPlayer === 'white' ? 'White' : 'Black'} is in Check!`;
                statusEl.className = `status ${currentPlayer === 'white' ? 'your-turn' : 'ai-turn'}`;
            } else {
                statusEl.textContent = currentPlayer === 'white' ? 'Your Turn (White)' : 'AI Thinking...';
                statusEl.className = `status ${currentPlayer === 'white' ? 'your-turn' : 'ai-turn'}`;
            }
        }

        function updateCaptured() {
            document.getElementById('capturedWhite').textContent = capturedWhite.map(p => PIECES[p]).join('');
            document.getElementById('capturedBlack').textContent = capturedBlack.map(p => PIECES[p]).join('');
        }

        // AI Implementation
        function evaluateBoard() {
            let score = 0;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        const pieceType = piece.toLowerCase();
                        let value = PIECE_VALUES[pieceType];

                        // Add position value
                        const pst = PST[pieceType];
                        if (pst) {
                            const posRow = isWhitePiece(piece) ? r : 7 - r;
                            value += pst[posRow][c];
                        }

                        // Mobility bonus
                        const mobility = getValidMoves(r, c, false).length;
                        value += mobility * 5;

                        score += isWhitePiece(piece) ? value : -value;
                    }
                }
            }

            // Check/checkmate bonuses
            if (isInCheck('white')) score -= 50;
            if (isInCheck('black')) score += 50;

            return score;
        }

        function getAllMoves(color) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && getPieceColor(piece) === color) {
                        const validMoves = getValidMoves(r, c);
                        validMoves.forEach(m => {
                            moves.push({
                                fromRow: r, fromCol: c,
                                toRow: m.row, toCol: m.col,
                                piece,
                                captured: board[m.row][m.col],
                                ...m
                            });
                        });
                    }
                }
            }

            // Order moves: captures first, then by piece value
            moves.sort((a, b) => {
                const aCapture = a.captured ? PIECE_VALUES[a.captured] : 0;
                const bCapture = b.captured ? PIECE_VALUES[b.captured] : 0;
                return bCapture - aCapture;
            });

            return moves;
        }

        function minimax(depth, alpha, beta, isMaximizing, visualize = false) {
            nodesEvaluated++;

            if (depth === 0 || gameOver) {
                return { score: evaluateBoard() };
            }

            const color = isMaximizing ? 'white' : 'black';
            const moves = getAllMoves(color);

            if (moves.length === 0) {
                if (isInCheck(color)) {
                    return { score: isMaximizing ? -100000 + depth : 100000 - depth };
                }
                return { score: 0 }; // Stalemate
            }

            let bestMove = null;

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const savedState = saveBoardState();

                    executeMove(move);

                    if (visualize && showThinking && depth >= getDifficulty() - 1) {
                        highlightThinking(move.fromRow, move.fromCol, move.toRow, move.toCol);
                    }

                    const result = minimax(depth - 1, alpha, beta, false, visualize);

                    restoreBoardState(savedState);

                    if (result.score > maxEval) {
                        maxEval = result.score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, result.score);
                    if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const savedState = saveBoardState();

                    executeMove(move);

                    if (visualize && showThinking && depth >= getDifficulty() - 1) {
                        highlightThinking(move.fromRow, move.fromCol, move.toRow, move.toCol);
                    }

                    const result = minimax(depth - 1, alpha, beta, true, visualize);

                    restoreBoardState(savedState);

                    if (result.score < minEval) {
                        minEval = result.score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, result.score);
                    if (beta <= alpha) break;
                }
                return { score: minEval, move: bestMove };
            }
        }

        function saveBoardState() {
            return {
                board: board.map(r => [...r]),
                castlingRights: { ...castlingRights },
                enPassantSquare
            };
        }

        function restoreBoardState(state) {
            board = state.board;
            castlingRights = state.castlingRights;
            enPassantSquare = state.enPassantSquare;
        }

        function executeMove(move) {
            const piece = board[move.fromRow][move.fromCol];
            const color = getPieceColor(piece);

            // Handle en passant
            if (move.enPassant) {
                const captureRow = color === 'white' ? move.toRow + 1 : move.toRow - 1;
                board[captureRow][move.toCol] = '';
            }

            // Handle castling
            if (move.castling) {
                if (move.castling === 'K') {
                    board[move.toRow][5] = board[move.toRow][7];
                    board[move.toRow][7] = '';
                } else {
                    board[move.toRow][3] = board[move.toRow][0];
                    board[move.toRow][0] = '';
                }
            }

            // Update en passant
            enPassantSquare = null;
            if (piece.toLowerCase() === 'p' && Math.abs(move.toRow - move.fromRow) === 2) {
                enPassantSquare = { row: (move.fromRow + move.toRow) / 2, col: move.fromCol };
            }

            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = '';

            // Promotion
            if (piece.toLowerCase() === 'p' && (move.toRow === 0 || move.toRow === 7)) {
                board[move.toRow][move.toCol] = color === 'white' ? 'Q' : 'q';
            }
        }

        function highlightThinking(fromRow, fromCol, toRow, toCol) {
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => {
                sq.classList.remove('thinking-from', 'thinking-to');
            });

            const fromSquare = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const toSquare = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);

            if (fromSquare) fromSquare.classList.add('thinking-from');
            if (toSquare) toSquare.classList.add('thinking-to');
        }

        function clearThinkingHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => {
                sq.classList.remove('thinking-from', 'thinking-to', 'thinking', 'best-move');
            });
        }

        function getDifficulty() {
            return parseInt(document.getElementById('difficulty').value);
        }

        async function aiMove() {
            if (gameOver || currentPlayer !== 'black') return;

            const spinner = document.getElementById('spinner');
            const thinkingLog = document.getElementById('thinkingLog');
            spinner.classList.add('active');
            thinkingLog.innerHTML = 'Analyzing position...<br>';

            nodesEvaluated = 0;
            const startTime = performance.now();

            const difficulty = getDifficulty();
            const depth = difficulty;

            // Add some delay for visual effect
            await new Promise(resolve => setTimeout(resolve, 100));

            const moves = getAllMoves('black');
            const evaluatedMoves = [];

            thinkingLog.innerHTML = `Evaluating ${moves.length} possible moves...<br>`;

            for (const move of moves) {
                const savedState = saveBoardState();
                executeMove(move);

                const eval_ = evaluateBoard();
                evaluatedMoves.push({ move, eval: eval_ });

                restoreBoardState(savedState);

                if (showThinking) {
                    highlightThinking(move.fromRow, move.fromCol, move.toRow, move.toCol);
                    await new Promise(resolve => setTimeout(resolve, 20));
                }
            }

            // Use minimax for final decision
            const result = minimax(depth, -Infinity, Infinity, false, showThinking);

            const endTime = performance.now();

            // Update stats
            document.getElementById('nodesEval').textContent = nodesEvaluated.toLocaleString();
            document.getElementById('thinkTime').textContent = `${Math.round(endTime - startTime)}ms`;

            // Show thinking log
            evaluatedMoves.sort((a, b) => a.eval - b.eval);
            let logHtml = `<div>Depth: ${depth}, Nodes: ${nodesEvaluated.toLocaleString()}</div><br>`;
            evaluatedMoves.slice(0, 5).forEach((em, i) => {
                const moveStr = getMoveNotation(em.move);
                const isBest = result.move && em.move.fromRow === result.move.fromRow && 
                              em.move.fromCol === result.move.fromCol &&
                              em.move.toRow === result.move.toRow &&
                              em.move.toCol === result.move.toCol;
                logHtml += `<div class="move-eval ${isBest ? 'best' : ''}">${i+1}. ${moveStr}: ${(em.eval / 100).toFixed(2)}</div>`;
            });
            thinkingLog.innerHTML = logHtml;

            clearThinkingHighlights();
            spinner.classList.remove('active');

            if (result.move) {
                makeMove(result.move.fromRow, result.move.fromCol, result.move.toRow, result.move.toCol, true);
                renderBoard();
            }
        }

        function getMoveNotation(move) {
            const files = 'abcdefgh';
            const piece = PIECES[move.piece] || '';
            const from = files[move.fromCol] + (8 - move.fromRow);
            const to = files[move.toCol] + (8 - move.toRow);
            const capture = move.captured ? 'x' : '-';
            return `${piece}${from}${capture}${to}`;
        }

        function updateEvalBar() {
            const eval_ = evaluateBoard();
            const normalized = Math.max(0, Math.min(100, 50 + eval_ / 50));
            document.getElementById('evalBar').style.width = `${normalized}%`;
            document.getElementById('evalScore').textContent = (eval_ / 100).toFixed(2);
        }

        // UI Functions
        function newGame() {
            initBoard();
            selectedSquare = null;
            currentPlayer = 'white';
            moveHistory = [];
            capturedWhite = [];
            capturedBlack = [];
            gameOver = false;
            castlingRights = { K: true, Q: true, k: true, q: true };
            enPassantSquare = null;
            lastMove = null;

            document.getElementById('moveCount').textContent = '0';
            document.getElementById('nodesEval').textContent = '0';
            document.getElementById('thinkTime').textContent = '0ms';
            document.getElementById('thinkingLog').textContent = 'Waiting for your move...';

            renderBoard();
            updateStatus();
            updateCaptured();
        }

        function showHint() {
            if (gameOver || currentPlayer !== 'white') return;

            nodesEvaluated = 0;
            const result = minimax(getDifficulty(), -Infinity, Infinity, true);

            if (result.move) {
                clearThinkingHighlights();
                const fromSquare = document.querySelector(`[data-row="${result.move.fromRow}"][data-col="${result.move.fromCol}"]`);
                const toSquare = document.querySelector(`[data-row="${result.move.toRow}"][data-col="${result.move.toCol}"]`);
                if (fromSquare) fromSquare.classList.add('best-move');
                if (toSquare) toSquare.classList.add('best-move');

                document.getElementById('thinkingLog').innerHTML = 
                    `<div class="best">Suggested: ${getMoveNotation(result.move)}</div>
                    <div>Evaluation: ${(result.score / 100).toFixed(2)}</div>`;
            }
        }

        function undoMove() {
            if (moveHistory.length < 2) return;

            // Undo both player and AI move
            for (let i = 0; i < 2; i++) {
                const lastState = moveHistory.pop();
                if (lastState) {
                    board = lastState.board;
                    castlingRights = lastState.castlingRights;
                    enPassantSquare = lastState.enPassantSquare;

                    if (lastState.captured) {
                        const color = getPieceColor(lastState.piece);
                        if (color === 'white') capturedBlack.pop();
                        else capturedWhite.pop();
                    }
                }
            }

            currentPlayer = 'white';
            gameOver = false;
            lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;

            renderBoard();
            updateStatus();
            updateCaptured();
            document.getElementById('moveCount').textContent = moveHistory.length;
        }

        function toggleCheatMenu() {
            document.getElementById('cheatMenu').classList.toggle('active');
        }

        function toggleThinkingVisual() {
            showThinking = !showThinking;
            document.getElementById('toggleThinking').classList.toggle('active', showThinking);
        }

        function toggleBestMoves() {
            showBestMoves = !showBestMoves;
            document.getElementById('toggleBestMoves').classList.toggle('active', showBestMoves);
            if (showBestMoves) showHint();
            else clearThinkingHighlights();
        }

        function autoWin() {
            if (gameOver || currentPlayer !== 'white') return;

            // Find best move sequence using deeper search
            nodesEvaluated = 0;
            const result = minimax(Math.min(6, getDifficulty() + 2), -Infinity, Infinity, true);

            if (result.move) {
                makeMove(result.move.fromRow, result.move.fromCol, result.move.toRow, result.move.toCol);
                renderBoard();

                if (!gameOver) {
                    setTimeout(() => aiMove(), 300);
                }
            }
        }

        function skipTurn() {
            if (currentPlayer === 'black') {
                currentPlayer = 'white';
                updateStatus();
            }
        }

        function removeRandomPiece() {
            const blackPieces = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && isBlackPiece(board[r][c]) && board[r][c] !== 'k') {
                        blackPieces.push({ r, c });
                    }
                }
            }

            if (blackPieces.length > 0) {
                const idx = Math.floor(Math.random() * blackPieces.length);
                const { r, c } = blackPieces[idx];
                capturedBlack.push(board[r][c]);
                board[r][c] = '';
                renderBoard();
                updateCaptured();
            }
        }

        function promoteRandomPawn() {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === 'P') {
                        board[r][c] = 'Q';
                        renderBoard();
                        return;
                    }
                }
            }
        }

        // Difficulty slider
        document.getElementById('difficulty').addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            const labels = ['Beginner', 'Easy', 'Medium', 'Hard', 'Expert'];
            const descs = [
                'üå± Perfect for learning',
                'üòä Casual gameplay',
                '‚öñÔ∏è Balanced challenge',
                'üí™ Serious competition',
                'üß† Maximum difficulty'
            ];
            document.getElementById('difficultyLabel').textContent = `${labels[level-1]} (${level})`;
            document.getElementById('difficultyDesc').textContent = descs[level-1];
        });

        // Initialize
        initBoard();
        renderBoard();
    </script>
</body>
</html>
