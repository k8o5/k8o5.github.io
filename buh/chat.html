<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>On-Chain Images Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #ff6b6b, #ffd700, #00ff88, #00d9ff, #9d4edd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .methods-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .method-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            transition: all 0.3s;
        }

        .method-card:hover {
            border-color: rgba(157, 78, 221, 0.5);
            transform: translateY(-5px);
        }

        .method-card h3 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: #00d9ff;
        }

        .method-card p {
            color: rgba(255,255,255,0.6);
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            margin-right: 5px;
        }

        .badge-green { background: rgba(0,255,136,0.2); color: #00ff88; }
        .badge-yellow { background: rgba(255,215,0,0.2); color: #ffd700; }
        .badge-red { background: rgba(255,107,107,0.2); color: #ff6b6b; }

        .status-bar {
            background: rgba(255,255,255,0.05);
            padding: 15px 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .wallet-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
        }

        .status-dot.connected {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        .connect-btn {
            background: linear-gradient(90deg, #9945FF, #14F195);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .connect-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .connect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .upload-section {
            background: rgba(255,255,255,0.05);
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .upload-section:hover {
            border-color: #9945FF;
        }

        .upload-section.dragover {
            background: rgba(153, 69, 255, 0.1);
            border-color: #9945FF;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(90deg, #9945FF, #14F195);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 15px;
        }

        .preview-container {
            margin-top: 20px;
            display: none;
        }

        .preview-container.show {
            display: block;
        }

        .preview-image {
            max-width: 200px;
            max-height: 200px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .image-info {
            margin-top: 15px;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .send-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .send-option-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .send-option-btn:hover:not(:disabled) {
            background: rgba(153, 69, 255, 0.2);
            border-color: #9945FF;
        }

        .send-option-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .send-option-btn h4 {
            margin-bottom: 5px;
            color: #00d9ff;
        }

        .send-option-btn p {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
        }

        .chat-container {
            background: rgba(255,255,255,0.03);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .chat-header {
            background: rgba(0,0,0,0.4);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
        }

        .message {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            border-left: 3px solid #9945FF;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .message-sender {
            color: #00d9ff;
            font-family: monospace;
        }

        .message-time {
            color: rgba(255,255,255,0.4);
        }

        .message-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            margin-top: 10px;
        }

        .message-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: 10px;
        }

        .type-pixel { background: rgba(0,255,136,0.2); color: #00ff88; }
        .type-chunked { background: rgba(255,215,0,0.2); color: #ffd700; }
        .type-ipfs { background: rgba(0,217,255,0.2); color: #00d9ff; }

        .pixel-canvas-container {
            margin: 20px 0;
            text-align: center;
        }

        #pixelCanvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .canvas-controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .color-picker {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .canvas-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
        }

        .canvas-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .progress-bar {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #9945FF, #14F195);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .alert-error {
            background: rgba(255,71,87,0.15);
            border: 1px solid rgba(255,71,87,0.3);
            color: #ff6b6b;
        }

        .alert-success {
            background: rgba(0,255,136,0.15);
            border: 1px solid rgba(0,255,136,0.3);
            color: #00ff88;
        }

        .alert-info {
            background: rgba(0,217,255,0.15);
            border: 1px solid rgba(0,217,255,0.3);
            color: #00d9ff;
        }

        .tx-link {
            color: #9945FF;
            text-decoration: none;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .tx-link:hover {
            text-decoration: underline;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 12px 25px;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab:hover {
            background: rgba(255,255,255,0.1);
        }

        .tab.active {
            background: linear-gradient(90deg, rgba(153,69,255,0.3), rgba(20,241,149,0.3));
            border-color: #9945FF;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .size-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .size-table th, .size-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .size-table th {
            color: #00d9ff;
        }

        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.02);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(153, 69, 255, 0.4);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üñºÔ∏è On-Chain Images</h1>
            <p style="color: rgba(255,255,255,0.6);">Store images on Solana blockchain - multiple methods!</p>
        </header>

        <div id="alertContainer"></div>

        <!-- Methods Overview -->
        <div class="methods-grid">
            <div class="method-card">
                <h3>üé® Pixel Art (Direct)</h3>
                <p>Small 8x8 to 16x16 images stored directly in memo</p>
                <span class="badge badge-green">1 TX</span>
                <span class="badge badge-green">~$0.001</span>
                <span class="badge badge-green">Instant</span>
            </div>
            <div class="method-card">
                <h3>üß© Chunked Upload</h3>
                <p>Split larger images across multiple transactions</p>
                <span class="badge badge-yellow">10-100+ TX</span>
                <span class="badge badge-yellow">~$0.01-0.10</span>
                <span class="badge badge-yellow">Slow</span>
            </div>
            <div class="method-card">
                <h3>üåê IPFS + On-Chain</h3>
                <p>Store on IPFS, save hash on Solana</p>
                <span class="badge badge-green">1 TX</span>
                <span class="badge badge-green">~$0.001</span>
                <span class="badge badge-green">Best!</span>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="wallet-info">
                <div class="status-dot" id="statusDot"></div>
                <span id="walletAddress">Not Connected</span>
                <span id="tokenStatus" style="color: rgba(255,255,255,0.4)"></span>
            </div>
            <button class="connect-btn" id="connectBtn" onclick="connectWallet()">
                üîå Connect Phantom
            </button>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('pixel')">üé® Pixel Art</button>
            <button class="tab" onclick="switchTab('upload')">üì§ Upload Image</button>
            <button class="tab" onclick="switchTab('chat')">üí¨ View Gallery</button>
        </div>

        <!-- Pixel Art Tab -->
        <div id="pixelTab" class="tab-content active">
            <div class="method-card">
                <h3>üé® Draw Pixel Art (8x8)</h3>
                <p>Create tiny pixel art that fits in a single transaction memo!</p>
                
                <div class="pixel-canvas-container">
                    <canvas id="pixelCanvas" width="160" height="160"></canvas>
                    
                    <div class="canvas-controls">
                        <input type="color" id="colorPicker" class="color-picker" value="#ff0000">
                        <button class="canvas-btn" onclick="clearCanvas()">üóëÔ∏è Clear</button>
                        <button class="canvas-btn" onclick="fillRandom()">üé≤ Random</button>
                        <button class="canvas-btn" onclick="sendPixelArt()" id="sendPixelBtn" disabled>
                            ‚ö° Send On-Chain
                        </button>
                    </div>
                </div>

                <div class="image-info">
                    <p>üìê Size: 8x8 pixels = 64 pixels</p>
                    <p>üé® Colors: 16 palette (4-bit)</p>
                    <p>üì¶ Data size: ~50 bytes (fits in memo!)</p>
                    <p>üí∞ Cost: ~0.000005 SOL</p>
                </div>
            </div>
        </div>

        <!-- Upload Tab -->
        <div id="uploadTab" class="tab-content">
            <div class="upload-section" id="dropZone">
                <h3>üì§ Upload Image</h3>
                <p style="color: rgba(255,255,255,0.5); margin: 10px 0;">
                    Drag & drop or click to select
                </p>
                <input type="file" id="fileInput" class="file-input" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Choose Image
                </button>

                <div class="preview-container" id="previewContainer">
                    <img id="previewImage" class="preview-image">
                    <div class="image-info" id="imageInfo"></div>
                    
                    <div class="send-options">
                        <button class="send-option-btn" id="sendChunkedBtn" onclick="sendChunked()" disabled>
                            <h4>üß© Chunked On-Chain</h4>
                            <p id="chunkedInfo">Loading...</p>
                        </button>
                        <button class="send-option-btn" id="sendIPFSBtn" onclick="sendWithIPFS()" disabled>
                            <h4>üåê IPFS + Solana</h4>
                            <p>1 TX, ~0.000005 SOL</p>
                        </button>
                    </div>
                </div>
            </div>

            <div id="uploadProgress" style="display: none;">
                <h4>üì° Uploading to blockchain...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
                </div>
                <p id="progressText" style="text-align: center; color: rgba(255,255,255,0.5);"></p>
            </div>

            <!-- Size Reference -->
            <div class="method-card" style="margin-top: 20px;">
                <h3>üìä Size Reference</h3>
                <table class="size-table">
                    <tr>
                        <th>Image Size</th>
                        <th>Base64 Size</th>
                        <th>Transactions</th>
                        <th>Cost</th>
                    </tr>
                    <tr>
                        <td>8x8 pixel art</td>
                        <td>~50 bytes</td>
                        <td>1</td>
                        <td>~$0.001</td>
                    </tr>
                    <tr>
                        <td>32x32 icon</td>
                        <td>~2 KB</td>
                        <td>4-5</td>
                        <td>~$0.005</td>
                    </tr>
                    <tr>
                        <td>100x100 thumb</td>
                        <td>~15 KB</td>
                        <td>30-40</td>
                        <td>~$0.04</td>
                    </tr>
                    <tr>
                        <td>500x500 image</td>
                        <td>~200 KB</td>
                        <td>400+</td>
                        <td>~$0.40</td>
                    </tr>
                </table>
                <p style="color: #ffd700; margin-top: 10px;">
                    üí° For larger images, use IPFS method - it's way cheaper!
                </p>
            </div>
        </div>

        <!-- Chat/Gallery Tab -->
        <div id="chatTab" class="tab-content">
            <div class="chat-container">
                <div class="chat-header">
                    <h3>üñºÔ∏è On-Chain Gallery</h3>
                    <button class="canvas-btn" onclick="loadGallery()">üîÑ Refresh</button>
                </div>
                <div class="chat-messages" id="gallery">
                    <div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.4);">
                        <p>Images you send will appear here!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        
        const TOKEN_MINT = "3FkfFXtMDVkKJ6SAouMSK4qYFmErYxSnAUx6vP52pump";
        const MIN_TOKENS = 1;
        const RPC_ENDPOINT = "https://api.mainnet-beta.solana.com";
        const MEMO_PROGRAM_ID = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
        const CHUNK_SIZE = 500; // bytes per memo
        
        // ============================================
        // STATE
        // ============================================
        
        let wallet = null;
        let connection = null;
        let hasTokens = false;
        let currentImageData = null;
        let galleryItems = [];
        
        // Pixel art state
        const GRID_SIZE = 8;
        const PIXEL_SIZE = 20;
        let pixelColors = Array(GRID_SIZE * GRID_SIZE).fill('#000000');
        let currentColor = '#ff0000';
        
        // 16-color palette for compression
        const PALETTE = [
            '#000000', '#ffffff', '#ff0000', '#00ff00',
            '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
            '#ff8800', '#88ff00', '#0088ff', '#ff0088',
            '#888888', '#ff8888', '#88ff88', '#8888ff'
        ];
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            connection = new solanaWeb3.Connection(RPC_ENDPOINT, 'confirmed');
            initPixelCanvas();
            initFileUpload();
            loadGallery();
            
            if (window.solana?.isPhantom) {
                window.solana.connect({ onlyIfTrusted: true })
                    .then(handleConnected)
                    .catch(() => {});
            }
        });
        
        // ============================================
        // WALLET
        // ============================================
        
        async function connectWallet() {
            try {
                if (!window.solana?.isPhantom) {
                    showAlert("Please install Phantom wallet!", "error");
                    return;
                }
                
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('connectBtn').textContent = "Connecting...";
                
                const response = await window.solana.connect();
                await handleConnected(response);
                
            } catch (err) {
                showAlert("Connection failed: " + err.message, "error");
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('connectBtn').textContent = "üîå Connect Phantom";
            }
        }
        
        async function handleConnected(response) {
            wallet = response.publicKey;
            
            const short = wallet.toString().slice(0,4) + "..." + wallet.toString().slice(-4);
            document.getElementById('walletAddress').textContent = short;
            document.getElementById('statusDot').classList.add('connected');
            document.getElementById('connectBtn').textContent = "‚úì Connected";
            document.getElementById('connectBtn').disabled = true;
            
            await checkTokenBalance();
        }
        
        async function checkTokenBalance() {
            try {
                const mint = new solanaWeb3.PublicKey(TOKEN_MINT);
                const accounts = await connection.getParsedTokenAccountsByOwner(
                    wallet, { mint }
                );
                
                let balance = 0;
                if (accounts.value.length > 0) {
                    balance = accounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0;
                }
                
                if (balance >= MIN_TOKENS) {
                    hasTokens = true;
                    document.getElementById('tokenStatus').textContent = `‚úì ${balance} tokens`;
                    document.getElementById('tokenStatus').style.color = '#00ff88';
                    enableSending();
                    showAlert(`Verified! You hold ${balance} tokens`, "success");
                } else {
                    document.getElementById('tokenStatus').textContent = `‚úó Need tokens`;
                    document.getElementById('tokenStatus').style.color = '#ff6b6b';
                    showAlert(`You need at least ${MIN_TOKENS} token(s)`, "error");
                }
            } catch (err) {
                console.error(err);
            }
        }
        
        function enableSending() {
            document.getElementById('sendPixelBtn').disabled = false;
            if (currentImageData) {
                document.getElementById('sendChunkedBtn').disabled = false;
                document.getElementById('sendIPFSBtn').disabled = false;
            }
        }
        
        // ============================================
        // PIXEL ART CANVAS
        // ============================================
        
        function initPixelCanvas() {
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = GRID_SIZE * PIXEL_SIZE;
            canvas.height = GRID_SIZE * PIXEL_SIZE;
            
            // Draw grid
            drawPixelGrid();
            
            // Color picker
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                currentColor = e.target.value;
            });
            
            // Canvas click
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE);
                
                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                    const idx = y * GRID_SIZE + x;
                    pixelColors[idx] = currentColor;
                    drawPixelGrid();
                }
            });
            
            // Mouse drag
            let isDrawing = false;
            canvas.addEventListener('mousedown', () => isDrawing = true);
            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseleave', () => isDrawing = false);
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE);
                
                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                    const idx = y * GRID_SIZE + x;
                    pixelColors[idx] = currentColor;
                    drawPixelGrid();
                }
            });
        }
        
        function drawPixelGrid() {
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const idx = y * GRID_SIZE + x;
                    ctx.fillStyle = pixelColors[idx];
                    ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    
                    // Grid lines
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.strokeRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                }
            }
        }
        
        function clearCanvas() {
            pixelColors = Array(GRID_SIZE * GRID_SIZE).fill('#000000');
            drawPixelGrid();
        }
        
        function fillRandom() {
            for (let i = 0; i < pixelColors.length; i++) {
                pixelColors[i] = PALETTE[Math.floor(Math.random() * PALETTE.length)];
            }
            drawPixelGrid();
        }
        
        function compressPixelArt() {
            // Convert to palette indices (4-bit per pixel)
            const indices = pixelColors.map(color => {
                const idx = PALETTE.findIndex(p => p.toLowerCase() === color.toLowerCase());
                return idx >= 0 ? idx : 0;
            });
            
            // Pack 2 pixels per byte
            const bytes = [];
            for (let i = 0; i < indices.length; i += 2) {
                const byte = (indices[i] << 4) | (indices[i + 1] || 0);
                bytes.push(byte);
            }
            
            // Convert to base64
            const uint8 = new Uint8Array(bytes);
            let binary = '';
            uint8.forEach(b => binary += String.fromCharCode(b));
            return btoa(binary);
        }
        
        function decompressPixelArt(base64) {
            const binary = atob(base64);
            const colors = [];
            
            for (let i = 0; i < binary.length; i++) {
                const byte = binary.charCodeAt(i);
                const idx1 = (byte >> 4) & 0x0F;
                const idx2 = byte & 0x0F;
                colors.push(PALETTE[idx1], PALETTE[idx2]);
            }
            
            return colors.slice(0, GRID_SIZE * GRID_SIZE);
        }
        
        async function sendPixelArt() {
            if (!hasTokens) return;
            
            const btn = document.getElementById('sendPixelBtn');
            btn.disabled = true;
            btn.textContent = "Sending...";
            
            try {
                const compressed = compressPixelArt();
                const memoData = JSON.stringify({
                    type: 'pixel',
                    size: GRID_SIZE,
                    data: compressed,
                    ts: Date.now()
                });
                
                console.log("Memo size:", memoData.length, "bytes");
                
                const signature = await sendMemo(memoData);
                
                // Add to gallery
                galleryItems.push({
                    type: 'pixel',
                    data: compressed,
                    sender: wallet.toString(),
                    signature,
                    timestamp: Date.now()
                });
                saveGallery();
                
                showAlert(`Pixel art stored on-chain! TX: ${signature.slice(0,8)}...`, "success");
                
            } catch (err) {
                showAlert("Failed: " + err.message, "error");
            } finally {
                btn.disabled = false;
                btn.textContent = "‚ö° Send On-Chain";
            }
        }
        
        // ============================================
        // FILE UPLOAD
        // ============================================
        
        function initFileUpload() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file);
            });
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFile(file);
            });
        }
        
        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showAlert("Please select an image file", "error");
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64 = e.target.result;
                currentImageData = base64;
                
                // Show preview
                document.getElementById('previewImage').src = base64;
                document.getElementById('previewContainer').classList.add('show');
                
                // Calculate sizes
                const size = base64.length;
                const chunks = Math.ceil(size / CHUNK_SIZE);
                const cost = (chunks * 0.000005).toFixed(6);
                
                document.getElementById('imageInfo').innerHTML = `
                    <p>üì¶ Base64 size: ${(size / 1024).toFixed(2)} KB</p>
                    <p>üß© Chunks needed: ${chunks} transactions</p>
                    <p>üí∞ Estimated cost: ~${cost} SOL</p>
                `;
                
                document.getElementById('chunkedInfo').textContent = 
                    `${chunks} TXs, ~${cost} SOL`;
                
                if (hasTokens) {
                    document.getElementById('sendChunkedBtn').disabled = false;
                    document.getElementById('sendIPFSBtn').disabled = false;
                }
            };
            reader.readAsDataURL(file);
        }
        
        async function sendChunked() {
            if (!currentImageData || !hasTokens) return;
            
            const chunks = [];
            for (let i = 0; i < currentImageData.length; i += CHUNK_SIZE) {
                chunks.push(currentImageData.slice(i, i + CHUNK_SIZE));
            }
            
            const imageId = Date.now().toString(36);
            const progressEl = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressEl.style.display = 'block';
            document.getElementById('sendChunkedBtn').disabled = true;
            
            const signatures = [];
            
            try {
                for (let i = 0; i < chunks.length; i++) {
                    const progress = Math.round(((i + 1) / chunks.length) * 100);
                    progressFill.style.width = progress + '%';
                    progressFill.textContent = progress + '%';
                    progressText.textContent = `Sending chunk ${i + 1} of ${chunks.length}...`;
                    
                    const memoData = JSON.stringify({
                        type: 'chunk',
                        id: imageId,
                        idx: i,
                        total: chunks.length,
                        data: chunks[i]
                    });
                    
                    const sig = await sendMemo(memoData);
                    signatures.push(sig);
                    
                    // Small delay to avoid rate limiting
                    await new Promise(r => setTimeout(r, 500));
                }
                
                // Save to gallery
                galleryItems.push({
                    type: 'chunked',
                    imageId,
                    chunks: chunks.length,
                    data: currentImageData,
                    sender: wallet.toString(),
                    signatures,
                    timestamp: Date.now()
                });
                saveGallery();
                
                showAlert(`Image stored in ${chunks.length} on-chain transactions!`, "success");
                
            } catch (err) {
                showAlert("Upload failed: " + err.message, "error");
            } finally {
                progressEl.style.display = 'none';
                document.getElementById('sendChunkedBtn').disabled = false;
            }
        }
        
        async function sendWithIPFS() {
            if (!currentImageData || !hasTokens) return;
            
            document.getElementById('sendIPFSBtn').disabled = true;
            
            try {
                // For demo: Use a free IPFS pinning service
                // In production: Use Pinata, NFT.Storage, or Web3.Storage
                
                showAlert("Uploading to IPFS...", "info");
                
                // Convert base64 to blob
                const response = await fetch(currentImageData);
                const blob = await response.blob();
                
                // Upload to NFT.Storage (free!)
                // For demo, we'll simulate with a fake CID
                // In production, use: https://nft.storage
                
                // Simulated IPFS CID
                const fakeCID = 'Qm' + btoa(Date.now().toString()).replace(/[^a-zA-Z0-9]/g, '').slice(0, 44);
                
                // Store CID on Solana
                const memoData = JSON.stringify({
                    type: 'ipfs',
                    cid: fakeCID,
                    mime: blob.type,
                    size: blob.size,
                    ts: Date.now()
                });
                
                const signature = await sendMemo(memoData);
                
                // Save to gallery (with actual data for demo)
                galleryItems.push({
                    type: 'ipfs',
                    cid: fakeCID,
                    data: currentImageData, // In production, fetch from IPFS
                    sender: wallet.toString(),
                    signature,
                    timestamp: Date.now()
                });
                saveGallery();
                
                showAlert(`IPFS link stored on-chain! CID: ${fakeCID.slice(0,12)}...`, "success");
                
            } catch (err) {
                showAlert("Failed: " + err.message, "error");
            } finally {
                document.getElementById('sendIPFSBtn').disabled = false;
            }
        }
        
        // ============================================
        // SEND MEMO TRANSACTION
        // ============================================
        
        async function sendMemo(memoData) {
            const transaction = new solanaWeb3.Transaction();
            
            // Memo instruction
            const memoProgram = new solanaWeb3.PublicKey(MEMO_PROGRAM_ID);
            
            transaction.add(
                new solanaWeb3.TransactionInstruction({
                    keys: [{
                        pubkey: wallet,
                        isSigner: true,
                        isWritable: false
                    }],
                    programId: memoProgram,
                    data: Buffer.from(memoData)
                })
            );
            
            const { blockhash } = await connection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = wallet;
            
            const signed = await window.solana.signTransaction(transaction);
            const signature = await connection.sendRawTransaction(signed.serialize());
            await connection.confirmTransaction(signature, 'confirmed');
            
            return signature;
        }
        
        // ============================================
        // GALLERY
        // ============================================
        
        function saveGallery() {
            localStorage.setItem('onchain_gallery', JSON.stringify(galleryItems));
            renderGallery();
        }
        
        function loadGallery() {
            const stored = localStorage.getItem('onchain_gallery');
            if (stored) {
                galleryItems = JSON.parse(stored);
            }
            renderGallery();
        }
        
        function renderGallery() {
            const gallery = document.getElementById('gallery');
            
            if (galleryItems.length === 0) {
                gallery.innerHTML = `
                    <div style="text-align: center; padding: 60px; color: rgba(255,255,255,0.4);">
                        <h3>üñºÔ∏è No images yet</h3>
                        <p>Create pixel art or upload an image to get started!</p>
                    </div>
                `;
                return;
            }
            
            gallery.innerHTML = galleryItems.map(item => {
                const time = new Date(item.timestamp).toLocaleString();
                const shortSender = item.sender.slice(0,4) + '...' + item.sender.slice(-4);
                
                let imageHtml = '';
                let typeClass = '';
                let typeLabel = '';
                
                if (item.type === 'pixel') {
                    // Render pixel art
                    const colors = decompressPixelArt(item.data);
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 80;
                    const ctx = canvas.getContext('2d');
                    const ps = 10;
                    
                    colors.forEach((color, idx) => {
                        const x = idx % 8;
                        const y = Math.floor(idx / 8);
                        ctx.fillStyle = color;
                        ctx.fillRect(x * ps, y * ps, ps, ps);
                    });
                    
                    imageHtml = `<img src="${canvas.toDataURL()}" class="message-image" style="image-rendering: pixelated; width: 160px;">`;
                    typeClass = 'type-pixel';
                    typeLabel = 'PIXEL ART';
                    
                } else if (item.type === 'chunked') {
                    imageHtml = `<img src="${item.data}" class="message-image">`;
                    typeClass = 'type-chunked';
                    typeLabel = `CHUNKED (${item.chunks} TXs)`;
                    
                } else if (item.type === 'ipfs') {
                    imageHtml = `<img src="${item.data}" class="message-image">`;
                    typeClass = 'type-ipfs';
                    typeLabel = 'IPFS';
                }
                
                const sig = item.signature || (item.signatures ? item.signatures[0] : '');
                const solscanUrl = `https://solscan.io/tx/${sig}`;
                
                return `
                    <div class="message">
                        <div class="message-header">
                            <span>
                                <span class="message-sender">${shortSender}</span>
                                <span class="message-type ${typeClass}">${typeLabel}</span>
                            </span>
                            <span class="message-time">${time}</span>
                        </div>
                        ${imageHtml}
                        <div style="margin-top: 10px;">
                            <a href="${solscanUrl}" target="_blank" class="tx-link">
                                üîó View on Solscan
                            </a>
                        </div>
                    </div>
                `;
            }).reverse().join('');
        }
        
        // ============================================
        // UTILITY
        // ============================================
        
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tab + 'Tab').classList.add('active');
        }
        
        function showAlert(message, type) {
            const container = document.getElementById('alertContainer');
            container.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }
    </script>
</body>
</html>
