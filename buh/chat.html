<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana On-Chain Chat (Read & Write)</title>
    
    <!-- 1. REQUIRED LIBRARIES -->
    <script src="https://bundle.run/buffer@6.0.3"></script>
    <script>window.Buffer = window.buffer.Buffer;</script>
    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>

    <style>
        body { background: #050505; color: #00ff41; font-family: 'Courier New', monospace; padding: 20px; max-width: 800px; margin: 0 auto; }
        .box { border: 1px solid #333; padding: 20px; margin-bottom: 20px; background: #000; }
        h2 { margin-top: 0; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 10px; color: #fff; display: flex; justify-content: space-between; }
        
        /* CHAT HISTORY STYLES */
        #chatBox { 
            height: 400px; overflow-y: auto; border: 1px solid #222; padding: 10px; 
            background: #0a0a0a; display: flex; flex-direction: column-reverse; /* Newest at bottom visually if we prepend, or column if append */
        }
        .msg-row { margin-bottom: 12px; border-bottom: 1px solid #111; padding-bottom: 8px; }
        .msg-meta { font-size: 10px; color: #666; margin-bottom: 4px; }
        .msg-text { color: #fff; font-size: 14px; word-wrap: break-word; }
        .loading { text-align: center; color: #888; padding: 20px; }

        /* INPUT STYLES */
        input { background: #111; border: 1px solid #333; color: #fff; padding: 10px; width: 70%; }
        button { background: #00ff41; color: #000; border: none; padding: 10px 20px; font-weight: bold; cursor: pointer; width: 28%; }
        button:disabled { background: #333; color: #666; }
        
        .refresh-btn { background: transparent; border: 1px solid #333; color: #888; width: auto; font-size: 10px; padding: 2px 10px; }
        .refresh-btn:hover { border-color: #fff; color: #fff; }
    </style>
</head>
<body>

    <!-- 1. CONNECT -->
    <div class="box">
        <h2>
            STATUS: <span id="status">Checking...</span>
            <button class="refresh-btn" onclick="connectWallet()">CONNECT WALLET</button>
        </h2>
        <div id="walletAddr" style="font-size:12px; color:#666">Not Connected</div>
    </div>

    <!-- 2. CHAT HISTORY -->
    <div class="box">
        <h2>
            LIVE CHAT ($k8o5)
            <button class="refresh-btn" onclick="fetchMessages()">REFRESH</button>
        </h2>
        <div id="chatBox">
            <div class="loading">Loading blockchain history...</div>
        </div>
    </div>

    <!-- 3. SEND INPUT -->
    <div class="box">
        <div style="display:flex; justify-content:space-between;">
            <input type="text" id="msgInput" placeholder="Write a message on-chain..." disabled>
            <button id="sendBtn" onclick="sendMessage()" disabled>SEND</button>
        </div>
        <div id="txLog" style="font-size:10px; margin-top:10px; color:#888;"></div>
    </div>

    <script>
        // --- CONFIG ---
        const TARGET_WALLET = "3FkfFXtMDVkKJ6SAouMSK4qYFmErYxSnAUx6vP52pump"; 
        const RPC_URL = "https://solana-rpc.publicnode.com"; // Open Public RPC

        let provider = null;
        let connection = new solanaWeb3.Connection(RPC_URL, "confirmed");

        // --- INIT ---
        window.onload = () => {
            // 1. Look for Phantom
            setTimeout(() => {
                if (window.solana && window.solana.isPhantom) {
                    provider = window.solana;
                    document.getElementById('status').innerText = "Phantom Detected";
                    document.getElementById('status').style.color = "#00ff41";
                    if(provider.isConnected) handleConnect(provider.publicKey);
                } else {
                    document.getElementById('status').innerText = "Phantom Not Found";
                    document.getElementById('status').style.color = "red";
                }
            }, 500);

            // 2. Fetch History Immediately
            fetchMessages();
        };

        // --- READ MESSAGES (THE NEW PART) ---
        async function fetchMessages() {
            const chatBox = document.getElementById('chatBox');
            chatBox.innerHTML = '<div class="loading">Scanning Blockchain...</div>';

            try {
                const pubKey = new solanaWeb3.PublicKey(TARGET_WALLET);
                
                // 1. Get last 15 signatures for the chat wallet
                // Note: limit is low to prevent rate limiting on public RPCs
                const signatures = await connection.getSignaturesForAddress(pubKey, { limit: 15 });

                if (signatures.length === 0) {
                    chatBox.innerHTML = '<div class="loading">No messages found.</div>';
                    return;
                }

                chatBox.innerHTML = ''; // Clear loading

                // 2. Fetch details for each transaction to find the Memo
                // We do this concurrently (Promise.all) but be careful with public RPC limits
                const txs = await Promise.all(signatures.map(async (sigInfo) => {
                    try {
                        const tx = await connection.getParsedTransaction(sigInfo.signature, {
                            maxSupportedTransactionVersion: 0
                        });
                        return { tx, sig: sigInfo.signature, time: sigInfo.blockTime };
                    } catch (e) {
                        return null; 
                    }
                }));

                // 3. Parse and Display
                txs.filter(t => t).forEach(item => {
                    const logs = item.tx.meta.logMessages || [];
                    const sender = item.tx.transaction.message.accountKeys[0].pubkey.toString();
                    
                    // Look for Memo in logs
                    let memoText = null;
                    
                    // Pattern 1: Program log: Memo (len X): "TEXT"
                    const memoRegex = /Program log: Memo \(len \d+\): "(.*)"/;
                    
                    for (const log of logs) {
                        const match = log.match(memoRegex);
                        if (match) {
                            memoText = match[1];
                            break;
                        }
                    }

                    // If we found a memo, display it
                    if (memoText) {
                        addMessageToUI(sender, memoText, item.sig, item.time);
                    }
                });

            } catch (err) {
                console.error(err);
                chatBox.innerHTML = '<div class="loading" style="color:red">Error loading messages. Rate limit? Try Refresh.</div>';
            }
        }

        function addMessageToUI(sender, text, sig, timestamp) {
            const box = document.getElementById('chatBox');
            const row = document.createElement('div');
            row.className = 'msg-row';
            
            const date = new Date(timestamp * 1000).toLocaleTimeString();
            const shortAddr = sender.slice(0,4) + '...' + sender.slice(-4);

            row.innerHTML = `
                <div class="msg-meta">
                    <span style="color:#00ff41; font-weight:bold;">${shortAddr}</span> • ${date} • 
                    <a href="https://solscan.io/tx/${sig}" target="_blank" style="color:#666; text-decoration:none;">TX</a>
                </div>
                <div class="msg-text">${escapeHtml(text)}</div>
            `;
            box.appendChild(row);
        }

        // --- WRITE MESSAGES (EXISTING) ---
        async function connectWallet() {
            if(!provider) return alert("Install Phantom!");
            try {
                const resp = await provider.connect();
                handleConnect(resp.publicKey);
            } catch(e) { console.error(e); }
        }

        function handleConnect(pk) {
            document.getElementById('walletAddr').innerText = pk.toString();
            document.getElementById('msgInput').disabled = false;
            document.getElementById('sendBtn').disabled = false;
        }

        async function sendMessage() {
            const text = document.getElementById('msgInput').value;
            if(!text) return;
            
            const btn = document.getElementById('sendBtn');
            const log = document.getElementById('txLog');
            btn.disabled = true;
            btn.innerText = "SENDING...";

            try {
                const tx = new solanaWeb3.Transaction();
                const from = provider.publicKey;

                // 1. Memo Instruction
                tx.add(new solanaWeb3.TransactionInstruction({
                    keys: [{ pubkey: from, isSigner: true, isWritable: true }],
                    programId: new solanaWeb3.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),
                    data: Buffer.from(text, 'utf-8')
                }));

                // 2. Transfer 0 SOL (Required for signature visibility on target)
                tx.add(solanaWeb3.SystemProgram.transfer({
                    fromPubkey: from,
                    toPubkey: new solanaWeb3.PublicKey(TARGET_WALLET),
                    lamports: 0
                }));

                const { blockhash } = await connection.getLatestBlockhash();
                tx.recentBlockhash = blockhash;
                tx.feePayer = from;

                const { signature } = await provider.signAndSendTransaction(tx);
                
                log.innerText = "Sent! waiting for confirmation...";
                
                // Wait 2s then refresh
                setTimeout(() => {
                    document.getElementById('msgInput').value = "";
                    btn.innerText = "SEND";
                    btn.disabled = false;
                    log.innerHTML = `<a href="https://solscan.io/tx/${signature}" target="_blank" style="color:#00ff41">Success! View TX</a>`;
                    fetchMessages(); // Auto refresh chat
                }, 2000);

            } catch(err) {
                console.error(err);
                log.innerText = "Error: " + err.message;
                btn.disabled = false;
                btn.innerText = "SEND";
            }
        }

        function escapeHtml(text) {
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>
