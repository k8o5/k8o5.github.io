<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gif 31 - Lite</title>
    <!-- GIF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <!-- Auto-generated Favicon -->
    <link id="favicon" rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">

    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --accent: #f43f5e; /* Changed to Rose for the "Lite/Fast" feel */
            --accent-hover: #e11d48;
            --text-main: #f8fafc;
            --text-sub: #94a3b8;
            --success: #10b981;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at bottom right, #3f1b25, var(--bg-color));
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }

        /* Glassmorphism Card */
        .glass-panel {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 40px;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
            transition: transform 0.3s ease;
        }

        h1 { margin: 0 0 10px 0; font-weight: 700; letter-spacing: -0.5px; }
        p.subtitle { margin: 0 0 30px 0; color: var(--text-sub); font-size: 0.95rem; }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-zone:hover {
            border-color: var(--accent);
            background: rgba(244, 63, 94, 0.1);
        }

        .upload-zone input {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0; opacity: 0; cursor: pointer;
        }

        .icon-upload {
            width: 48px; height: 48px; fill: var(--text-sub); margin-bottom: 15px; transition: fill 0.2s;
        }
        .upload-zone:hover .icon-upload { fill: var(--accent); }

        /* Progress Bar */
        .progress-wrapper {
            margin-top: 30px;
            display: none;
            text-align: left;
        }
        
        .progress-labels { display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--text-sub); margin-bottom: 8px; }

        .progress-track {
            background: rgba(255,255,255,0.1);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #fb7185);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--accent);
        }

        /* Result Area */
        .result-area { display: none; margin-top: 30px; animation: fadeIn 0.5s ease; }
        
        img.gif-preview {
            width: 100%;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .stats-badge {
            display: inline-block;
            background: rgba(0,0,0,0.3);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--text-sub);
            margin-top: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .btn-download {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
            text-decoration: none;
        }
        .btn-download:hover { background: var(--accent-hover); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        svg { pointer-events: none; }
    </style>
</head>
<body>

<div class="glass-panel">
    <h1>Gif 31 <span style="font-weight:300; opacity:0.6;">Lite</span></h1>
    <p class="subtitle">31 FPS • Discord Ready (&lt;4MB) • Local</p>

    <div class="upload-zone" id="dropZone">
        <input type="file" id="uploadInput" accept="video/*">
        <!-- Self-contained SVG Icon -->
        <svg class="icon-upload" viewBox="0 0 24 24">
            <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/>
        </svg>
        <div style="font-weight: 600;">Click to Select Video</div>
        <div style="font-size: 0.8rem; color: var(--text-sub); margin-top: 5px;">Optimized for under 4MB</div>
    </div>

    <div class="progress-wrapper" id="progressWrapper">
        <div class="progress-labels">
            <span id="statusText">Initializing...</span>
            <span id="pctText">0%</span>
        </div>
        <div class="progress-track">
            <div class="progress-fill" id="progressBar"></div>
        </div>
    </div>

    <div class="result-area" id="resultArea">
        <img id="outputImg" class="gif-preview" alt="GIF Result">
        <div class="stats-badge" id="fileStats">Size: Calculating...</div>
        <br>
        <a id="downloadLink" class="btn-download" download="sleek-31fps-lite.gif">
            <svg style="width:20px;height:20px;fill:currentColor" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
            Download GIF
        </a>
    </div>
</div>

<!-- Hidden Canvas/Video for processing -->
<canvas id="canvas" style="display:none;"></canvas>

<script>
    // --- Elements ---
    const uploadInput = document.getElementById('uploadInput');
    const dropZone = document.getElementById('dropZone');
    const progressWrapper = document.getElementById('progressWrapper');
    const progressBar = document.getElementById('progressBar');
    const statusText = document.getElementById('statusText');
    const pctText = document.getElementById('pctText');
    const resultArea = document.getElementById('resultArea');
    const outputImg = document.getElementById('outputImg');
    const downloadLink = document.getElementById('downloadLink');
    const fileStats = document.getElementById('fileStats');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    // --- Worker Loader (Bypass CORS) ---
    let workerUrl = '';
    (async () => {
        try {
            const res = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
            const blob = await res.blob();
            workerUrl = URL.createObjectURL(blob);
        } catch(e) { console.error("Network error loading worker"); }
    })();

    // --- Drag & Drop Visuals ---
    ['dragenter', 'dragover'].forEach(evt => {
        dropZone.addEventListener(evt, (e) => { e.preventDefault(); dropZone.style.borderColor = 'var(--accent)'; });
    });
    ['dragleave', 'drop'].forEach(evt => {
        dropZone.addEventListener(evt, (e) => { dropZone.style.borderColor = ''; });
    });

    // --- Main Logic ---
    uploadInput.addEventListener('change', startProcess);

    async function startProcess(e) {
        if (!workerUrl) return alert("System initializing, please wait 2 seconds and try again.");
        const file = e.target.files[0];
        if (!file) return;

        // UI Reset
        resultArea.style.display = 'none';
        progressWrapper.style.display = 'block';
        dropZone.style.display = 'none';
        updateProgress(0, "Analyzing video...");

        // Load Video
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.muted = true;
        await new Promise(r => video.onloadedmetadata = r);

        // --- THE 4MB OPTIMIZER ALGORITHM ---
        const FPS = 31;
        const duration = video.duration;
        const totalFrames = Math.floor(duration * FPS);
        
        // Target safe size: 3.8MB (in bytes) to ensure we stay under 4MB limit
        const MAX_BYTES = 3.8 * 1024 * 1024; 
        
        // Heuristic: We estimate 0.8 bytes per pixel for a quality GIF.
        // We add a safety buffer of 0.85 because lower resolutions compress slightly worse per-pixel relative to headers.
        const allowedPixelsPerFrame = MAX_BYTES / (totalFrames * 0.85); 
        
        // Calculate Scale
        const currentPixels = video.videoWidth * video.videoHeight;
        let scale = Math.sqrt(allowedPixelsPerFrame / currentPixels);
        
        // Hard Constraints
        if (scale > 1) scale = 1; // Don't upscale
        
        let width = Math.floor(video.videoWidth * scale);
        let height = Math.floor(video.videoHeight * scale);

        // Sanity Check for very long videos to prevent microscopic output
        // If it's too small, we just have to accept it might go over 4MB or look crunchy,
        // but we ensure it's at least visible.
        if (width < 200 && video.videoWidth > 200) {
            // A small boost if calculations resulted in a tiny stamp
            width = 240; 
            height = Math.floor(width * (video.videoHeight / video.videoWidth));
        }
        
        // Hard Cap on Max Width (4MB is small, 1080p is impossible)
        if (width > 500) {
            width = 500;
            height = Math.floor(width * (video.videoHeight / video.videoWidth));
        }

        canvas.width = width;
        canvas.height = height;

        updateProgress(5, `Optimization: Resizing to ${width}x${height}...`);

        // Init GIF.js
        const gif = new GIF({
            workers: 4, 
            quality: 15, // 15 provides a balance. Lower number = better quality but bigger size. 10 is std, 20 is web-safe.
            width: width,
            height: height,
            workerScript: workerUrl,
            dither: 'FloydSteinberg' // Standard dither, slightly better compression than serpentine
        });

        // --- Frame Capture ---
        const interval = 1 / FPS;
        let currentTime = 0;

        const captureFrame = async () => {
            if (currentTime >= duration) {
                updateProgress(100, "Compiling binary...");
                gif.render();
                return;
            }

            video.currentTime = currentTime;
            await new Promise(r => video.onseeked = r);

            ctx.drawImage(video, 0, 0, width, height);
            
            // 32ms delay approx 31.25 FPS
            gif.addFrame(ctx, { copy: true, delay: 32 });

            const pct = Math.round((currentTime / duration) * 90); 
            updateProgress(pct, `Capturing frame ${Math.floor(currentTime*FPS)}/${totalFrames}`);

            currentTime += interval;
            setTimeout(captureFrame, 0); 
        };

        // --- On Finish ---
        gif.on('finished', (blob) => {
            const url = URL.createObjectURL(blob);
            
            outputImg.src = url;
            downloadLink.href = url;
            
            const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
            fileStats.innerText = `Size: ${sizeMB} MB • ${width}x${height}px @ 31FPS`;
            
            // Visual feedback if we missed the mark slightly (rare with this algo)
            if (blob.size > 4 * 1024 * 1024) {
                fileStats.style.color = '#fb7185';
                fileStats.innerText += ' (Slightly Over)';
            } else {
                fileStats.style.color = 'var(--success)';
            }

            progressWrapper.style.display = 'none';
            resultArea.style.display = 'block';
            dropZone.style.display = 'block'; 
        });

        captureFrame();
    }

    function updateProgress(pct, text) {
        progressBar.style.width = `${pct}%`;
        pctText.innerText = `${pct}%`;
        statusText.innerText = text;
    }
</script>

</body>
</html>
