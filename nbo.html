<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON BATTLE ONLINE</title>
    
    <!-- PeerJS & QRCode -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            user-select: none;
        }
        
        /* UI OVERLAYS */
        .screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; background: rgba(5,5,5,0.95); flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        .active { display: flex !important; }

        h1 { font-size: 40px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px rgba(0, 240, 255, 0.7); margin-bottom: 30px; }
        h2 { color: #ff0055; text-shadow: 0 0 10px #ff0055; }
        
        button {
            background: transparent; border: 2px solid #00f0ff; color: #00f0ff;
            padding: 15px 40px; font-size: 18px; font-family: inherit; cursor: pointer;
            transition: 0.2s; box-shadow: 0 0 10px #00f0ff; margin: 10px;
            text-transform: uppercase; font-weight: bold;
        }
        button:hover { background: #00f0ff; color: black; box-shadow: 0 0 30px #00f0ff; }
        
        input { 
            background: #111; border: 2px solid #555; color: white; padding: 15px; 
            font-size: 20px; text-align: center; text-transform: uppercase; margin-bottom: 10px;
        }

        /* IN GAME UI */
        #ui-layer { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 10; display: none; }
        .score-board { display: flex; justify-content: center; gap: 50px; font-size: 40px; font-weight: bold; }
        #p1-score { color: #00f0ff; text-shadow: 0 0 20px #00f0ff; }
        #p2-score { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
        #connection-status { font-size: 12px; color: #666; margin-top: 5px; }

        #qrcode { background: white; padding: 10px; margin: 20px; border-radius: 4px; }
        .lobby-code { font-size: 30px; letter-spacing: 5px; color: #ff0055; margin: 10px 0; font-weight: bold; }
        
        canvas { display: block; }
    </style>
</head>
<body>

    <!-- 1. MENU SCREEN -->
    <div id="menu-screen" class="screen active">
        <h1>NEON BATTLE <br><span style="font-size:20px; color:#fff;">ONLINE</span></h1>
        <button onclick="createLobby()">HOST GAME</button>
        <div style="margin-top:30px; border-top: 1px solid #333; padding-top:20px;">
            <input type="text" id="join-input" placeholder="CODE" maxlength="4">
            <br>
            <button onclick="joinLobby()" style="border-color: #ff0055; color: #ff0055; box-shadow: 0 0 10px #ff0055;">JOIN GAME</button>
        </div>
    </div>

    <!-- 2. LOBBY SCREEN -->
    <div id="lobby-screen" class="screen">
        <h2>WAITING FOR PLAYER...</h2>
        <div class="lobby-code" id="display-code">...</div>
        <div id="qrcode"></div>
        <p>Scan to join or enter code.</p>
        <button onclick="location.reload()" style="font-size:12px; padding: 10px;">CANCEL</button>
    </div>

    <!-- 3. GAME UI -->
    <div id="ui-layer">
        <div class="score-board">
            <div id="p1-score">0</div>
            <div>:</div>
            <div id="p2-score">0</div>
        </div>
        <div id="connection-status">CONNECTED</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/** 
 * NETZWERK KONFIGURATION
 */
const PREFIX = "gh-neon-battle-";
let peer = null;
let conn = null;
let isHost = false;
let myRole = null; // 'p1' (Blue/Host) or 'p2' (Red/Guest)

// Globale Input Zust채nde (werden 체bers Netzwerk gesendet)
let localKeys = { u: false, d: false, l: false, r: false, fire: false };
let remoteKeys = { u: false, d: false, l: false, r: false, fire: false };

/** 
 * AUDIO ENGINE
 */
const AudioEngine = {
    ctx: null,
    init: function() {
        if(this.ctx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq/4, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot: function() { this.playTone(400, 'square', 0.1, 0.1); },
    explode: function() { this.playTone(100, 'sawtooth', 0.3, 0.2); }
};

/**
 * GAME ENGINE SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// Resize handling
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// UI Elements
const screens = {
    menu: document.getElementById('menu-screen'),
    lobby: document.getElementById('lobby-screen'),
    game: document.getElementById('ui-layer')
};

function showScreen(name) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    if(screens[name]) screens[name].classList.add('active');
    if(name === 'game') screens.game.style.display = 'block';
}

// Auto Join via URL
window.onload = () => {
    const params = new URLSearchParams(window.location.search);
    if(params.has('join')) {
        document.getElementById('join-input').value = params.get('join');
        joinLobby();
    }
};

/**
 * PEERJS LOGIC
 */
function createLobby() {
    AudioEngine.init();
    const code = Math.random().toString(36).substring(2, 6).toUpperCase();
    showScreen('lobby');
    document.getElementById('display-code').innerText = code;
    
    // QR Code
    const url = window.location.href.split('?')[0] + '?join=' + code;
    document.getElementById('qrcode').innerHTML = "";
    new QRCode(document.getElementById("qrcode"), { text: url, width: 150, height: 150 });

    peer = new Peer(PREFIX + code);
    
    peer.on('open', (id) => { isHost = true; myRole = 'p1'; });
    
    peer.on('connection', (c) => {
        conn = c;
        setupConnection();
    });
}

function joinLobby() {
    AudioEngine.init();
    const code = document.getElementById('join-input').value.toUpperCase().trim();
    if(code.length < 3) return alert("Code too short");

    peer = new Peer();
    peer.on('open', () => {
        conn = peer.connect(PREFIX + code);
        isHost = false; 
        myRole = 'p2';
        setupConnection();
    });
    
    peer.on('error', () => { alert("Lobby not found"); location.href = window.location.href.split('?')[0]; });
}

function setupConnection() {
    conn.on('open', () => {
        showScreen('game'); // Close menus
        startGame();
    });

    conn.on('data', (data) => {
        if (isHost) {
            // HOST empf채ngt Input vom Gast
            if(data.type === 'input') remoteKeys = data.keys;
        } else {
            // GAST empf채ngt Game State vom Host
            if(data.type === 'state') renderGameState(data);
        }
    });
    
    conn.on('close', () => { alert("Connection lost"); location.reload(); });
}

// INPUT HANDLING
window.addEventListener('keydown', e => updateInput(e.code, true));
window.addEventListener('keyup', e => updateInput(e.code, false));

function updateInput(code, isPressed) {
    let changed = false;
    // Map Arrows AND WASD to the same standard control scheme
    if(code === 'ArrowUp' || code === 'KeyW') { localKeys.u = isPressed; changed = true; }
    if(code === 'ArrowDown' || code === 'KeyS') { localKeys.d = isPressed; changed = true; }
    if(code === 'ArrowLeft' || code === 'KeyA') { localKeys.l = isPressed; changed = true; }
    if(code === 'ArrowRight' || code === 'KeyD') { localKeys.r = isPressed; changed = true; }
    if(code === 'Space' || code === 'Enter') { localKeys.fire = isPressed; changed = true; }

    // Send input to Host immediately if we are the Guest
    if (!isHost && conn && conn.open && changed) {
        conn.send({ type: 'input', keys: localKeys });
    }
}

/**
 * GAME LOGIC
 */

// Config
const CONFIG = { friction: 0.92, accel: 1.5, maxSpeed: 8, bulletSpeed: 12, fireRate: 15 };

// Entities
let players = {
    p1: { x: 0, y: 0, vx: 0, vy: 0, angle: 0, color: '#00f0ff', dead: false, cd: 0 },
    p2: { x: 0, y: 0, vx: 0, vy: 0, angle: 0, color: '#ff0055', dead: false, cd: 0 }
};
let bullets = [];
let particles = [];
let scores = { p1: 0, p2: 0 };
let shakeTime = 0;

function resetGame() {
    players.p1.x = width * 0.2; players.p1.y = height / 2;
    players.p2.x = width * 0.8; players.p2.y = height / 2;
    players.p1.vx = 0; players.p1.vy = 0;
    players.p2.vx = 0; players.p2.vy = 0;
    players.p1.dead = false; players.p2.dead = false;
    bullets = [];
}

// UPDATE LOOP (Nur Host)
function updatePhysics() {
    // 1. Inputs verarbeiten
    // P1 ist Host (localKeys), P2 ist Gast (remoteKeys)
    applyMovement(players.p1, localKeys);
    applyMovement(players.p2, remoteKeys);

    // 2. Bullets
    bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy; b.life--;
        // Collision
        if(!b.dead) {
            checkHit(b, players.p1, 'p1');
            checkHit(b, players.p2, 'p2');
        }
    });
    // Cleanup Bullets
    bullets = bullets.filter(b => b.life > 0 && !b.dead && b.x > 0 && b.x < width && b.y > 0 && b.y < height);

    // 3. Particles
    particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.alpha -= 0.03;
    });
    particles = particles.filter(p => p.alpha > 0);

    // 4. Respawn Logic
    ['p1', 'p2'].forEach(pid => {
        if(players[pid].dead) {
            players[pid].cd--; // reusing cooldown var for respawn timer
            if(players[pid].cd <= 0) {
                players[pid].dead = false;
                players[pid].x = (pid === 'p1') ? width * 0.2 : width * 0.8;
                players[pid].y = height/2;
                players[pid].vx = 0; players[pid].vy = 0;
            }
        }
    });

    if(shakeTime > 0) shakeTime--;
}

function applyMovement(p, input) {
    if(p.dead) return;

    if(input.u) p.vy -= CONFIG.accel;
    if(input.d) p.vy += CONFIG.accel;
    if(input.l) p.vx -= CONFIG.accel;
    if(input.r) p.vx += CONFIG.accel;

    p.vx *= CONFIG.friction; p.vy *= CONFIG.friction;
    p.x += p.vx; p.y += p.vy;

    // Walls
    if(p.x < 20) { p.x = 20; p.vx *= -0.5; }
    if(p.x > width-20) { p.x = width-20; p.vx *= -0.5; }
    if(p.y < 20) { p.y = 20; p.vy *= -0.5; }
    if(p.y > height-20) { p.y = height-20; p.vy *= -0.5; }

    // Angle
    if(Math.abs(p.vx) > 0.1 || Math.abs(p.vy) > 0.1) p.angle = Math.atan2(p.vy, p.vx);

    // Shoot
    if(p.cd > 0) p.cd--;
    if(input.fire && p.cd <= 0) {
        let ang = p.angle;
        // Aim default if still
        if(Math.abs(p.vx)<0.5 && Math.abs(p.vy)<0.5) ang = (p.color === '#00f0ff') ? 0 : Math.PI;
        
        bullets.push({ 
            x: p.x + Math.cos(ang)*25, y: p.y + Math.sin(ang)*25, 
            vx: Math.cos(ang)*CONFIG.bulletSpeed, vy: Math.sin(ang)*CONFIG.bulletSpeed,
            color: p.color, life: 60, dead: false
        });
        
        // Recoil
        p.vx -= Math.cos(ang)*2; p.vy -= Math.sin(ang)*2;
        p.cd = CONFIG.fireRate;
        
        // Host sound immediately, sends sound event in state later
        AudioEngine.shoot(); 
    }
}

function checkHit(b, p, pid) {
    if(p.dead || b.color === p.color) return;
    const dx = b.x - p.x;
    const dy = b.y - p.y;
    if(Math.sqrt(dx*dx + dy*dy) < 25) {
        // HIT
        p.dead = true;
        p.cd = 120; // Respawn timer
        b.dead = true;
        createExplosion(p.x, p.y, p.color);
        AudioEngine.explode();
        shakeTime = 15;
        
        if(pid === 'p1') scores.p2++;
        else scores.p1++;
    }
}

function createExplosion(x, y, col) {
    for(let i=0; i<20; i++) {
        const ang = Math.random()*Math.PI*2;
        const spd = Math.random()*5+2;
        particles.push({ 
            x: x, y: y, 
            vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, 
            color: col, alpha: 1 
        });
    }
}

// LOOP
function startGame() {
    resetGame();
    requestAnimationFrame(loop);
}

function loop() {
    if(isHost) {
        updatePhysics();
        // Send State to Guest
        if(conn && conn.open) {
            conn.send({
                type: 'state',
                p1: { x: players.p1.x, y: players.p1.y, angle: players.p1.angle, dead: players.p1.dead },
                p2: { x: players.p2.x, y: players.p2.y, angle: players.p2.angle, dead: players.p2.dead },
                bullets: bullets.map(b => ({x:Math.round(b.x), y:Math.round(b.y), color:b.color})), // Optimize size
                particles: particles.map(p => ({x:Math.round(p.x), y:Math.round(p.y), color:p.color, alpha:p.alpha})),
                scores: scores,
                shake: shakeTime
            });
        }
        draw();
    }
    requestAnimationFrame(loop);
}

// GAST RENDERER
function renderGameState(state) {
    // Apply state from Host
    players.p1.x = state.p1.x; players.p1.y = state.p1.y; players.p1.angle = state.p1.angle; players.p1.dead = state.p1.dead;
    players.p2.x = state.p2.x; players.p2.y = state.p2.y; players.p2.angle = state.p2.angle; players.p2.dead = state.p2.dead;
    bullets = state.bullets;
    particles = state.particles;
    scores = state.scores;
    shakeTime = state.shake;
    
    // Simple sound trigger detection (if particles spawn, explode happened)
    // In a real robust engine, we'd send events. This is a visual approximation.
    
    draw();
}

function draw() {
    // Clear / Trail
    ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
    ctx.fillRect(0, 0, width, height);

    // Screen Shake
    ctx.save();
    if(shakeTime > 0) {
        const mag = shakeTime / 2;
        ctx.translate((Math.random()-0.5)*mag, (Math.random()-0.5)*mag);
        if(!isHost) shakeTime--; // Guest decreases visual shake locally
    }

    // Grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    for (let x = 0; x < width; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); }
    for (let y = 0; y < height; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }

    // Draw Entities
    drawPlayer(players.p1);
    drawPlayer(players.p2);

    bullets.forEach(b => {
        ctx.shadowBlur = 10; ctx.shadowColor = b.color; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
    });
    ctx.shadowBlur = 0;

    particles.forEach(p => {
        ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // UI Updates
    document.getElementById('p1-score').innerText = scores.p1;
    document.getElementById('p2-score').innerText = scores.p2;

    ctx.restore();
}

function drawPlayer(p) {
    if(p.dead) return;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);
    ctx.shadowBlur = 20; ctx.shadowColor = p.color;
    ctx.fillStyle = '#000'; ctx.strokeStyle = p.color; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(20, 0); ctx.lineTo(-20, -15); ctx.lineTo(-10, 0); ctx.lineTo(-20, 15);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.restore();
}

</script>
</body>
</html>
