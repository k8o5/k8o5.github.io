<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>FIFA-Abklatsch (Mini 2D)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; background: #0b4628;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff; user-select: none; overflow: hidden;
    }
    #wrap {
      display: flex; align-items: center; justify-content: center;
      height: 100%;
    }
    canvas {
      background: #1c7d3b;
      border-radius: 10px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      image-rendering: pixelated;
    }
    #overlay {
      position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 14px; align-items: center;
      font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,0.5);
      pointer-events: none;
    }
    #help {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      opacity: 0.9; font-size: 14px; text-align: center;
      pointer-events: none;
    }
    .score {
      padding: 6px 12px; background: rgba(0,0,0,0.3); border-radius: 6px;
      letter-spacing: 1px;
    }
    #centerMsg {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      font-size: 42px; font-weight: 800; text-shadow: 0 4px 16px rgba(0,0,0,0.7);
      display: none;
    }
    a { color: #fff; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540"></canvas>
    <div id="overlay">
      <div id="timer" class="score">02:00</div>
      <div id="score" class="score">YOU 0 - 0 CPU</div>
    </div>
    <div id="centerMsg"></div>
    <div id="help">
      Steuerung: WASD / Pfeiltasten bewegen, Leertaste schießen. R: Neustart
    </div>
  </div>
  <script>
  ;(() => {
    // Utilities
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const len = (x, y) => Math.hypot(x, y);
    const norm = (x, y) => {
      const l = Math.hypot(x, y);
      return l ? {x: x / l, y: y / l} : {x: 0, y: 0};
    };
    const rand = (a, b) => a + Math.random() * (b - a);
    const nowMs = () => performance.now();

    // Game setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const CENTER = { x: W / 2, y: H / 2 };
    const GOAL_OPEN = 160; // Höhe der Tormündung (oben/unten an den Seiten)
    const GOAL_TOP = CENTER.y - GOAL_OPEN / 2;
    const GOAL_BOT = CENTER.y + GOAL_OPEN / 2;

    const COLORS = {
      pitch: '#1c7d3b',
      lines: '#ffffff',
      ball: '#fafafa',
      you: '#4ef3ff',
      cpu: '#ff7369',
      shadow: 'rgba(0,0,0,0.35)'
    };

    // Input
    const keys = Object.create(null);
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase()) ||
          ['w','a','s','d','r'].includes(k)) {
        e.preventDefault();
      }
      keys[k] = true;
    }, { passive: false });
    window.addEventListener('keyup', e => {
      const k = e.key.toLowerCase();
      keys[k] = false;
    });

    // SFX (WebAudio einfacher Piep)
    const audio = new (window.AudioContext || window.webkitAudioContext)();
    function beep({ freq=440, dur=0.07, type='sine', vol=0.05, decay=0.03 }={}) {
      const t0 = audio.currentTime;
      const osc = audio.createOscillator();
      const gain = audio.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);
      gain.gain.setValueAtTime(vol, t0);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur + decay);
      osc.connect(gain).connect(audio.destination);
      osc.start(t0);
      osc.stop(t0 + dur + decay + 0.01);
    }
    function kickSfx(){ beep({ freq: 220, dur: 0.05, type: 'square', vol: 0.08 }); }
    function bounceSfx(){ beep({ freq: 440, dur: 0.04, type: 'sine', vol: 0.03 }); }
    function goalSfx(){ beep({ freq: 740, dur: 0.12, type: 'triangle', vol: 0.12 }); setTimeout(()=>beep({freq:540, dur:0.1, vol:0.12}),110); }

    // Entities
    const ball = {
      x: CENTER.x, y: CENTER.y, r: 10,
      vx: 0, vy: 0,
      maxSpeed: 520
    };
    function resetBall(toRight = Math.random() < 0.5) {
      ball.x = CENTER.x; ball.y = CENTER.y;
      const sp = 320, ang = (Math.random() * 0.6 - 0.3);
      ball.vx = (toRight ? 1 : -1) * sp * Math.cos(ang);
      ball.vy = sp * Math.sin(ang);
    }

    function makePlayer(x, y, color, speed=270) {
      return { x, y, r: 16, color, vx: 0, vy: 0, speed };
    }
    const player = makePlayer(W*0.25, CENTER.y, COLORS.you, 290);
    const cpu = makePlayer(W*0.75, CENTER.y, COLORS.cpu, 260);
    const team = [player, cpu];

    // AI settings
    const AI = {
      chaseRadius: 500,
      defendX: W * 0.72,
      targetIdle: { x: W * 0.7, y: H * 0.5 },
      kickBias: 0.7, // wahrscheinlichkeit in Richtung gegnerisches Tor zu schießen
    };

    // Game state
    let score = { you: 0, cpu: 0 };
    let timeLeft = 120; // seconds
    let last = nowMs();
    let paused = false;
    let messageTimer = 0;

    const uiScore = document.getElementById('score');
    const uiTimer = document.getElementById('timer');
    const uiCenter = document.getElementById('centerMsg');

    function setCenterMsg(text, time=1200) {
      uiCenter.textContent = text;
      uiCenter.style.display = 'block';
      messageTimer = time;
    }

    function fmtTime(s) {
      s = Math.max(0, Math.floor(s));
      const m = Math.floor(s/60);
      const ss = s % 60;
      return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }

    function resetPositions(kickToRight=false) {
      player.x = W*0.25; player.y = CENTER.y; player.vx = player.vy = 0;
      cpu.x = W*0.75; cpu.y = CENTER.y; cpu.vx = cpu.vy = 0;
      resetBall(kickToRight);
    }

    function restartMatch() {
      score.you = 0; score.cpu = 0;
      timeLeft = 120;
      paused = false;
      resetPositions(Math.random() < 0.5);
      setCenterMsg('Anpfiff!', 1000);
      uiScore.textContent = `YOU ${score.you} - ${score.cpu} CPU`;
      uiTimer.textContent = fmtTime(timeLeft);
    }

    function update(dt) {
      if (paused) return;

      // Timer
      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        paused = true;
        setCenterMsg('Abpfiff! (R = Neustart)', 4000);
      }
      uiTimer.textContent = fmtTime(timeLeft);

      // Input for player
      const up = keys['w'] || keys['arrowup'];
      const down = keys['s'] || keys['arrowdown'];
      const left = keys['a'] || keys['arrowleft'];
      const right = keys['d'] || keys['arrowright'];
      let mx = (right?1:0) - (left?1:0);
      let my = (down?1:0) - (up?1:0);
      let n = norm(mx, my);
      const accelPlayer = 1200;
      player.vx += n.x * accelPlayer * dt;
      player.vy += n.y * accelPlayer * dt;
      // Damping
      player.vx *= 0.90;
      player.vy *= 0.90;
      const sp = len(player.vx, player.vy);
      if (sp > player.speed) {
        const s = player.speed / sp; player.vx *= s; player.vy *= s;
      }
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // Kick action (space)
      if (keys[' ']) tryKick(player, 1.0);

      // CPU AI
      updateAI(dt);
      // CPU kick attempt (AI gets "free" kicks if close enough)
      if (len(ball.x - cpu.x, ball.y - cpu.y) < cpu.r + ball.r + 8) {
        tryKick(cpu, 0.9);
      }

      // Integrate ball with friction
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;
      ball.vx *= 0.995;
      ball.vy *= 0.995;

      // Clamp ball speed
      const bs = len(ball.vx, ball.vy);
      if (bs > ball.maxSpeed) {
        const f = ball.maxSpeed / bs; ball.vx *= f; ball.vy *= f;
      }

      // Collisions with players (circle-circle, separation + transfer)
      for (const p of team) resolvePlayerBallCollision(p);

      // Walls (top/bottom)
      if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -0.9; bounceSfx(); }
      if (ball.y + ball.r > H) { ball.y = H - ball.r; ball.vy *= -0.9; bounceSfx(); }

      // Left/Right walls and goals
      if (ball.x - ball.r <= 0) {
        if (ball.y >= GOAL_TOP && ball.y <= GOAL_BOT) {
          // Tor für CPU (links)
          score.cpu++;
          uiScore.textContent = `YOU ${score.you} - ${score.cpu} CPU`;
          goalSfx();
          paused = true;
          setCenterMsg('Tor für CPU!', 1000);
          setTimeout(() => {
            paused = false;
            resetPositions(false); // Ball nach rechts
          }, 1200);
        } else {
          ball.x = ball.r; ball.vx *= -0.9; bounceSfx();
        }
      }
      if (ball.x + ball.r >= W) {
        if (ball.y >= GOAL_TOP && ball.y <= GOAL_BOT) {
          // Tor für YOU (rechts)
          score.you++;
          uiScore.textContent = `YOU ${score.you} - ${score.cpu} CPU`;
          goalSfx();
          paused = true;
          setCenterMsg('Tor für dich!', 1000);
          setTimeout(() => {
            paused = false;
            resetPositions(true); // Ball nach links
          }, 1200);
        } else {
          ball.x = W - ball.r; ball.vx *= -0.9; bounceSfx();
        }
      }

      // Stay inside field for players (not into goals)
      for (const p of team) {
        p.x = clamp(p.x, p.r, W - p.r);
        p.y = clamp(p.y, p.r, H - p.r);
      }

      // Center message timer
      if (messageTimer > 0) {
        messageTimer -= dt * 1000;
        if (messageTimer <= 0) uiCenter.style.display = 'none';
      }

      // Restart
      if (keys['r']) {
        keys['r'] = false;
        restartMatch();
      }
    }

    function tryKick(p, power=1.0) {
      // cooldown to avoid spamming
      if (!p.kickCooldown || (nowMs() - p.kickCooldown) > 220) {
        const dx = ball.x - p.x, dy = ball.y - p.y;
        const d = Math.hypot(dx, dy);
        if (d <= p.r + ball.r + 4) {
          let dir;
          if (p === cpu) {
            // CPU tends to shoot toward player's goal
            dir = norm(CENTER.x - ball.x, CENTER.y - ball.y);
            if (Math.random() > AI.kickBias) {
              // sometimes random pass/shot
              const ang = rand(-Math.PI/3, Math.PI/3);
              const base = norm(1, 0); // to right
              const v = rotate(base, ang);
              dir = norm(dir.x*0.5 + v.x*0.5, dir.y*0.5 + v.y*0.5);
            }
          } else {
            dir = norm(dx, dy);
          }
          const force = 460 * power + Math.min(220, len(p.vx, p.vy) * 0.35);
          ball.vx += dir.x * force;
          ball.vy += dir.y * force;
          kickSfx();
          p.kickCooldown = nowMs();
        }
      }
    }

    function rotate(v, ang) {
      const c = Math.cos(ang), s = Math.sin(ang);
      return { x: v.x*c - v.y*s, y: v.x*s + v.y*c };
    }

    function resolvePlayerBallCollision(p) {
      const dx = ball.x - p.x;
      const dy = ball.y - p.y;
      const d = Math.hypot(dx, dy);
      const minD = p.r + ball.r;
      if (d > 0 && d < minD) {
        const n = { x: dx / d, y: dy / d };
        const overlap = (minD - d);
        // Separate
        ball.x += n.x * overlap * 0.7;
        ball.y += n.y * overlap * 0.7;
        p.x -= n.x * overlap * 0.3;
        p.y -= n.y * overlap * 0.3;

        // Transfer some player momentum to ball + extra based on closing speed
        const closing = (ball.vx - p.vx) * n.x + (ball.vy - p.vy) * n.y;
        const impulse = -closing * 0.6 + 80; // base push
        ball.vx += n.x * impulse;
        ball.vy += n.y * impulse;
      }
    }

    function updateAI(dt) {
      // Simple: chase ball if it's on CPU side or close; otherwise hold position
      const dx = ball.x - cpu.x;
      const dy = ball.y - cpu.y;
      const d = Math.hypot(dx, dy);

      let target = { x: AI.targetIdle.x, y: clamp(ball.y, 100, H-100) };
      const ballOnCpuSide = ball.x > W * 0.52;
      const ballNear = d < AI.chaseRadius;

      if (ballOnCpuSide || ballNear) {
        // Chase slightly behind the ball (so AI doesn't overshoot)
        const behind = { x: ball.x - Math.sign(dx) * 18, y: ball.y - Math.sign(dy) * 12 };
        target = { x: clamp(behind.x, cpu.r, W - cpu.r), y: clamp(behind.y, cpu.r, H - cpu.r) };
      } else {
        // Gentle return to "defendX"
        target.x = Math.min(AI.defendX, W - cpu.r);
      }

      const toT = { x: target.x - cpu.x, y: target.y - cpu.y };
      const tN = norm(toT.x, toT.y);
      const accel = 900;
      cpu.vx += tN.x * accel * dt;
      cpu.vy += tN.y * accel * dt;

      // Damp and clamp speed
      cpu.vx *= 0.90; cpu.vy *= 0.90;
      const sp = len(cpu.vx, cpu.vy);
      if (sp > cpu.speed) {
        const s = cpu.speed / sp; cpu.vx *= s; cpu.vy *= s;
      }
      cpu.x += cpu.vx * dt;
      cpu.y += cpu.vy * dt;
    }

    function drawPitch() {
      // Background
      ctx.fillStyle = COLORS.pitch;
      ctx.fillRect(0, 0, W, H);

      // Subtle stripes
      const stripes = 12;
      for (let i = 0; i < stripes; i++) {
        ctx.fillStyle = i % 2 ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.02)';
        const h = H / stripes;
        ctx.fillRect(0, i*h, W, h);
      }

      // Lines
      ctx.strokeStyle = COLORS.lines;
      ctx.lineWidth = 3;

      ctx.beginPath();
      // outer rectangle
      ctx.strokeRect(3, 3, W-6, H-6);
      // halfway line
      ctx.moveTo(W/2, 3); ctx.lineTo(W/2, H-3);
      // center circle
      ctx.moveTo(CENTER.x + 70, CENTER.y);
      ctx.arc(CENTER.x, CENTER.y, 70, 0, Math.PI*2);
      // Penalty boxes (both sides)
      // Left
      ctx.rect(3, CENTER.y - 160, 120, 320);
      // Right
      ctx.rect(W - 123, CENTER.y - 160, 120, 320);
      ctx.stroke();

      // Goals (mouth opening)
      ctx.beginPath();
      // left goal mouth
      ctx.moveTo(0, GOAL_TOP); ctx.lineTo(0, GOAL_BOT);
      // right goal mouth
      ctx.moveTo(W, GOAL_TOP); ctx.lineTo(W, GOAL_BOT);
      ctx.stroke();
    }

    function drawPlayer(p) {
      // Shadow
      ctx.fillStyle = COLORS.shadow;
      ctx.beginPath();
      ctx.ellipse(p.x+2, p.y+6, p.r*0.9, p.r*0.6, 0, 0, Math.PI*2);
      ctx.fill();

      // Body
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();

      // Direction indicator
      const v = { x: p.vx, y: p.vy };
      const s = len(v.x, v.y);
      const d = s > 10 ? { x: v.x/s, y: v.y/s } : { x: 1, y: 0 };
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + d.x * (p.r + 10), p.y + d.y * (p.r + 10));
      ctx.stroke();
    }

    function drawBall() {
      // Shadow
      ctx.fillStyle = COLORS.shadow;
      ctx.beginPath();
      ctx.ellipse(ball.x+3, ball.y+6, ball.r*1.2, ball.r*0.7, 0, 0, Math.PI*2);
      ctx.fill();

      // Ball
      ctx.fillStyle = COLORS.ball;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fill();

      // Simple pattern
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      for (let i=0;i<6;i++){
        const a = (i/6)*Math.PI*2;
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(ball.x + Math.cos(a)*ball.r, ball.y + Math.sin(a)*ball.r);
      }
      ctx.stroke();
    }

    function drawHUD() {
      // Already handled by DOM for timer/score; draw nothing here.
    }

    function render() {
      drawPitch();
      drawBall();
      for (const p of team) drawPlayer(p);
    }

    function loop() {
      const t = nowMs();
      let dt = (t - last) / 1000;
      last = t;

      // clamp dt to avoid big jumps if tab inactive
      dt = Math.min(dt, 0.033);

      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    // Init
    restartMatch();
    requestAnimationFrame(loop);

  })();
  </script>
</body>
</html>
