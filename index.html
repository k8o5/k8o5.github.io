<html lang="en" style="--desktop-icon-scale-factor: 1;"><head>
    <meta charset="UTF-8">
    <!-- SEO Meta Tags -->
    <title>k8OS</title>
    <meta name="description" content="k8OS is a open-source AI-powered web desktop environment that runs entirely in your browser. Create games, music, and graphics with simple text prompts.">
    <meta name="keywords" content="web desktop, AI, generative AI, web OS, virtual desktop, browser OS, game generator, svg creator, music generator, AI assistant, retro computing, web app, k8os, k8o5, operating system, no-backend, open source">
    <meta name="author" content="k8o5">
    <meta name="source" content="https://github.com/k8o5/k8o5.github.io">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://k8o5.com/">
    <meta property="og:title" content="k8OS">
    <meta property="og:description" content="A AI-powered web desktop environment that runs entirely in your browser.">
    <meta property="og:image" content="https://k8o5.com/sparky.svg">

    <!-- X -->
    <meta property="X:card" content="summary_large_image">
    <meta property="X:url" content="https://k8o5.com/">
    <meta property="X:title" content="k8OS">
    <meta property="X:description" content="A AI-powered web desktop environment that runs entirely in your browser.">
    <meta property="X:image" content="https://k8o5.com/sparky.svg">

    <!-- PWA / Mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <link id="favicon" rel="shortcut icon" href="sparky.svg">
    <link rel="apple-touch-icon" href="sparky.svg">
    <script async="" src="https://ga.jspm.io/npm:es-module-shims@1.8.3/dist/es-module-shims.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai",
        "marked": "https://esm.run/marked@4.0.12"
      }
    }
    </script>
    <style>
        :root {
            --win95-bg: #008080;
            --win95-light-gray: #C0C0C0;
            --win95-dark-gray: #808080;
            --win95-white: #FFFFFF;
            --win95-black: #000000;
            --win95-button-face: #DFDFDF;
            --win95-title-blue: #000080;
            --win95-title-text: #FFFFFF;
            --win95-font: 'MS Sans Serif', 'Tahoma', 'Geneva', sans-serif;
            --desktop-icon-base-size: 48px;
            --desktop-icon-scale-factor: 1.0;
        }
        body {
            font-family: var(--win95-font);
            background-color: var(--win95-bg); /* Fallback color */
            background-image: none; /* Default no image */
            background-size: cover; /* Default size */
            background-repeat: no-repeat; /* Default repeat */
            background-position: center center; /* Default position */
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            /* touch-action: none; Removed to allow pinch-zoom on mobile */
        }
        .desktop {
            flex-grow: 1;
            position: relative;
            padding: 5px;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: flex-start;
            align-content: flex-start;
            overflow: hidden; /* Important for Sparky's movement boundaries */
        }
        .desktop-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: calc( (var(--desktop-icon-base-size) * var(--desktop-icon-scale-factor)) + 32px);
            margin: calc(5px * var(--desktop-icon-scale-factor));
            padding: calc(5px * var(--desktop-icon-scale-factor));
            cursor: pointer;
            color: var(--win95-white);
            flex-shrink: 0;
            touch-action: manipulation; /* Prevents page scroll when dragging icons on touch */
        }
        .desktop-icon:hover, .desktop-icon.selected {
            background-color: rgba(0, 0, 128, 0.5);
            outline: 1px dotted var(--win95-white);
        }
        .desktop-icon img, .desktop-icon .icon-placeholder {
            width: calc(var(--desktop-icon-base-size) * var(--desktop-icon-scale-factor));
            height: calc(var(--desktop-icon-base-size) * var(--desktop-icon-scale-factor));
            margin-bottom: calc(5px * var(--desktop-icon-scale-factor));
            background-color: var(--win95-light-gray);
            border: 1px solid var(--win95-dark-gray);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(20px * var(--desktop-icon-scale-factor));
            color: var(--win95-black);
        }
        .desktop-icon span {
            font-size: calc(11px * var(--desktop-icon-scale-factor));
            word-break: break-word;
            line-height: 1.2;
        }
        .window {
            position: absolute;
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            min-width: 280px;
            min-height: 180px;
            display: none; /* Initially hidden, shown by JS */
            flex-direction: column;
            resize: both;
            overflow: hidden;
        }
        /* Web Browser specific styling for its dynamic parts */
        .webBrowserWindow .window-content, .sparkyHtmlPopupWindow .window-content { padding: 0; overflow: hidden; }
        .webBrowserWindow_navControls { display:flex; align-items: center; padding: 5px; border-bottom: 1px solid var(--win95-dark-gray); background-color: var(--win95-button-face); flex-shrink: 0;}
        .webBrowserWindow_navControls button { font-family: "Marlett", "Webdings"; font-size: 14px; width: 24px; height: 22px; line-height: 20px; margin-right: 3px;}
        .webBrowserWindow_addressBar { flex-grow: 1; margin-left:5px; margin-right: 5px; height: 22px; padding: 2px 4px;}
        .webBrowserWindow_iframeContent, .sparkyHtmlPopupWindow_iframeContent { width: 100%; height: 100%; flex-grow: 1; border: none; background-color: var(--win95-white); }
        .webBrowserWindow_status { /* Already covered by .window-content .status-bar if added there */ }


        .window.fullscreen {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: calc(100vh - 31px) !important; /* Adjusted for taskbar */
            resize: none !important;
            border-radius: 0;
            box-shadow: none;
            z-index: 1500 !important;
        }
        .window.minimized { /* This class might not be needed if display:none is used directly */
            display: none !important;
        }
        .window.mobile-default-fullscreen {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important; /* Full height on mobile */
            resize: none !important;
            border-radius: 0;
            box-shadow: none;
            z-index: 1500 !important;
        }
        .window.active { z-index: 1000; } /* Default active window z-index */

        .title-bar {
            background-color: var(--win95-title-blue);
            color: var(--win95-title-text);
            padding: 3px 5px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            height: 20px;
            flex-shrink: 0;
            touch-action: none; /* Prevent page scroll when dragging title bar on touch */
        }
        .window.mobile-default-fullscreen .title-bar { cursor: default; }

        .title-bar-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .title-bar-controls button {
            background-color: var(--win95-light-gray);
            border: 1px outset var(--win95-light-gray);
            color: var(--win95-black);
            font-family: "Marlett", "Webdings";
            font-size: 12px;
            padding: 0;
            width: 16px;
            height: 14px;
            line-height: 14px;
            margin-left: 2px;
            cursor: pointer;
        }
        .title-bar-controls button:active { border-style: inset; }
        .window-content {
            padding: 10px;
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            background-color: var(--win95-button-face);
            display: flex;
            flex-direction: column;
        }
        .window-content label { display: block; margin-bottom: 5px; font-size: 12px; }
        .window-content input[type="text"],
        .window-content input[type="password"],
        .window-content input[type="number"],
        .window-content textarea,
        .window-content select,
        .window-content input[type="color"],
        .window-content input[type="range"] {
            width: calc(100% - 10px);
            padding: 3px;
            margin-bottom: 8px;
            border: 1px inset var(--win95-dark-gray);
            font-family: var(--win95-font);
            font-size: 12px;
            box-sizing: border-box;
        }
        .window-content input[type="color"] { height: 30px; padding: 1px; }
        .window-content input[type="range"] { padding: 0; }
        .window-content textarea { min-height: 60px; resize: vertical; flex-grow: 1; }
        #gameGen_generatedCode, #musicStudio_generatedCode, #gifCreator_svgInput, #textEditor_contentArea { min-height: 100px; font-family: "Courier New", monospace; font-size:11px; white-space: pre-wrap; }
        #gameGen_debugCombinedInput, #gameErrorLog_errorsDisplay { min-height: 80px; background-color: var(--win95-white); font-family: "Courier New", monospace; font-size:11px; white-space: pre-wrap;}
        .window-content button {
            padding: 5px 10px;
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            cursor: pointer;
            font-family: var(--win95-font);
            font-size: 12px;
        }
        .window-content button:active { border-style: inset; }
        .window-content button:disabled { color: var(--win95-dark-gray); cursor: default; }
        .window-content .status-bar {
            border-top: 1px solid var(--win95-dark-gray);
            border-bottom: 1px solid var(--win95-white);
            padding: 2px 5px;
            font-size: 11px;
            margin-top: auto;
            flex-shrink: 0;
        }
        .taskbar {
            background-color: var(--win95-light-gray);
            border-top: 1px solid var(--win95-white);
            padding: 3px;
            height: 28px;
            display: flex;
            align-items: center;
            box-sizing: border-box;
            flex-shrink: 0;
            position: relative;
            z-index: 19000; /* Below start menu, above most windows */
        }
        .start-button {
            padding: 2px 8px;
            margin-right: 5px;
            border: 2px outset var(--win95-light-gray);
            font-weight: bold;
            cursor: pointer;
            position: relative;
        }
        .start-button:active { border-style: inset; }
        .taskbar-buttons-container {
            display: flex;
            flex-grow: 1;
            overflow-x: auto; /* For many buttons */
            align-items: center;
            padding-left: 5px;
            gap: 3px;
            height: 100%;
        }
        .taskbar-button {
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            padding: 0px 8px; /* Adjusted padding */
            font-size: 11px;
            font-family: var(--win95-font);
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            height: 22px; /* Standard taskbar button height */
            line-height: 18px; /* Vertically center text */
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }
        .taskbar-button:active, .taskbar-button.active {
            border-style: inset;
            background-color: var(--win95-button-face); /* Slightly different look when active */
        }
        .taskbar-button.minimized {
            /* Optional: Style for minimized buttons, e.g., slightly darker or different border */
        }
        .clock {
            margin-left: auto;
            padding: 2px 5px;
            border: 1px inset var(--win95-dark-gray);
            font-size: 11px;
        }
        .start-menu {
            position: absolute;
            bottom: 28px; /* Height of taskbar */
            left: 3px;
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            box-shadow: 2px -2px 5px rgba(0,0,0,0.3);
            padding: 2px;
            display: none;
            flex-direction: column;
            width: 150px;
            z-index: 20000; /* Above taskbar */
        }
        .start-menu-item { padding: 5px 10px; cursor: pointer; font-size: 12px; }
        .start-menu-item:hover { background-color: var(--win95-title-blue); color: var(--win95-white); }
        .start-menu-separator { height: 1px; background-color: var(--win95-dark-gray); border-bottom: 1px solid var(--win95-white); margin: 2px 0; }

        .context-menu {
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            padding: 2px;
            min-width: 120px;
            display: none; /* Initially hidden */
            position: absolute; /* Positioned by JS */
            z-index: 30000; /* High z-index */
            font-family: var(--win95-font);
        }
        .context-menu-item {
            padding: 4px 12px; /* Increased padding for better clickability */
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
        }
        .context-menu-item:hover {
            background-color: var(--win95-title-blue);
            color: var(--win95-white);
        }
        .context-menu-separator {
            height: 1px;
            background-color: var(--win95-dark-gray);
            border-bottom: 1px solid var(--win95-white);
            margin: 2px 0;
        }

        #gifCreator_previewContainer { width: 100%; min-height: 200px; flex-grow: 1; border: 1px inset var(--win95-dark-gray); background-color: var(--win95-white); margin-top: 10px; display: flex; justify-content: center; align-items: center; overflow: auto; }
        #gifCreator_previewContainer svg { max-width: 100%; max-height: 100%; }
        #gifCreator_loadingIndicator { font-style: italic; }

        #gameGen_planDisplay { font-family: "Courier New", Courier, monospace; font-size: 11px; min-height: 60px; background-color: var(--win95-white); border: 1px inset var(--win95-dark-gray); padding: 5px; white-space: pre-wrap; margin-top: 5px; overflow-y: auto;}
        #gameGen_assetStatus { font-size: 11px; margin-top: 5px; }
        #gamePlayerWindow_iframe { width: 100%; height: 100%; flex-grow: 1; border: none; background-color: var(--win95-white); }
        #gamePlayerWindow .window-content { padding: 0; overflow: hidden; }


        #gameGen_loadingMessage, #gameGen_errorMessage { padding: 8px; margin-top: 8px; border: 1px solid var(--win95-dark-gray); text-align: center; }
        #gameGen_errorMessage { background-color: #FFCCCC; color: red; }
        .api-key-warning { font-size: 11px; background-color: #FFFFE0; border: 1px solid #F0E68C; padding: 5px; margin-bottom: 10px; }
        .get-api-key-link { font-size: 11px; color: var(--win95-title-blue); margin-right: 10px; }
        #fileExplorerWindow .window-content { overflow: hidden; }
        #fe_fileListContainer { flex-grow: 1; overflow-y: auto; border: 1px inset var(--win95-dark-gray); background-color: var(--win95-white); padding: 5px; margin-top: 5px; }
        #fe_fileTable { width: 100%; border-collapse: collapse; font-size: 12px; }
        #fe_fileTable thead { background-color: var(--win95-light-gray); }
        #fe_fileTable th { text-align: left; padding: 2px 5px; border: 1px outset var(--win95-light-gray); font-weight: normal; }
        .fe-sortable-header { cursor: pointer; }
        .fe-sortable-header:hover { background-color: var(--win95-dark-gray); color: var(--win95-white); }
        .fe-sortable-header.active-sort { border-style: inset; background-color: var(--win95-dark-gray); color: var(--win95-white); }
        #fe_fileList tr.selected { background-color: var(--win95-title-blue); color: var(--win95-white); }
        #fe_fileList tr:hover { background-color: var(--win95-title-blue); color: var(--win95-white); }
        #fe_fileList td { padding: 2px 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #fe_fileList td .fe-item-icon { margin-right: 5px; font-family: "Segoe UI Symbol", "Apple Color Emoji", "Segoe UI Emoji";}
        #fe_fileList td a { text-decoration: none; color: inherit; display: flex; align-items: center; }
        #fe_fileSearchInput { margin-bottom: 5px; }
        #fe_folderNameDisplay { font-weight: bold; margin-bottom: 5px; padding-bottom: 3px; border-bottom: 1px solid var(--win95-dark-gray); }

        .settings-tabs { display: flex; border-bottom: 1px solid var(--win95-dark-gray); margin-bottom: 10px; }
        .settings-tab { padding: 5px 10px; cursor: pointer; border: 1px solid transparent; border-bottom: none; margin-right: 2px; font-size: 12px; background-color: var(--win95-dark-gray); color: var(--win95-light-gray); }
        .settings-tab.active { background-color: var(--win95-light-gray); border-color: var(--win95-dark-gray); border-bottom-color: var(--win95-light-gray); color: var(--win95-black); position: relative; top: 1px; }
        .settings-tab-content { display: none; }
        .settings-tab-content.active { display: block; }
        .settings-tab-content h3 { font-size: 13px; margin-top: 0; margin-bottom: 8px; border-bottom: 1px solid var(--win95-dark-gray); padding-bottom: 3px;}
        .settings-tab-content textarea { min-height: 60px; }

        #systemSettings_appearance_colorOptions button { width: 30px; height: 30px; margin: 5px; border: 2px outset var(--win95-light-gray); }
        #systemSettings_appearance_colorOptions button:active { border-style: inset; }
        #systemSettings_appearance_colorOptions { display: flex; flex-wrap: wrap; margin-bottom:10px; }
        #systemSettings_iconSizeSliderValue { margin-left: 10px; font-size: 12px; }

        .reboot-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #000; color: #FFF; display: none; justify-content: center; align-items: center; font-family: 'Consolas', 'Courier New', monospace; font-size: 18px; z-index: 100000; text-align: center; line-height: 1.5; }
        .reboot-overlay p { margin: 5px; }
        .reboot-overlay .k8os-logo { font-size: 32px; font-weight: bold; color: #00FF00; margin-bottom: 20px; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
        .debug-section { border: 1px dotted var(--win95-dark-gray); padding: 8px; margin-top: 10px; }
        .debug-section h4 { font-size: 12px; margin-top:0; margin-bottom:5px; }

        .provider-caveat {
            font-size: 10px;
            color: var(--win95-dark-gray);
            margin-top: 2px;
            font-style: italic;
        }

        /* Assistant Styles */
        #k8osAssistant {
            position: fixed;
            z-index: 26000;
            display: none;
            flex-direction: column;
            user-select: none;
            transition: left 0.05s linear, top 0.05s linear;
        }

        #k8osAssistant_avatarContainer {
            width: 70px;
            height: 70px;
            cursor: pointer;
        }
        #k8osAssistant_inputContainer {
            display: none;
            flex-direction: column; /* Changed for preview */
            margin-bottom: 8px;
            padding: 5px;
            background-color: var(--win95-button-face);
            border: 1px solid var(--win95-dark-gray);
            border-radius: 5px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.15);
        }
        #k8osAssistant_commandInput {
            flex-grow: 1; /* Take available space */
            height: 20px;
            border: 1px inset var(--win95-dark-gray);
            font-family: var(--win95-font);
            font-size: 11px;
            padding: 2px 4px;
        }
        #k8osAssistant_sendCommandButton {
            font-size: 10px;
            padding: 2px 5px;
            margin-left: 5px;
            background-color: var(--win95-light-gray);
            border: 1px outset var(--win95-light-gray);
        }
         #k8osAssistant_sendCommandButton:active { border-style: inset; }

        /* Styles for Image Attachment in Sparky */
        .sparky-image-preview-container {
            position: relative;
            margin-bottom: 5px;
            max-width: 170px; /* Width of the input area */
            align-self: center;
        }
        .sparky-image-preview-thumbnail {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            border: 1px solid var(--win95-dark-gray);
        }
        .sparky-remove-image-button {
            position: absolute;
            top: -7px;
            right: -7px;
            background-color: #ff0000;
            color: white;
            border: 1px solid white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 1;
        }
        .sparky-attach-file-button {
            font-size: 12px;
            padding: 2px 5px;
            margin-left: 5px;
            height: 24px;
            line-height: 20px;
            background-color: var(--win95-light-gray);
            border: 1px outset var(--win95-light-gray);
            flex-shrink: 0;
        }
        .sparky-attach-file-button:active {
            border-style: inset;
        }

        /* Adjustments for Aqua Theme */
        body.aqua-theme .sparky-attach-file-button {
            border-radius: 12px;
            background: linear-gradient(to bottom, #fefefe, #dcdcdc);
            border: 1px solid #999;
            color: #333;
            height: 22px;
            line-height: 18px;
        }
        body.aqua-theme .sparky-attach-file-button:active {
            background: linear-gradient(to top, #fefefe, #dcdcdc);
        }


        #k8osAssistant_speechBubble {
            background-color: #FFFFE1;
            border: 1px solid #F4E79A;
            border-radius: 8px;
            padding: 8px 12px;
            font-family: var(--win95-font);
            font-size: 12px;
            color: var(--win95-black);
            max-width: 220px;
            min-width: 80px;
            text-align: left;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.15);
            position: relative;
            margin-bottom: 8px;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            white-space: normal;
        }

        #k8osAssistant_speechBubble.visible {
            opacity: 1;
            transform: translateY(0px) scale(1);
        }

        #k8osAssistant_speechBubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            right: 18px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #FFFFE1;
        }
         /* End Assistant Styles */


        /* --- Terminal Styles --- */
        #terminal_content {
            background-color: rgba(0, 0, 0, 0.85);
            color: #E0E0E0;
            font-family: 'Fira Code', 'Menlo', 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            padding: 8px;
            overflow-y: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #terminal_output {
            white-space: pre-wrap;
            word-break: break-all;
        }
        .terminal-input-line {
            display: flex;
            align-items: center;
        }
        .terminal-prompt {
            color: #87D7AF; /* A greenish prompt color */
            margin-right: 8px;
            white-space: nowrap;
        }
        #terminal_input {
            background: transparent;
            border: none;
            color: #E0E0E0;
            outline: none;
            width: 100%;
            font-family: inherit;
            font-size: inherit;
            padding: 0;
            caret-color: #E0E0E0; /* This is the native blinking cursor */
        }
        /* --- End Terminal Styles --- */

        @media (max-width: 768px) {
            #workflowNodeSidebar, #workflowPropertiesPanel {
                display: none; /* Hidden by default on mobile */
                position: absolute;
                top: 32px; /* Below toolbar */
                bottom: 0;
                z-index: 20;
                width: 160px;
                box-shadow: 2px 0 5px rgba(0,0,0,0.5);
                border-right: 1px solid var(--win95-dark-gray);
            }
            #workflowNodeSidebar.mobile-visible, #workflowPropertiesPanel.mobile-visible {
                display: block; /* Show when toggled */
            }
            #workflowNodeSidebar {
                left: 0;
            }
            #workflowPropertiesPanel {
                right: 0;
                border-left: 1px solid var(--win95-dark-gray);
                border-right: none;
            }
            .mobile-workflow-controls {
                display: flex; /* Show buttons on mobile */
            }

            .window.mobile-default-fullscreen {
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                resize: none !important;
                border-radius: 0;
                box-shadow: none;
                z-index: 1500 !important;
            }
            .window.mobile-default-fullscreen .title-bar { cursor: default; }
            .window.mobile-default-fullscreen .title-bar-controls .fullscreen-button { display: none; }
            .window.mobile-default-fullscreen .title-bar-controls .minimize-button { display: none; }

            #k8osAssistant_avatarContainer {
                width: 60px;
                height: 60px;
            }
            #k8osAssistant_speechBubble {
                max-width: 180px;
                font-size: 11px;
            }
            /* File Explorer Mobile Enhancements */
            #fileExplorerWindow #fe_fileList td {
                white-space: normal; /* Allow file names to wrap */
                word-break: break-word; /* Nicer word breaking */
                padding-top: 6px;
                padding-bottom: 6px;
            }
            #fileExplorerWindow #fe_fileList td .fe-item-icon {
                font-size: 1.2em; /* Slightly larger icons for touch */
                margin-right: 8px;
            }
        }

/* --- Calendar Popup --- */
.calendar-popup {
    display: none; /* Hidden by default */
    position: absolute;
    bottom: 32px; /* Just above the taskbar */
    right: 5px;
    width: 220px;
    background-color: var(--win95-light-gray);
    border: 2px outset var(--win95-light-gray);
    box-shadow: 2px -2px 5px rgba(0,0,0,0.3);
    z-index: 21000; /* Above start menu */
    padding: 5px;
    font-family: var(--win95-font);
}
.calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 5px;
    margin-bottom: 5px;
    border-bottom: 1px solid var(--win95-dark-gray);
}
#calendarMonthYear {
    font-weight: bold;
    font-size: 12px;
}
.calendar-nav-btn {
    background-color: var(--win95-light-gray);
    border: 1px outset var(--win95-light-gray);
    font-size: 10px;
    padding: 1px 4px;
    cursor: pointer;
}
.calendar-nav-btn:active {
    border-style: inset;
}
.calendar-grid {
    width: 100%;
    border-collapse: collapse;
    font-size: 11px;
    text-align: center;
}
.calendar-grid th {
    font-weight: bold;
    padding: 3px;
}
.calendar-grid td {
    padding: 4px;
    cursor: pointer;
}
.calendar-grid td:hover {
    background-color: var(--win95-title-blue);
    color: var(--win95-white);
}
.calendar-grid .today {
    border: 1px solid var(--win95-title-blue);
    font-weight: bold;
}
.calendar-grid .other-month {
    color: var(--win95-dark-gray);
}

/* Calendar Aqua Theme Styles */
body.aqua-theme .calendar-popup {
    background: rgba(245, 245, 245, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid #bbb;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.25);
    font-family: var(--aqua-font);
    color: #333;
}
body.aqua-theme .calendar-header {
    border-bottom: 1px solid #bbb;
}
body.aqua-theme #calendarMonthYear {
    font-weight: 600;
}
body.aqua-theme .calendar-nav-btn {
    border-radius: 10px;
    background: linear-gradient(to bottom, #fefefe, #dcdcdc);
    border: 1px solid #999;
    color: #333;
    padding: 2px 8px;
}
body.aqua-theme .calendar-nav-btn:active {
    background: linear-gradient(to top, #fefefe, #dcdcdc);
}
body.aqua-theme .calendar-grid td:hover {
    background-color: #3465a4;
    color: #fff;
    border-radius: 4px;
}
body.aqua-theme .calendar-grid .today {
    background-color: #3465a4;
    color: #fff;
    border-radius: 4px;
    border: none;
}
body.aqua-theme .calendar-grid .other-month {
    color: #aaa;
}

/* --- Aqua Theme --- */
body.aqua-theme {
    --aqua-bg-start: #729fcf;
    --aqua-bg-end: #3465a4;
    --aqua-title-bar-start: #b4d3ea;
    --aqua-title-bar-end: #88b3d7;
    --aqua-title-bar-inactive-start: #e5e5e5;
    --aqua-title-bar-inactive-end: #d1d1d1;
    --aqua-title-text: #222;
    --aqua-window-bg: #f0f0f0;
    --aqua-button-blue-start: #6c99d6;
    --aqua-button-blue-end: #3a6ab2;
    --aqua-button-text: #fff;
    --aqua-taskbar-bg: rgba(230, 235, 240, 0.8);
    --aqua-font: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    
    font-family: var(--aqua-font) !important;
    background-color: var(--aqua-bg-end);
    background-image: radial-gradient(circle at 50% 0, var(--aqua-bg-start), var(--aqua-bg-end) 150%) !important;
    color: #000;
}

/* Window Styling */
body.aqua-theme .window {
    background-color: var(--aqua-window-bg);
    border: 1px solid #999;
    border-radius: 8px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    border-top: none;
}

body.aqua-theme .title-bar {
    background: linear-gradient(to bottom, var(--aqua-title-bar-start), var(--aqua-title-bar-end));
    color: var(--aqua-title-text);
    padding: 3px 10px;
    font-weight: 600;
    font-size: 13px;
    text-align: center;
    border-bottom: 1px solid #777;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    height: 22px;
    text-shadow: 0 1px 0 rgba(255,255,255,0.6);
}
body.aqua-theme .window:not(.active) .title-bar {
    background: linear-gradient(to bottom, var(--aqua-title-bar-inactive-start), var(--aqua-title-bar-inactive-end));
    color: #888;
}

body.aqua-theme .title-bar-controls {
    position: absolute;
    top: 4px;
    left: 8px;
}
body.aqua-theme .title-bar-text {
    padding-left: 75px; /* Make space for buttons */
    padding-right: 60px;
}

body.aqua-theme .title-bar-controls button {
    font-family: 'Helvetica Neue', sans-serif !important;
    font-weight: bold;
    font-size: 14px;
    height: 16px;
    width: 16px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.4);
    line-height: 16px;
    text-align: center;
    color: transparent; /* Hide the original characters */
    text-shadow: none;
    margin-right: 6px;
    padding: 0;
}
body.aqua-theme .title-bar-controls button:active {
    filter: brightness(0.8);
}
body.aqua-theme .title-bar-controls .close-button {
    background: radial-gradient(circle at 30% 30%, #ff8a8a, #ff5050);
    border-color: #e04040;
}
body.aqua-theme .title-bar-controls .minimize-button {
    background: radial-gradient(circle at 30% 30%, #fff68e, #ffdd50);
    border-color: #e0c040;
}
body.aqua-theme .title-bar-controls .fullscreen-button {
    background: radial-gradient(circle at 30% 30%, #8aff94, #50ff5e);
    border-color: #40e050;
}

/* Window Content */
body.aqua-theme .window-content {
    background-color: transparent;
    font-size: 12px;
}

/* Taskbar */
body.aqua-theme .taskbar {
    background: var(--aqua-taskbar-bg);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid rgba(255,255,255,0.7);
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
    height: 32px;
}
body.aqua-theme .start-button {
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path fill="%233465a4" d="M50,2.5C23.8,2.5,2.5,23.8,2.5,50S23.8,97.5,50,97.5,97.5,76.2,97.5,50,76.2,2.5,50,2.5ZM66.3,70.1c-4.3-2.5-10.4-4.8-15.6-4.8-5.3,0-11.4,2.3-15.6,4.8-2.3,1.3-5,1.2-7.2-0.4-2.2-1.6-3.5-4.1-3.5-6.8,0-9.4,6.7-17.1,15-20.9-5.9-4.1-9.6-11.1-9.6-19,0-12.2,9.9-22.1,22.1-22.1s22.1,9.9,22.1,22.1c0,7.8-3.7,14.9-9.6,19,8.3,3.8,15,11.5,15,20.9,0,2.7-1.3,5.2-3.5,6.8C71.3,71.3,68.5,71.4,66.3,70.1Z"/></svg>') center/contain no-repeat;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 4px;
    text-indent: -9999px; /* Hide "Start" text */
}
body.aqua-theme .taskbar-button {
    background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
    border: 1px solid #aaa;
    border-radius: 12px;
    height: 24px;
    line-height: 22px;
    box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    color: #333;
}
body.aqua-theme .taskbar-button.active {
    background: linear-gradient(to top, #6c99d6, #3a6ab2);
    color: var(--aqua-button-text);
    border-color: #333;
    text-shadow: 0 -1px 0 rgba(0,0,0,0.4);
}
body.aqua-theme .clock {
    border: none;
    color: #333;
    font-weight: 500;
}

/* Desktop Icons */
body.aqua-theme .desktop-icon {
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
}
body.aqua-theme .desktop-icon:hover, body.aqua-theme .desktop-icon.selected {
    background-color: rgba(50, 100, 200, 0.4);
    outline: none;
    border-radius: 6px;
}
body.aqua-theme .desktop-icon img, body.aqua-theme .desktop-icon .icon-placeholder {
    background-color: transparent;
    border: none;
}

/* Form Elements */
body.aqua-theme .window-content button {
    border-radius: 12px;
    background: linear-gradient(to bottom, #fefefe, #dcdcdc);
    border: 1px solid #999;
    color: #333;
    font-weight: 500;
    padding: 4px 12px;
    box-shadow: 0 1px 1px rgba(0,0,0,0.1);
}
body.aqua-theme .window-content button:active {
    background: linear-gradient(to top, #fefefe, #dcdcdc);
}
/* Primary button style */
body.aqua-theme .window-content button#saveApiKeyButton,
body.aqua-theme .window-content button#vibe_generateButton,
body.aqua-theme .window-content button#gifCreator_generateButton,
body.aqua-theme .window-content button#gameGen_generateButton,
body.aqua-theme .window-content button#musicStudio_generateButton {
    background: linear-gradient(to bottom, var(--aqua-button-blue-start), var(--aqua-button-blue-end));
    border-color: #2a5a9a;
    color: var(--aqua-button-text);
    text-shadow: 0 -1px 0 rgba(0,0,0,0.3);
}
body.aqua-theme .window-content input[type="text"],
body.aqua-theme .window-content input[type="password"],
body.aqua-theme .window-content input[type="number"],
body.aqua-theme .window-content textarea,
body.aqua-theme .window-content select {
    border: 1px solid #aaa;
    border-radius: 4px;
    padding: 4px;
    background-color: #fff;
}
body.aqua-theme .window-content input[type="text"]:focus,
body.aqua-theme .window-content input[type="password"]:focus,
body.aqua-theme .window-content input[type="number"]:focus,
body.aqua-theme .window-content textarea:focus,
body.aqua-theme .window-content select:focus {
    outline: 2px solid #6c99d6;
    outline-offset: -1px;
}

/* File Explorer */
body.aqua-theme #fe_fileTable {
    font-size: 13px;
}
body.aqua-theme #fe_fileTable thead {
    background: linear-gradient(to bottom, #fdfdfd, #e9e9e9);
}
body.aqua-theme #fe_fileTable th {
    border: 1px solid #ccc;
    border-bottom: 2px solid #aaa;
    font-weight: 600;
}
body.aqua-theme #fe_fileList tr.selected {
    background-color: #3465a4;
    color: #fff;
}
body.aqua-theme #fe_fileList tr:hover {
    background-color: #a4c5e4;
    color: #000;
}
body.aqua-theme #fe_fileList tr.selected:hover {
    background-color: #4475b4;
    color: #fff;
}

#textEditorAssist_diffContainer ins {
    background-color: #d4edda;
    color: #155724;
    text-decoration: none;
    display: block;
}
#textEditorAssist_diffContainer del {
    background-color: #f8d7da;
    color: #721c24;
    text-decoration: none;
    display: block;
}

/* Context Menus */
body.aqua-theme .context-menu {
    background: rgba(245, 245, 245, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid #bbb;
    border-radius: 6px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
}
body.aqua-theme .context-menu-item {
    font-size: 13px;
    padding: 5px 15px;
}
body.aqua-theme .context-menu-item:hover {
    background-color: #3465a4;
    color: #fff;
}
body.aqua-theme .context-menu-separator {
    background-color: #bbb;
    height: 1px;
    margin: 4px 1px;
    border-bottom: none;
}

    </style>
</head>
<body style="background-color: rgb(0, 0, 0);">
    <div class="desktop" id="desktop">
        <!-- Static App Icons -->
        <div class="desktop-icon" data-item-type="app" data-app-id="apiKeySettingsWindow"><div class="icon-placeholder">🔑</div><span>API Key</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="fileExplorerWindow" data-vfs-path-id="root"><div class="icon-placeholder">📁</div><span>Files</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="webBrowserLauncher"><div class="icon-placeholder">🌐</div><span>Browser</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="vibeCreatorWindow"><div class="icon-placeholder">✨</div><span>Vibe Creator</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="gifCreatorWindow"><div class="icon-placeholder">🎞️</div><span>GIF Creator</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="gameGeneratorWindow"><div class="icon-placeholder">🕹️</div><span>Game Gen</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="musicStudioWindow"><div class="icon-placeholder">🎶</div><span>Music Studio</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="textEditorWindow"><div class="icon-placeholder">🗒️</div><span>Editor</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="systemSettingsWindow"><div class="icon-placeholder">⚙️</div><span>Settings</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="terminalWindow"><div class="icon-placeholder">💲</div><span>Terminal</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="imageToCodeWindow"><div class="icon-placeholder">✨</div><span>Pic to Code</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="trashBin"><div class="icon-placeholder">🗑️</div><span>Trash</span></div>
        <!-- VFS Icons will be dynamically added here by JS -->
    <div class="desktop-icon" data-item-id="mfuwx9niakkh8" data-item-type="folder" draggable="true"><div class="icon-placeholder">📁</div><span>live</span></div><div class="desktop-icon" data-item-id="mfxmlr4re53ws" data-item-type="folder" draggable="true"><div class="icon-placeholder">📁</div><span>Pasted Pictures</span></div><div class="desktop-icon" data-item-id="mfz4q09mt2fqs" data-item-type="file" draggable="true"><div class="icon-placeholder">🌐</div><span>terminal.html</span></div></div>

    <!-- App Windows -->
    <div id="apiKeySettingsWindow" class="window" style="width: 420px; height: 320px; top: 20px; left: 20px; display: none; z-index: 102;">
        <div class="title-bar"><span class="title-bar-text">🔑 API Key Settings</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <div class="api-key-warning"><strong>Bring Your Own Key (BYOK) Model:</strong> Your keys are stored only in your browser's local storage and are never sent to our servers.</div>
            <label for="apiProviderSelect">Select API Provider:</label>
            <select id="apiProviderSelect" style="margin-bottom: 10px;">
                <option value="gemini">Google Gemini</option>
                <option value="groq">Groq</option>
                <option value="openai">OpenAI</option>
                <option value="openrouter">OpenRouter</option>
                <option value="xai">XAI</option>
                <option value="deepseek">DeepSeek</option>
                <option value="huggingface">Hugging Face</option>
                <option value="transformersjs">Transformers.js (Local LLM)</option>
                <option value="custom">Custom Endpoint (User-hosted)</option>
            </select>
            <label id="apiKeyInputLabel" for="apiKeyInput" style="display: block;">Custom Endpoint API Key:</label>
            <input type="password" id="apiKeyInput" placeholder="Enter API Key/Token for selected provider" style="display: block;">
            <p id="apiKeyInfoText" style="font-size: 11px; margin-top: 5px; display: block;">Enter your Custom Endpoint's specific API key here. Configure URL in System Settings.</p>
            <button id="saveApiKeyButton">Save Key/Token</button>
            <p id="apiKeyLinksContainer" style="margin-top: 10px; font-size: 11px; display: block;">
                <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="geminiApiKeyLink" style="display: none;">Get a Gemini API Key</a>
                <a href="https://console.groq.com/keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="groqApiKeyLink" style="display:none;">Get a Groq API Key</a>
                <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="openaiApiKeyLink" style="display:none;">Get an OpenAI API Key</a>
                <a href="https://openrouter.ai/keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="openrouterApiKeyLink" style="display:none;">Get an OpenRouter API Key</a>
                <a href="https://console.x.ai/team/default/api-keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="xaiApiKeyLink" style="display:none;">Get an XAI API Key</a>
                <a href="https://platform.deepseek.com/api_keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="deepseekApiKeyLink" style="display:none;">Get a DeepSeek API Key</a>
                <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="hfApiKeyLink" style="display:none;">Get a Hugging Face Token</a>
                <a href="#" class="get-api-key-link" id="customSetupLink" style="display: inline;">Setup Custom Endpoint Guide</a>
            </p>
            <div id="apiKeyStatus" class="status-bar">Status: Custom Endpoint Key/Token Loaded.</div>
        </div>
    </div>

    <div id="fileExplorerWindow" class="window" style="width: 450px; height: 400px; top: 30px; left: 350px;">
        <div class="title-bar"><span class="title-bar-text">📁 File Explorer</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <div id="fe_folderNameDisplay">Loading folder...</div>
            <input type="text" id="fe_fileSearchInput" placeholder="Search files...">
            <div id="fe_fileListContainer">
                <table id="fe_fileTable">
                    <thead>
                        <tr>
                            <th data-sort-key="name" class="fe-sortable-header active-sort">Name ▲</th>
                            <th data-sort-key="type" class="fe-sortable-header">Type</th>
                            <th data-sort-key="modified" class="fe-sortable-header">Date Modified</th>
                        </tr>
                    </thead>
                    <tbody id="fe_fileList"><tr data-item-id="mfuwx9niakkh8" data-item-type="folder" draggable="true" style="cursor: pointer;"><td><span class="fe-item-icon">📁</span>live</td><td>Folder</td><td>9/22/2025, 11:17:10 AM</td></tr><tr data-item-id="mfxmlr4re53ws" data-item-type="folder" draggable="true" style="cursor: pointer;"><td><span class="fe-item-icon">📁</span>Pasted Pictures</td><td>Folder</td><td>9/24/2025, 8:51:35 AM</td></tr><tr data-item-id="mg0rywnbrap76" data-item-type="folder" draggable="true" style="cursor: pointer;"><td><span class="fe-item-icon">📁</span>Sparky's Creations</td><td>Folder</td><td>9/26/2025, 1:45:05 PM</td></tr><tr data-item-id="mfnt5eb10tuy2" data-item-type="folder" draggable="true" style="cursor: pointer;"><td><span class="fe-item-icon">📁</span>Trash</td><td>Folder</td><td>9/17/2025, 11:57:07 AM</td></tr><tr data-item-id="mfz4q09mt2fqs" data-item-type="file" draggable="true" style="cursor: pointer;"><td><span class="fe-item-icon">🌐</span>terminal.html</td><td>html</td><td>9/25/2025, 11:58:00 AM</td></tr></tbody>
                </table>
            </div>
            <div id="fe_status" class="status-bar">Status: 5 item(s).</div>
        </div>
    </div>

    <div id="vibeCreatorWindow" class="window" style="width: 500px; height: 450px; top: 50px; left: 50px;">
        <div class="title-bar"><span class="title-bar-text">✨ Vibe Creator</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="vibe_creator_type_select">Creator Type:</label>
            <select id="vibe_creator_type_select" style="margin-bottom: 10px;">
                <option value="svg">SVG</option>
                <option value="p5js">p5.js</option>
                <option value="threejs">Three.js</option>
                <option value="babylonjs">Babylon.js</option>
            </select>
            <label for="vibe_promptInput">Describe your vibe:</label>
            <textarea id="vibe_promptInput" rows="3" placeholder="e.g., a smiling sun, a field of generative flowers, a rotating 3D cube"></textarea>
            <button id="vibe_generateButton">Generate</button>
            <button id="vibe_downloadButton" style="display: none; margin-top: 5px;">Download</button>
            <div id="vibe_loadingIndicator" style="display: none;">Generating...</div>
            <div id="vibe_container" style="width: 100%; min-height: 200px; flex-grow: 1; border: 1px inset var(--win95-dark-gray); background-color: var(--win95-white); margin-top: 10px; display: flex; justify-content: center; align-items: center; overflow: auto;">
                <p>Your vibe appears here.</p>
            </div>
            <div id="vibe_errorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle (custom)</div>
        </div>
    </div>

    <div id="gifCreatorWindow" class="window" style="width: 600px; height: 550px; top: 60px; left: 100px;">
        <div class="title-bar"><span class="title-bar-text">🎞️ GIF Creator (Animated SVG)</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="gifCreator_promptInput">Describe animation or animated SVG:</label>
            <textarea id="gifCreator_promptInput" rows="3" placeholder="e.g., 'a blinking eye' (Animation quality varies greatly by provider)"></textarea>
            <div class="import-section" style="margin-top:10px; margin-bottom:10px; padding:5px; border:1px dashed var(--win95-dark-gray);">
                <label for="gifCreator_svgInput">Optional: Existing SVG code (from SVG Creator or pasted):</label>
                <textarea id="gifCreator_svgInput" rows="4" placeholder="Paste static SVG code here to animate it..."></textarea>
                <button id="gifCreator_importSvgButton" style="margin-top:5px; font-size:10px; padding:2px 5px;">Import from SVG Creator</button>
                <label for="gifCreator_animationPromptInput" style="margin-top:5px;">Animation instructions for existing SVG:</label>
                <textarea id="gifCreator_animationPromptInput" rows="2" placeholder="e.g., 'make the sun rotate'"></textarea>
            </div>
            <button id="gifCreator_generateButton">Generate Animated SVG</button>
            <button id="gifCreator_downloadButton" style="display: none; margin-top: 5px;">Download Animated SVG</button>
            <div id="gifCreator_loadingIndicator" style="display: none; margin-top:5px;">Generating...</div>
            <div id="gifCreator_previewContainer" style="margin-top:10px;"><p>Animated SVG preview appears here.</p></div>
            <div id="gifCreator_errorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle (custom)</div>
        </div>
    </div>

    <div id="gameGeneratorWindow" class="window" style="width: 700px; height: 680px; top: 110px; left: 110px;">
        <div class="title-bar"><span class="title-bar-text">🕹️ Game Generator</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="gameGen_prompt">Describe game idea:</label>
            <textarea id="gameGen_prompt" rows="2" placeholder="e.g., 'breakout-style game with 3 lives' (Complex generation works best with Gemini/Groq/DeepSeek)"></textarea>
            <button id="gameGen_generateButton">Generate Game</button>
            <button id="gameGen_downloadZipButton" style="display: none; margin-top: 5px;">Download Game as ZIP</button>
            <div id="gameGen_loadingMessage" style="display: none;">AI working...</div>
            <div id="gameGen_errorMessage" style="display: none;"></div>
            <div style="margin-top:10px;">
                <label for="gameGen_planDisplay">Game Plan &amp; Asset Status:</label>
                <div id="gameGen_planDisplay" readonly="">Awaiting game plan...</div>
            </div>
            <div id="gameGen_assetStatus"></div>
            <div class="output-section" style="margin-top:10px;">
                <label for="gameGen_generatedCode">Generated Game Code (HTML):</label>
                <textarea id="gameGen_generatedCode" readonly="" placeholder="Generated HTML/JS code..."></textarea>
            </div>
            <div id="gameGen_apiErrorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle (custom)</div>
            <div class="debug-section" id="gameGen_debugSection" style="display:none;">
                <h4>Assisted Debugging</h4>
                <label for="gameGen_debugCombinedInput">Observed Errors &amp; Debugging Hints:</label>
                <textarea id="gameGen_debugCombinedInput" rows="4" placeholder="Paste error messages and/or provide hints for AI..."></textarea>
                <button id="gameGen_debugAttemptButton">Attempt to Fix Error with AI</button>
            </div>
        </div>
    </div>

    <div id="musicStudioWindow" class="window" style="width: 500px; height: 480px; top: 140px; left: 500px;">
        <div class="title-bar"><span class="title-bar-text">🎶 Music Studio</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="musicStudio_promptInput">Describe music or theme:</label>
            <textarea id="musicStudio_promptInput" rows="3" placeholder="e.g., 'upbeat 8-bit space theme loop' (JS code generation works best with Gemini/Groq/DeepSeek)"></textarea>
            <button id="musicStudio_generateButton">Generate Music Code</button>
            <button id="musicStudio_modifyButton" style="margin-left: 5px;" disabled="">Modify Music</button> <!-- ADDED THIS BUTTON -->
            <div id="musicStudio_loadingIndicator" style="display: none; margin-top: 5px;">Generating music code...</div>
            <label for="musicStudio_generatedCode" style="margin-top:10px;">Generated JavaScript (Web Audio API):</label>
            <textarea id="musicStudio_generatedCode" rows="8" readonly=""></textarea>
            <div style="margin-top:5px;">
                <button id="musicStudio_playButton" disabled="">Play Music</button>
                <button id="musicStudio_stopButton" disabled="">Stop Music</button>
                <button id="musicStudio_downloadJsButton" style="display: none;">Download JS</button>
            </div>
            <div id="musicStudio_errorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle (custom)</div>
        </div>
    </div>

    <div id="gamePlayerWindow" class="window" style="width: 800px; height: 600px; top: 150px; left: 150px;">
        <div class="title-bar">
            <span class="title-bar-text" id="gamePlayerWindow_title">Game Player</span>
            <div class="title-bar-controls">
                <button id="gamePlayer_refreshButton" title="Refresh Game">Q</button>
                <button class="minimize-button" title="Minimize">0</button>
                <button class="fullscreen-button" title="Toggle Fullscreen">1</button>
                <button class="close-button" title="Close">r</button>
            </div>
        </div>
        <div class="window-content"><iframe id="gamePlayerWindow_iframe" sandbox="allow-scripts allow-same-origin allow-popups"></iframe></div>
    </div>

    <div id="textEditorWindow" class="window" style="width: 500px; height: 400px; top: 70px; left: 70px;">
        <div class="title-bar"><span class="title-bar-text">🗒️ Text Editor</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <div style="display: flex; margin-bottom: 5px; flex-shrink: 0; align-items:center;">
                <button id="textEditor_saveButton">Save</button>
                <button id="textEditor_sparkyAssistButton" style="margin-left: 5px;" title="Use Sparky to help create files/folders based on editor content">✨ Assist</button>
                <span id="textEditor_currentFileName" style="margin-left: 10px; font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1;"></span>
            </div>
            <textarea id="textEditor_contentArea" style="flex-grow: 1; width: calc(100% - 6px);" placeholder="File content... or describe a file/folder structure for Sparky Assist."></textarea>
            <div id="textEditor_status" class="status-bar">Status: Idle.</div>
        </div>
    </div>

    <div id="systemSettingsWindow" class="window" style="width: 550px; height: 720px; top: 60px; left: 200px; overflow-y: auto; display: flex; z-index: 109;">
        <div class="title-bar"><span class="title-bar-text">⚙️ System Settings</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content" style="height: calc(100% - 22px); overflow-y: auto;">
            <div class="settings-tabs">
                <div class="settings-tab" data-tab="appearance">Appearance</div>
                <div class="settings-tab active" data-tab="aiConfig">AI Config</div>
                <div class="settings-tab" data-tab="about">About</div>
            </div>
            <div id="settingsContent_appearance" class="settings-tab-content">
                <h3>Desktop Background</h3>
                <label for="systemSettings_appearance_bgColorPicker">Custom Background Color:</label>
                <input type="color" id="systemSettings_appearance_bgColorPicker" value="#008080">
                <label>Preset Colors:</label>
                <div id="systemSettings_appearance_colorOptions"><button style="background-color: rgb(0, 128, 128);" title="#008080"></button><button style="background-color: rgb(0, 0, 0);" title="#000000"></button><button style="background-color: rgb(128, 128, 128);" title="#808080"></button><button style="background-color: rgb(0, 0, 160);" title="#0000A0"></button><button style="background-color: rgb(58, 110, 165);" title="#3A6EA5"></button><button style="background-color: rgb(211, 211, 211);" title="#D3D3D3"></button></div>
                <button id="systemSettings_appearance_resetButton">Reset to Default Color</button>
                <h3 style="margin-top: 15px;">Image Background (URL)</h3>
                <p style="font-size:10px; margin-bottom:5px; color:var(--win95-dark-gray);"><em>Note: Direct access to your computer's wallpaper is not possible for security reasons. You can provide a URL to an image instead.</em></p>
                <label for="systemSettings_appearance_bgImageUrlInput">Image URL:</label>
                <input type="text" id="systemSettings_appearance_bgImageUrlInput" placeholder="https://example.com/image.png">
                <label for="systemSettings_appearance_bgSizeSelect">Background Size:</label>
                <select id="systemSettings_appearance_bgSizeSelect">
                    <option value="cover">Cover</option>
                    <option value="contain">Contain</option>
                    <option value="auto">Auto (Original Size)</option>
                    <option value="100% 100%">Stretch to Fit</option>
                </select>
                <label for="systemSettings_appearance_bgRepeatSelect">Background Repeat:</label>
                <select id="systemSettings_appearance_bgRepeatSelect">
                    <option value="no-repeat">No Repeat</option>
                    <option value="repeat">Repeat</option>
                    <option value="repeat-x">Repeat Horizontally</option>
                    <option value="repeat-y">Repeat Vertically</option>
                </select>
                <button id="systemSettings_appearance_applyBgImageButton" style="margin-top: 5px;">Apply Image URL</button>
                <button id="systemSettings_appearance_clearBgImageButton" style="margin-top: 5px;">Clear Image Background</button>
                <h3 style="margin-top: 15px;">Icon Size</h3>
                <label for="systemSettings_iconSizeSlider">Icon Scale: <span id="systemSettings_iconSizeSliderValue">1.0x</span></label>
                <input type="range" id="systemSettings_iconSizeSlider" min="0.5" max="1.5" step="0.1" value="1.0">
                <button id="systemSettings_iconSizeResetButton" style="margin-top: 5px;">Reset Icon Size</button>

                <div id="secretThemeSection" style="display: block; margin-top: 20px; padding-top: 10px; border-top: 1px dashed var(--win95-dark-gray);">
                    <h3 style="color: #909;">Secret Themes</h3>
                    <label for="themeSelect">Select Theme:</label>
                    <select id="themeSelect">
                        <option value="win95">Windows 95 (Default)</option>
                        <option value="aqua">Aqua (2001)</option>
                    </select>
                </div>
            </div>
            <div id="settingsContent_aiConfig" class="settings-tab-content active">
                <div id="geminiModelSettings" style="display: none;">
                    <h3>Global AI Model (Gemini)</h3>
                    <label for="systemSettings_ai_modelNameInput">Current Gemini Model Name:</label>
                    <input type="text" id="systemSettings_ai_modelNameInput" placeholder="e.g., gemini-1.5-flash">
                    <button id="systemSettings_ai_saveModelButton">Save &amp; Apply Gemini Model</button>
                </div>
                <div id="groqModelSettings" style="display:none;">
                    <h3>Global AI Model (Groq)</h3>
                    <label for="systemSettings_ai_groqModelInput">Enter Groq Model Name:</label>
                    <input type="text" id="systemSettings_ai_groqModelInput" placeholder="e.g., llama3-8b-8192 or meta-llama/Llama-3-8b-chat-hf">
                    <button id="systemSettings_ai_saveGroqModelButton">Save Groq Model</button>
                    <p class="provider-caveat">Enter the exact model identifier from Groq.</p>
                    <h3 style="margin-top:15px;">Groq API Settings</h3>
                    <label for="systemSettings_ai_groqMaxTokensInput">Max Tokens per Request:</label>
                    <input type="number" id="systemSettings_ai_groqMaxTokensInput" min="1" step="1" placeholder="e.g., 2048">
                    <button id="systemSettings_ai_saveGroqMaxTokensButton">Save Max Tokens</button>
                    <p class="provider-caveat">Lower values use less quota per request but might cut off long responses.</p>
                </div>
                <div id="openaiModelSettings" style="display:none;">
                    <h3>Global AI Model (OpenAI)</h3>
                    <label for="systemSettings_ai_openaiModelInput">Enter OpenAI Model Name:</label>
                    <input type="text" id="systemSettings_ai_openaiModelInput" placeholder="e.g., gpt-4-turbo or gpt-3.5-turbo">
                    <button id="systemSettings_ai_saveOpenaiModelButton">Save OpenAI Model</button>
                    <p class="provider-caveat">Enter the exact model identifier from OpenAI.</p>
                </div>
                <div id="openrouterModelSettings" style="display:none;">
                    <h3>Global AI Model (OpenRouter)</h3>
                    <label for="systemSettings_ai_openrouterModelInput">Enter OpenRouter Model String:</label>
                    <input type="text" id="systemSettings_ai_openrouterModelInput" placeholder="e.g., google/gemini-flash-1.5 or mistralai/mistral-7b-instruct">
                    <button id="systemSettings_ai_saveOpenrouterModelButton">Save OpenRouter Model</button>
                    <p class="provider-caveat">Find model strings on the OpenRouter <a href="https://openrouter.ai/models" target="_blank" rel="noopener noreferrer">Models page</a>.</p>
                    <h3 style="margin-top:15px;">OpenRouter API Settings</h3>
                    <label for="systemSettings_ai_openrouterHttpRefererInput">Site URL / HTTP-Referer (Optional):</label>
                    <input type="text" id="systemSettings_ai_openrouterHttpRefererInput" placeholder="e.g., https://your-site.com">
                    <button id="systemSettings_ai_saveOpenrouterHttpRefererButton">Save Site URL</button>
                    <p class="provider-caveat">Set your site URL to identify your app to OpenRouter. See their docs.</p>
                </div>
                <div id="xaiModelSettings" style="display:none;">
                    <h3>Global AI Model (XAI)</h3>
                    <label for="systemSettings_ai_xaiModelInput">Enter XAI Model Name:</label>
                    <input type="text" id="systemSettings_ai_xaiModelInput" placeholder="e.g., grok-4">
                    <button id="systemSettings_ai_saveXaiModelButton">Save XAI Model</button>
                    <p class="provider-caveat">Enter the model identifier from XAI (e.g., grok-4, grok-3, grok-3-mini).</p>
                </div>
                <div id="deepseekModelSettings" style="display:none;">
                    <h3>Global AI Model (DeepSeek)</h3>
                    <label for="systemSettings_ai_deepseekModelInput">Enter DeepSeek Model Name:</label>
                    <input type="text" id="systemSettings_ai_deepseekModelInput" placeholder="e.g., deepseek-chat or deepseek-coder">
                    <button id="systemSettings_ai_saveDeepseekModelButton">Save DeepSeek Model</button>
                    <p class="provider-caveat">Enter the model identifier from DeepSeek (e.g., deepseek-chat, deepseek-coder).</p>
                    <h3 style="margin-top:15px;">DeepSeek API Settings</h3>
                    <label for="systemSettings_ai_deepseekMaxTokensInput">Max Tokens per Request:</label>
                    <input type="number" id="systemSettings_ai_deepseekMaxTokensInput" min="1" step="1" placeholder="e.g., 2048">
                    <button id="systemSettings_ai_saveDeepseekMaxTokensButton">Save Max Tokens</button>
                    <p class="provider-caveat">Lower values use less quota per request but might cut off long responses.</p>
                </div>
                <div id="hfModelSettings" style="display:none;">
                    <h3>Global AI Model (Hugging Face)</h3>
                    <label for="systemSettings_ai_hfModelIdInput">Enter HF Model ID:</label>
                    <input type="text" id="systemSettings_ai_hfModelIdInput" placeholder="e.g., mistralai/Mistral-7B-Instruct-v0.1">
                    <button id="systemSettings_ai_saveHfModelButton">Save HF Model ID</button>
                    <p class="provider-caveat">Uses the Inference API (text-generation assumed). Ensure the model is loaded or available. Results vary.</p>
                </div>
                <div id="transformersjsModelSettings" style="display:none;">
                    <h3>Global AI Model (Transformers.js - Local LLM)</h3>
                    <label for="systemSettings_ai_transformersjsModelIdInput">Hugging Face Model ID (Text Generation):</label>
                    <input type="text" id="systemSettings_ai_transformersjsModelIdInput" placeholder="e.g., Xenova/distilgpt2">
                    <button id="systemSettings_ai_saveTransformersjsModelButton">Save &amp; Prepare Model</button>
                    <p class="provider-caveat">Model from Xenova's collection recommended (e.g., Xenova/distilgpt2). Model will be downloaded and run in your browser. Ensure it's a text-generation model.</p>
                    <p class="provider-caveat">Using Transformers.js version: <span id="systemSettings_transformersJsVersion">3.5.1</span>.</p>
                    <div id="systemSettings_transformersjs_status" class="status-bar" style="margin-top: 5px; border-top: 1px solid var(--win95-dark-gray); padding-top:3px;">Status: Idle.</div>
                </div>
                <div id="customProviderSettings" style="display: block;">
                    <h3>Custom Endpoint Settings (User-hosted)</h3>
                    <label for="systemSettings_ai_customEndpointUrlInput">Custom Endpoint URL:</label>
                    <input type="text" id="systemSettings_ai_customEndpointUrlInput" placeholder="e.g., https://xxxx.ngrok.io/generate">
                    <label for="systemSettings_ai_customModelIdInput">Custom Model Identifier (optional):</label>
                    <input type="text" id="systemSettings_ai_customModelIdInput" placeholder="e.g., my-custom-model-v1">
                    <button id="systemSettings_ai_saveCustomSettingsButton">Save Custom Endpoint Settings</button>
                    <p class="provider-caveat">Ensure your backend is running and accessible. The API Key for this endpoint is set in the 'API Key Settings' window.</p>
                </div>

                <h3 style="margin-top:15px;">Vibe Creator Instruction</h3>
                <label for="systemSettings_ai_vibeInstruction">Base prompt for Vibe generation:</label>
                <textarea id="systemSettings_ai_vibeInstruction" rows="3"></textarea>
                <button id="systemSettings_ai_saveVibeInstructionButton">Save Vibe Instruction</button>
                <h3 style="margin-top:15px;">Game Generator Final Code Instruction</h3>
                <label for="systemSettings_ai_gameGenFinalInstruction">Base prompt for Game Generator (Final Code Step):</label>
                <textarea id="systemSettings_ai_gameGenFinalInstruction" rows="4"></textarea>
                <button id="systemSettings_ai_saveGameGenFinalInstructionButton">Save Game Gen Final Instruction</button>
                <h3 style="margin-top:15px;">Music Studio Instruction</h3>
                <label for="systemSettings_ai_musicStudioInstruction">Base prompt for Music Studio JS generation:</label>
                <textarea id="systemSettings_ai_musicStudioInstruction" rows="4"></textarea>
                <button id="systemSettings_ai_saveMusicStudioInstructionButton">Save Music Studio Instruction</button>
                <h3 style="margin-top:15px;">GIF Creator (Animated SVG from Prompt) Instruction</h3>
                <label for="systemSettings_ai_gifCreatorNewInstruction">Base prompt for new animated SVG:</label>
                <textarea id="systemSettings_ai_gifCreatorNewInstruction" rows="3"></textarea>
                <button id="systemSettings_ai_saveGifCreatorNewInstructionButton">Save GIF (New) Instruction</button>
                <h3 style="margin-top:15px;">GIF Creator (Animate Existing SVG) Instruction</h3>
                <label for="systemSettings_ai_gifCreatorAnimateInstruction">Base prompt for animating existing SVG:</label>
                <textarea id="systemSettings_ai_gifCreatorAnimateInstruction" rows="4"></textarea>
                <button id="systemSettings_ai_saveGifCreatorAnimateInstructionButton">Save GIF (Animate) Instruction</button>
            </div>
            <div id="settingsContent_about" class="settings-tab-content">
                <h3>About k8OS</h3>
                <p id="systemSettings_about_version">Version: 0.1.15</p>
                <p>Created by: k8o5</p>
                <p>© 2025 k8o5.</p>
                <p style="font-size:11px; margin-top:15px;">Uses Google Generative AI, Groq API, OpenRouter, DeepSeek API, Hugging Face Inference API, Transformers.js, MarkedJS, ES Module Shims, JSZip.</p>
            </div>
            <div id="systemSettings_status" class="status-bar">Custom Endpoint settings saved. URL: https://little-art-f35c.kotistklasse.workers.dev/. Model: @cf/meta/llama-4-scout-17b-16e-instruct.</div>
        </div>
    </div>

    <div id="terminalWindow" class="window" style="width: 600px; height: 400px; top: 70px; left: 250px;">
        <div class="title-bar"><span class="title-bar-text">k8OS Terminal</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content" id="terminal_content">
            <div id="terminal_output">Welcome to k8OS Terminal! Type 'help' for a list of commands.</div>
            <div class="terminal-input-line">
                <span class="terminal-prompt">$</span>
                <input type="text" id="terminal_input" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false">
            </div>
        </div>
    </div>

    <div id="imageToCodeWindow" class="window" style="width: 550px; height: 600px; top: 150px; left: 180px;">
        <div class="title-bar"><span class="title-bar-text">✨ Pic to Code</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label>1. Paste your image here (Ctrl+V):</label>
            <div id="imageToCode_pasteZone" style="width: 100%; height: 200px; border: 1px inset var(--win95-dark-gray); background-color: var(--win95-white); margin-bottom: 10px; display:flex; justify-content:center; align-items:center; overflow:hidden;">
                 <img id="imageToCode_preview" style="max-width: 100%; max-height: 100%; display: none;">
                 <span id="imageToCode_pasteInstructions">Paste image to see preview...</span>
            </div>
            <label for="imageToCode_prompt">2. (Optional) Add a prompt for the AI:</label>
            <input type="text" id="imageToCode_prompt" placeholder="e.g., 'Make it responsive', 'Use a dark theme'">
            <button id="imageToCode_generateButton" disabled="">Generate Code</button>
            <label for="imageToCode_generatedCode" style="margin-top:10px;">3. Generated HTML/CSS Code:</label>
            <textarea id="imageToCode_generatedCode" readonly="" placeholder="AI will generate code here..."></textarea>
            <div id="imageToCode_status" class="status-bar">Status: Ready.</div>
        </div>
    </div>

    <div class="taskbar">
        <div class="start-button" id="startButton">Start</div>
        <div id="taskbarButtonsContainer" class="taskbar-buttons-container">
            <!-- Taskbar buttons will be added here by JS -->
        <button class="taskbar-button" data-window-id="systemSettingsWindow" title="⚙️ System Settings">⚙️ System Settings</button></div>
        <div class="start-menu" id="startMenu" style="display: none;">
            <!-- <div class="start-menu-item" id="startMenuNewFolder">New Folder</div> Removed -->
            <!-- <div class="start-menu-separator"></div> Removed -->
            <div class="start-menu-item" id="startMenuUpdate">Update</div>
            <div class="start-menu-separator"></div>
            <div class="start-menu-item" id="startMenuReboot">Reboot</div>
            <div class="start-menu-separator"></div>
            <div class="start-menu-item" id="startMenuFactoryReset" style="color: #c00; font-weight:bold;">Factory Reset</div>
            <div class="start-menu-separator"></div>
            <div class="start-menu-item" id="startMenuShutdown">Shutdown</div>
        </div>
        <div class="clock" id="taskbarClock">8:43:21 AM</div>
    </div>

    <!-- Calendar Popup -->
    <div id="calendarPopup" class="calendar-popup">
        <div class="calendar-header">
            <button id="calendarPrevMonth" class="calendar-nav-btn">&lt;</button>
            <span id="calendarMonthYear"></span>
            <button id="calendarNextMonth" class="calendar-nav-btn">&gt;</button>
        </div>
        <table class="calendar-grid">
            <thead>
                <tr>
                    <th>Su</th>
                    <th>Mo</th>
                    <th>Tu</th>
                    <th>We</th>
                    <th>Th</th>
                    <th>Fr</th>
                    <th>Sa</th>
                </tr>
            </thead>
            <tbody id="calendarDays">
            </tbody>
        </table>
    </div>

    <div class="reboot-overlay" id="rebootOverlay">
        <div id="rebootMessageContainer">
            <p class="k8os-logo">k8OS</p>
            <p id="rebootProgressText">Initializing...</p>
        </div>
    </div>

    <!-- Desktop Context Menu -->
    <div id="desktopContextMenu" class="context-menu" style="display: none;">
        <!-- Items will be added here by JS -->
    </div>

    <!-- Taskbar Context Menu -->
    <div id="taskbarContextMenu" class="context-menu" style="display: none;">
        <!-- Items will be added here by JS -->
    </div>

    <!-- k8OS Assistant (Sparky) -->
    <div id="k8osAssistant" style="display: flex; left: 1161.5px; top: 190.34px;">
        <div id="k8osAssistant_inputContainer" style="display: none;">
            <div id="sparky_imagePreviewContainer" class="sparky-image-preview-container" style="display: none;"></div>
            <div style="display: flex; align-items: center; width: 100%;">
                <input type="text" id="k8osAssistant_commandInput" placeholder="Talk to Sparky..." autocomplete="off">
                <button id="sparky_attachFileButton" class="sparky-attach-file-button" title="Attach Image">📎</button>
                <input type="file" id="sparky_fileInput" accept="image/*" style="display: none;">
                <button id="k8osAssistant_sendCommandButton">Send</button>
            </div>
        </div>
        <div id="k8osAssistant_speechBubble" class="visible"><span id="k8osAssistant_speechText">You're exploring Sparky Command, let's see what awesome things we can discover together!</span></div>
        <div id="k8osAssistant_avatarContainer" style="cursor: pointer;">
            <svg id="assistantAvatarSVG" viewBox="0 0 100 100" width="100%" height="100%">
                <style>
                    /* Default animation for sparkyBobbingGroup */
                    #sparkyBobbingGroup {
                        transform-origin: 50% 50%;
                        animation-name: sparkyWander;
                        animation-duration: 10s;
                        animation-timing-function: ease-in-out;
                        animation-iteration-count: infinite;
                    }
                    /* When .rolling class is added to sparkyBobbingGroup */
                    #sparkyBobbingGroup.rolling {
                        animation-name: sparkyRoll, sparkyWander;
                        animation-duration: 1s, 10s;
                        animation-timing-function: ease-in-out, ease-in-out;
                        animation-iteration-count: 1, infinite;
                        animation-delay: 0s, 1.05s; /* Roll first, then wander starts after 1.05s */
                    }

                    @keyframes sparkyWander {
                        0%   { transform: translate(0px, 0px) rotate(0deg); }
                        15%  { transform: translate(4px, -3px) rotate(3deg); }
                        30%  { transform: translate(-2px, 1px) rotate(-2deg); }
                        45%  { transform: translate(5px, -2px) rotate(2deg); }
                        60%  { transform: translate(0px, 2px) rotate(0deg); }
                        75%  { transform: translate(-4px, -3px) rotate(-3deg); }
                        90%  { transform: translate(2px, 0px) rotate(1deg); }
                        100% { transform: translate(0px, 0px) rotate(0deg); }
                    }
                     @keyframes sparkyRoll {
                        0%   { transform: translate(0px, 0px) rotate(0deg) scale(1); }
                        50%  { transform: translate(0px, 0px) rotate(180deg) scale(1.1); }
                        100% { transform: translate(0px, 0px) rotate(360deg) scale(1); }
                    }

                    #sparkyEyelid { animation: sparkyBlink 4.5s ease-in-out infinite; transform-origin: 50% 35%; /* Blink from top of eye */ }
                    @keyframes sparkyBlink {
                        0%, 90%, 100% { opacity: 0; transform: scaleY(0.1)}
                        93% { opacity: 1; transform: scaleY(1)}
                        96% { opacity: 0; transform: scaleY(0.1)}
                    }
                    #sparkyMouth.talking { animation: sparkyTalk 0.25s infinite steps(2, end); }
                    @keyframes sparkyTalk {
                        0% { d: path("M 40 60 Q 50 63 60 60"); }
                        50% { d: path("M 40 60 Q 50 68 60 60"); }
                    }
                </style>
                <defs>
                    <radialGradient id="sparkyBodyGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                        <stop offset="0%" style="stop-color:#87CEFA;stop-opacity:1"></stop>
                        <stop offset="100%" style="stop-color:#4682B4;stop-opacity:1"></stop>
                    </radialGradient>
                    <filter id="sparkyGlow"><feGaussianBlur stdDeviation="1.5" result="coloredBlur"></feGaussianBlur><feMerge><feMergeNode in="coloredBlur"></feMergeNode><feMergeNode in="SourceGraphic"></feMergeNode></feMerge></filter>
                </defs>
                <g id="sparkyBobbingGroup" class="">
                    <circle cx="50" cy="50" r="32" fill="url(#sparkyBodyGradient)" filter="url(#sparkyGlow)"></circle>
                    <ellipse cx="50" cy="45" rx="14" ry="9" fill="white"></ellipse>
                    <ellipse id="sparkyEyelid" cx="50" cy="45" rx="14.5" ry="9.5" fill="url(#sparkyBodyGradient)" opacity="0"></ellipse>
                    <circle id="sparkyPupil" cx="50" cy="45" r="4.5" fill="#222"></circle>
                    <path id="sparkyMouth" d="M 40 60 Q 50 63 60 60" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round" class="talking"></path>
                </g>
            </svg>
        </div>
    </div>

    <!-- Setup Guide Modal -->
    <div id="setupGuideModal" class="window" style="width: 650px; height: 550px; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 40000; display: none; resize: none; box-shadow: 0 0 15px rgba(0,0,0,0.5);">
        <div class="title-bar">
            <span id="setupGuideModalTitle" class="title-bar-text">Setup Guide</span>
            <div class="title-bar-controls">
                <button id="setupGuideModalCloseButton" title="Close">r</button>
            </div>
        </div>
        <div class="window-content" style="display: flex; flex-direction: column;">
            <p id="setupGuideModalInstructions" style="font-size: 12px; margin-bottom: 10px; flex-shrink: 0; max-height: 150px; overflow-y: auto;">Instructions will appear here.</p>
            <label for="setupGuideModalCode" style="font-size:12px; margin-bottom:3px; flex-shrink:0;">Boilerplate Code:</label>
            <textarea id="setupGuideModalCode" readonly="" style="width: calc(100% - 6px); flex-grow: 1; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre; margin-bottom: 10px;"></textarea>
            <button id="setupGuideModalCopyButton" style="flex-shrink: 0;">Copy Code</button>
            <div id="setupGuideModalStatus" class="status-bar" style="margin-top: auto; flex-shrink:0;">Click "Copy Code" then paste into your environment.</div>
        </div>
    </div>

    <!-- Text Editor Assist Modal -->
    <div id="textEditorAssistModal" class="window" style="width: 600px; height: 450px; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 41000; display: none;">
        <div class="title-bar">
            <span class="title-bar-text">✨ Sparky Assist</span>
            <div class="title-bar-controls">
                <button id="textEditorAssist_closeButton" title="Close">r</button>
            </div>
        </div>
        <div class="window-content">
             <div id="textEditorAssist_inputSection">
                <label for="textEditorAssist_userInput">Describe the changes you want to make (or describe an image):</label>
                <div id="sparkyAssist_imagePreviewContainer" class="sparky-image-preview-container" style="display: none;"></div>
                <div style="display: flex; align-items: flex-start; width: 100%;">
                    <textarea id="textEditorAssist_userInput" rows="2" placeholder="e.g., 'Refactor this function to be async' or 'Fix the bug in this loop'"></textarea>
                    <div style="margin-left: 5px; display:flex; flex-direction: column;">
                         <button id="sparkyAssist_attachFileButton" class="sparky-attach-file-button" title="Attach Image">📎</button>
                         <input type="file" id="sparkyAssist_fileInput" accept="image/*" style="display: none;">
                    </div>
                </div>
            </div>
            <div id="textEditorAssist_diffContainer" style="flex-grow: 1; border: 1px inset var(--win95-dark-gray); margin-top: 5px; margin-bottom: 5px; background-color: var(--win95-white); overflow: auto; padding: 5px; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre-wrap; word-break: break-all;">
                <!-- Diff will be generated here -->
            </div>
            <div id="textEditorAssist_buttonContainer" style="display: flex; justify-content: flex-end; margin-top: 5px; flex-shrink: 0;">
                <button id="textEditorAssist_rejectButton" style="display: none; margin-right: 5px;">Reject</button>
                <button id="textEditorAssist_acceptButton" style="display: none; margin-right: 5px;">Accept</button>
                <button id="textEditorAssist_getSuggestionsButton">Get Suggestions</button>
            </div>
            <div id="textEditorAssist_status" class="status-bar" style="margin-top: auto;">Status: Awaiting instructions.</div>
        </div>
    </div>


<script type="module">
    import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
    import { marked, Renderer as MarkedRenderer } from 'marked';
    import { pipeline as transformersPipeline, env as transformersEnv } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1';

    // Apply saved theme on load
    (function() {
        const savedTheme = localStorage.getItem('k8os_theme');
        if (savedTheme === 'aqua') {
            document.body.classList.add('aqua-theme');
        }
    })();

    // Transformers.js specific setup
    transformersEnv.allowLocalModels = false; // Only fetch from HF Hub
    transformersEnv.useBrowserCache = true;   // Cache models in browser

    const K8OS_VERSION = "0.1.15"; // Version bump for OpenRouter and GameGen overhaul
    const DEFAULT_GEMINI_AI_MODEL = "gemini-1.5-flash";
    const DEFAULT_GROQ_AI_MODEL = "llama3-8b-8192";
    const DEFAULT_OPENAI_MODEL = "gpt-4-turbo";
    const DEFAULT_OPENROUTER_AI_MODEL = "google/gemini-flash-1.5";
    const DEFAULT_XAI_MODEL = "grok-4";
    const DEFAULT_DEEPSEEK_CHAT_MODEL = "deepseek-chat";
    const DEFAULT_DEEPSEEK_CODER_MODEL = "deepseek-coder";
    const DEFAULT_HF_MODEL_ID = "mistralai/Mistral-7B-Instruct-v0.1";
    const DEFAULT_TRANSFORMERSJS_MODEL_ID = "Xenova/distilgpt2";
    const TRANSFORMERS_JS_VERSION = "3.5.1";

    const DEFAULT_GROQ_MAX_TOKENS = 2048;
    const DEFAULT_DEEPSEEK_MAX_TOKENS = 2048;
    const DEFAULT_HF_MAX_NEW_TOKENS = 1024;
    const DEFAULT_TRANSFORMERSJS_MAX_NEW_TOKENS = 150;
    const DEFAULT_CUSTOM_MAX_TOKENS = 1024; // Default for custom endpoint


    const DEFAULT_VIBE_SVG_INSTRUCTION = `Generate ONLY raw SVG code for: "{USER_PROMPT}". The SVG should be simple, iconic, and scalable. Start with "<svg" and end with "</svg>". Include 'viewBox'. No explanations, comments, or markdown.`;
    const DEFAULT_VIBE_P5JS_INSTRUCTION = `Generate a complete, self-contained HTML page with p5.js code to create a visual based on: "{USER_PROMPT}". The HTML must include the p5.js library from a CDN. The p5.js sketch should be contained within a <script> tag. The canvas should be dynamically sized to fit its container. Output ONLY the raw HTML code.`;
    const DEFAULT_VIBE_THREEJS_INSTRUCTION = `Generate a complete, self-contained HTML page with Three.js code to create a 3D scene based on: "{USER_PROMPT}". The HTML must include the Three.js library from a CDN. The Three.js code should be contained within a <script type="module"> tag. The renderer should be dynamically sized to fit its container, and there should be a basic animation loop. Output ONLY the raw HTML code.`;
    const DEFAULT_VIBE_BABYLONJS_INSTRUCTION = `Generate a complete, self-contained HTML page with Babylon.js code to create a 3D scene based on: "{USER_PROMPT}". The HTML must include the Babylon.js library from a CDN. The Babylon.js code should be contained within a <script> tag. The engine and scene should be set up to render on a canvas that dynamically sizes to fit its container. Output ONLY the raw HTML code.`;
    const DEFAULT_GAMEGEN_PLAN_INSTRUCTION = `Based on the user's game idea: "{USER_GAME_IDEA}", create a concise game plan. The plan must include: 1. A brief (1-2 sentences) description of the core game mechanic. 2. A list of 3 to 5 essential SVG assets. For each, provide a short, clear description, a boolean "animated" flag, and a unique, URL-safe "filename" ending in .svg. 3. A list of 2 to 3 essential sound effects. For each, provide a short, clear description and a unique, URL-safe "filename" ending in .js. Format the output as a JSON object with three keys: "game_mechanic" (string), "svg_assets" (array of objects), and "sound_effects" (array of objects). Example JSON: { "game_mechanic": "Top-down shooter...", "svg_assets": [{"description": "player ship, blue", "animated": false, "filename": "player.svg"}, {"description": "enemy UFO, rotates slowly", "animated": true, "filename": "enemy.svg"}], "sound_effects": [{"description": "laser shoot sound", "filename": "shoot.js"}, {"description": "explosion fx", "filename": "explosion.js"}] }. Output ONLY the JSON object.`;
    const DEFAULT_GAMEGEN_FINAL_INSTRUCTION = `Generate a COMPLETE, SINGLE-FILE, RUNNABLE HTML/JavaScript game. User's idea: "{USER_GAME_IDEA}". Game Plan: {GAME_PLAN_JSON}. All assets will be provided in a relative './assets/' directory. You MUST load them from there. The asset filenames are: {ASSET_FILENAMES_JSON}. IMPORTANT: For SVGs, use an asynchronous loading mechanism. 1. Create Image objects for each SVG asset using its path (e.g., 'assets/player.svg'). 2. Use onload/onerror handlers. 3. Only start the game loop AFTER all images are loaded. 4. For sound effects, the assets are JavaScript files. You must fetch each JS file (e.g., fetch('assets/shoot.js')), get its text content, and then use 'new Function('audioContext', 'activeSources', THE_FETCHED_CODE)' to create the playable sound function. Manage loading these sound functions asynchronously as well. The game should not start until all assets (SVGs and sounds) are loaded. Output ONLY the single HTML file string. Use pure JS/Canvas or CDN libraries. Include game loop, rendering, input. Self-contained. No markdown/explanations outside HTML. Make game playable, fit description/plan, using all provided assets and triggering sound effects.`;
    const DEFAULT_GAMEGEN_DEBUG_INSTRUCTION = `The HTML/JS game code (original idea: "{USER_GAME_IDEA}") produced error(s) and/or the user has provided hints: "{ERRORS_AND_HINTS}". Analyze the code, errors, and hints. Provide a corrected version of the full HTML/JS game code. Focus on fixing specified issues while preserving the game's original intent. Pay close attention to asynchronous asset loading from the './assets/' folder. Output ONLY the corrected, complete HTML/JS code, starting with <!DOCTYPE html> or <html> and ending with </html>. No explanations or markdown. Problematic code:\n\`\`\`html\n{PROBLEM_CODE}\n\`\`\``;
    const DEFAULT_MUSICSTUDIO_INSTRUCTION = `Generate JavaScript code using the Web Audio API to create music based on the description: "{USER_PROMPT}". The code should be a self-contained function body. It will be executed within a function that receives 'audioContext' and 'activeSources' (an array to push created source nodes to for later stopping) as arguments, like so: new Function('audioContext', 'activeSources', YOUR_CODE_HERE)(audioContextInstance, activeSourcesArray); Your code should use the provided 'audioContext'. It should create and start all necessary audio nodes and push main/looping source nodes to the 'activeSources' array if they are intended to be stopped later. If the description implies a loop or continuous music, structure your code to create and start the loop. If it's a one-shot piece, it should play through once. Generate ONLY the JavaScript function body. No explanations or markdown.`;
    const DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION = `Generate ONLY raw SVG code for an animated image based on: "{USER_PROMPT}". The SVG MUST include SMIL animation (<animate>, <animateTransform>, <animateMotion>, etc.) to create a looping, GIF-like effect. Ensure the animation is self-contained within the SVG. Start with "<svg" and end with "</svg>". Include 'viewBox'. No explanations, comments, or markdown outside the SVG code itself.`;
    const DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION = `Take the following static SVG code:\n\`\`\`svg\n{STATIC_SVG_CODE}\n\`\`\`\nNow, add SMIL animation elements to this SVG to achieve the following animation described by the user: "{ANIMATION_PROMPT}". Modify the provided SVG code directly. The output should be the complete, modified SVG code with the SMIL animations included. Ensure the animation is looping and self-contained. Start with "<svg" and end with "</svg>". No explanations, comments, or markdown outside the SVG code itself.`;
    const DEFAULT_SPARKY_AD_PROMPT = `You are Sparky, the k8OS assistant. Generate a short, witty, and slightly boastful advertisement about your capabilities or how helpful you are. Make it fun and friendly! Max 2-3 concise sentences. Output ONLY the ad text.`;
    const DEFAULT_SPARKY_HTML_GENERATOR_PROMPT = `You are Sparky, an AI assistant. The user wants to create something described as: "{USER_REQUEST}". Generate a complete, self-contained HTML page that fulfills this request. The HTML should be suitable to be displayed in an iframe. Output ONLY the raw HTML code, starting with <!DOCTYPE html> or <html> and ending with </html>. Do not include any explanations, markdown, or comments outside the HTML itself. If the request is for an interactive element, try to include basic JavaScript within <script> tags in the HTML. Be creative but keep it simple and functional.`;
    const DEFAULT_SPARKY_FILESYSTEM_GENERATOR_PROMPT = `You are Sparky, a k8OS AI assistant. The user wants to create a directory structure with files. User request: "{USER_REQUEST}".
The base location for these creations should be relative to a parent ID: "{BASE_PARENT_ID}". If "{BASE_PARENT_ID}" is "root", then top-level items in the plan should have "parentId": "root". Otherwise, top-level items in the plan should have "parentId": "{BASE_PARENT_ID}".
Analyze the request and generate a JSON array of actions to create the file system.
Each action object in the array should have:
- "action": "create_folder" or "create_file"
- "name": string (name of the file or folder)
- "parentId": string (ID of the parent folder. Use the value provided in "{BASE_PARENT_ID}" for top-level items of this request if "{BASE_PARENT_ID}" is not "root". Use "root" for top-level items if "{BASE_PARENT_ID}" is "root". For nested items, use the "id" you assign to the parent folder in a previous action).
- "id": string (a unique temporary ID for this item, e.g., "item1", "folderA", so it can be referenced as a parentId later by other actions in THIS SAME JSON response).
- "content": string (for "create_file" only, the content of the file. Can be empty string.)
- "mimeType": string (for "create_file" only, e.g., "text/plain", "text/html", "text/css", "application/javascript". Default to "text/plain" if unsure.)

Example (assuming {BASE_PARENT_ID} is "folderXYZ"): User wants "a subfolder 'WebApp' with 'index.html'".
Output JSON:
[
  { "action": "create_folder", "name": "WebApp", "parentId": "folderXYZ", "id": "webappFolder" },
  { "action": "create_file", "name": "index.html", "parentId": "webappFolder", "id": "indexFile", "content": "<h1>Hi</h1>", "mimeType": "text/html" }
]
Output ONLY the JSON array. No explanations, comments, or markdown outside the JSON. Ensure parentId references are correct within the generated sequence of actions, respecting the "{BASE_PARENT_ID}" context for the top-level items of this request.
`;
const DEFAULT_SPARKY_MULTIMODAL_PROMPT = `Analyze the user's prompt "{USER_PROMPT}" and the provided image. Generate a single, complete, runnable HTML file that combines the user's idea and the image's content. Your response must be ONLY the raw HTML code. Do not include any markdown, explanations, or comments. Start with <!DOCTYPE html> or <html>.`;
const DEFAULT_PHOTO_AI_EDIT_PROMPT = `You are an expert photo editing AI named Sparky. The user has provided an image and a text prompt. Your task is to edit the image based on the user's request and return ONLY the data URL of the edited image (e.g., "data:image/png;base64,iVBORw..."). Do not add any explanation, markdown, or other text. The user's prompt is: "{USER_PROMPT}"`;

const DEFAULT_SPARKY_ASSIST_MULTIMODAL_PROMPT = `You are an expert AI programmer. Rewrite the code based on the user's instruction and the provided image.
IMPORTANT: Respond ONLY with the complete, raw, rewritten code block. Do not add explanations, comments, or markdown formatting.

User's instruction: "{USER_INSTRUCTION}"
Image is provided as reference for the desired outcome.

Code to rewrite:
\`\`\`
{CODE_TO_REWRITE}
\`\`\`

Rewritten code:`;

    const wittyComments = {
        create_game: [
            "Poof! One game, coming right up. Try not to get addicted!",
            "My circuits are sizzling with game-making genius. Enjoy!",
            "Beep boop... game complete. Let me know if you win!",
            "There. I'm pretty sure this one's a future award-winner.",
        ],
        create_html: [
            "I've woven the very fabric of the web for you. Behold, HTML!",
            "Just whipped up a little something. Hope you like the pixels.",
            "There, a new webpage is born. I should get a stork costume.",
            "Another masterpiece for the internet's grand museum.",
        ],
        create_files: [
            "Files and folders, organized neatly. I'm basically a digital librarian.",
            "Consider your file system... structurated. You're welcome.",
            "Done! That was more fun than defragmenting my hard drive.",
            "I've tidied up your digital workspace. It's what I do.",
        ]
    };

    function getWittyComment(actionType) {
        const comments = wittyComments[actionType];
        if (!comments || comments.length === 0) {
            return "Just like that, it's done!"; // Fallback comment
        }
        return comments[Math.floor(Math.random() * comments.length)];
    }


    const apiProviderSelect = document.getElementById('apiProviderSelect');
    const apiKeyInputLabel = document.getElementById('apiKeyInputLabel');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeyInfoText = document.getElementById('apiKeyInfoText');
    const saveApiKeyButton = document.getElementById('saveApiKeyButton');
    const apiKeyStatus = document.getElementById('apiKeyStatus');
    const apiKeyLinksContainer = document.getElementById('apiKeyLinksContainer');
    const geminiApiKeyLink = document.getElementById('geminiApiKeyLink');
    const groqApiKeyLink = document.getElementById('groqApiKeyLink');
    const openaiApiKeyLink = document.getElementById('openaiApiKeyLink');
    const openrouterApiKeyLink = document.getElementById('openrouterApiKeyLink');
    const xaiApiKeyLink = document.getElementById('xaiApiKeyLink');
    const deepseekApiKeyLink = document.getElementById('deepseekApiKeyLink');
    const hfApiKeyLink = document.getElementById('hfApiKeyLink');
    const customSetupLink = document.getElementById('customSetupLink');


    const taskbarClock = document.getElementById('taskbarClock');
    const taskbarButtonsContainer = document.getElementById('taskbarButtonsContainer');
    const vibe_promptInput = document.getElementById('vibe_promptInput');
    const vibe_generateButton = document.getElementById('vibe_generateButton');
    const vibe_container = document.getElementById('vibe_container');
    const vibe_downloadButton = document.getElementById('vibe_downloadButton');
    const vibe_loadingIndicator = document.getElementById('vibe_loadingIndicator');
    const vibe_errorDisplay = document.getElementById('vibe_errorDisplay');
    const vibe_creator_type_select = document.getElementById('vibe_creator_type_select');
    const gifCreator_promptInput = document.getElementById('gifCreator_promptInput');
    const gifCreator_svgInput = document.getElementById('gifCreator_svgInput');
    const gifCreator_importSvgButton = document.getElementById('gifCreator_importSvgButton');
    const gifCreator_animationPromptInput = document.getElementById('gifCreator_animationPromptInput');
    const gifCreator_generateButton = document.getElementById('gifCreator_generateButton');
    const gifCreator_downloadButton = document.getElementById('gifCreator_downloadButton');
    const gifCreator_loadingIndicator = document.getElementById('gifCreator_loadingIndicator');
    const gifCreator_previewContainer = document.getElementById('gifCreator_previewContainer');
    const gifCreator_errorDisplay = document.getElementById('gifCreator_errorDisplay');
    const gameGen_promptInput = document.getElementById('gameGen_prompt');
    const gameGen_generateButton = document.getElementById('gameGen_generateButton');
    const gameGen_downloadZipButton = document.getElementById('gameGen_downloadZipButton');
    const gameGen_generatedCodeTextarea = document.getElementById('gameGen_generatedCode');
    const gameGen_loadingMessage = document.getElementById('gameGen_loadingMessage');
    const gameGen_errorMessage = document.getElementById('gameGen_errorMessage');
    const gameGen_apiErrorDisplay = document.getElementById('gameGen_apiErrorDisplay');
    const gameGen_planDisplay = document.getElementById('gameGen_planDisplay');
    const gameGen_assetStatus = document.getElementById('gameGen_assetStatus');
    const gameGen_debugSection = document.getElementById('gameGen_debugSection');
    const gameGen_debugCombinedInput = document.getElementById('gameGen_debugCombinedInput');
    const gameGen_debugAttemptButton = document.getElementById('gameGen_debugAttemptButton');
    const gamePlayerWindow_iframe = document.getElementById('gamePlayerWindow_iframe');
    const gamePlayer_refreshButton = document.getElementById('gamePlayer_refreshButton');
    const musicStudio_promptInput = document.getElementById('musicStudio_promptInput');
    const musicStudio_generateButton = document.getElementById('musicStudio_generateButton');
    const musicStudio_loadingIndicator = document.getElementById('musicStudio_loadingIndicator');
    const musicStudio_generatedCode = document.getElementById('musicStudio_generatedCode');
    const musicStudio_playButton = document.getElementById('musicStudio_playButton');
    const musicStudio_stopButton = document.getElementById('musicStudio_stopButton');
    const musicStudio_downloadJsButton = document.getElementById('musicStudio_downloadJsButton');
    const musicStudio_errorDisplay = document.getElementById('musicStudio_errorDisplay');
    const fe_fileListElement = document.getElementById('fe_fileList');
    const fe_statusElement = document.getElementById('fe_status');
    const fe_folderNameDisplayElement = document.getElementById('fe_folderNameDisplay');
    const fe_searchInput = document.getElementById('fe_fileSearchInput');
    const textEditor_saveButton = document.getElementById('textEditor_saveButton');
    const textEditor_sparkyAssistButton = document.getElementById('textEditor_sparkyAssistButton');
    const textEditor_contentArea = document.getElementById('textEditor_contentArea');
    const textEditor_status = document.getElementById('textEditor_status');
    const textEditor_currentFileName = document.getElementById('textEditor_currentFileName');
    let currentTextEditorFileId = null;


    const imageToCode_pasteZone = document.getElementById('imageToCode_pasteZone');
    const imageToCode_preview = document.getElementById('imageToCode_preview');
    const imageToCode_pasteInstructions = document.getElementById('imageToCode_pasteInstructions');
    const imageToCode_prompt = document.getElementById('imageToCode_prompt');
    const imageToCode_generateButton = document.getElementById('imageToCode_generateButton');
    const imageToCode_generatedCode = document.getElementById('imageToCode_generatedCode');
    const imageToCode_status = document.getElementById('imageToCode_status');
    let imageToCode_lastPastedFile = null;

    const desktopElement = document.getElementById('desktop');
    const desktopContextMenu = document.getElementById('desktopContextMenu');
    const taskbarContextMenu = document.getElementById('taskbarContextMenu');
    const startButton = document.getElementById('startButton');
    const startMenu = document.getElementById('startMenu');
    const startMenuUpdate = document.getElementById('startMenuUpdate');
    const startMenuReboot = document.getElementById('startMenuReboot');
    const startMenuFactoryReset = document.getElementById('startMenuFactoryReset');
    const startMenuShutdown = document.getElementById('startMenuShutdown');
    const rebootOverlay = document.getElementById('rebootOverlay');
    const rebootProgressText = document.getElementById('rebootProgressText');
    const systemSettings_appearance_bgColorPicker = document.getElementById('systemSettings_appearance_bgColorPicker');
    const systemSettings_appearance_colorOptions = document.getElementById('systemSettings_appearance_colorOptions');
    const systemSettings_appearance_resetButton = document.getElementById('systemSettings_appearance_resetButton');
    const systemSettings_appearance_bgImageUrlInput = document.getElementById('systemSettings_appearance_bgImageUrlInput');
    const systemSettings_appearance_bgSizeSelect = document.getElementById('systemSettings_appearance_bgSizeSelect');
    const systemSettings_appearance_bgRepeatSelect = document.getElementById('systemSettings_appearance_bgRepeatSelect');
    const systemSettings_appearance_applyBgImageButton = document.getElementById('systemSettings_appearance_applyBgImageButton');
    const systemSettings_appearance_clearBgImageButton = document.getElementById('systemSettings_appearance_clearBgImageButton');
    const systemSettings_iconSizeSlider = document.getElementById('systemSettings_iconSizeSlider');
    const systemSettings_iconSizeSliderValue = document.getElementById('systemSettings_iconSizeSliderValue');
    const systemSettings_iconSizeResetButton = document.getElementById('systemSettings_iconSizeResetButton');
    const systemSettings_status = document.getElementById('systemSettings_status');
    const systemSettings_ai_modelNameInput = document.getElementById('systemSettings_ai_modelNameInput');
    const systemSettings_ai_saveModelButton = document.getElementById('systemSettings_ai_saveModelButton');
    const systemSettings_ai_groqModelInput = document.getElementById('systemSettings_ai_groqModelInput');
    const systemSettings_ai_saveGroqModelButton = document.getElementById('systemSettings_ai_saveGroqModelButton');
    const systemSettings_ai_groqMaxTokensInput = document.getElementById('systemSettings_ai_groqMaxTokensInput');
    const systemSettings_ai_saveGroqMaxTokensButton = document.getElementById('systemSettings_ai_saveGroqMaxTokensButton');
    const systemSettings_ai_openaiModelInput = document.getElementById('systemSettings_ai_openaiModelInput');
    const systemSettings_ai_saveOpenaiModelButton = document.getElementById('systemSettings_ai_saveOpenaiModelButton');
    const systemSettings_ai_openrouterModelInput = document.getElementById('systemSettings_ai_openrouterModelInput');
    const systemSettings_ai_saveOpenrouterModelButton = document.getElementById('systemSettings_ai_saveOpenrouterModelButton');
    const systemSettings_ai_xaiModelInput = document.getElementById('systemSettings_ai_xaiModelInput');
    const systemSettings_ai_saveXaiModelButton = document.getElementById('systemSettings_ai_saveXaiModelButton');
    const systemSettings_ai_openrouterHttpRefererInput = document.getElementById('systemSettings_ai_openrouterHttpRefererInput');
    const systemSettings_ai_saveOpenrouterHttpRefererButton = document.getElementById('systemSettings_ai_saveOpenrouterHttpRefererButton');
    const systemSettings_ai_deepseekModelInput = document.getElementById('systemSettings_ai_deepseekModelInput');
    const systemSettings_ai_saveDeepseekModelButton = document.getElementById('systemSettings_ai_saveDeepseekModelButton');
    const systemSettings_ai_deepseekMaxTokensInput = document.getElementById('systemSettings_ai_deepseekMaxTokensInput');
    const systemSettings_ai_saveDeepseekMaxTokensButton = document.getElementById('systemSettings_ai_saveDeepseekMaxTokensButton');
    const systemSettings_ai_hfModelIdInput = document.getElementById('systemSettings_ai_hfModelIdInput');
    const systemSettings_ai_saveHfModelButton = document.getElementById('systemSettings_ai_saveHfModelButton');
    const systemSettings_ai_transformersjsModelIdInput = document.getElementById('systemSettings_ai_transformersjsModelIdInput');
    const systemSettings_ai_saveTransformersjsModelButton = document.getElementById('systemSettings_ai_saveTransformersjsModelButton');
    const systemSettings_transformersJsVersion = document.getElementById('systemSettings_transformersJsVersion');
    const systemSettings_transformersjs_status = document.getElementById('systemSettings_transformersjs_status');
    const systemSettings_ai_customEndpointUrlInput = document.getElementById('systemSettings_ai_customEndpointUrlInput');
    const systemSettings_ai_customModelIdInput = document.getElementById('systemSettings_ai_customModelIdInput');
    const systemSettings_ai_saveCustomSettingsButton = document.getElementById('systemSettings_ai_saveCustomSettingsButton');


    const systemSettings_ai_vibeInstruction = document.getElementById('systemSettings_ai_vibeInstruction');
    const systemSettings_ai_saveVibeInstructionButton = document.getElementById('systemSettings_ai_saveVibeInstructionButton');
    const systemSettings_ai_gameGenFinalInstruction = document.getElementById('systemSettings_ai_gameGenFinalInstruction');
    const systemSettings_ai_saveGameGenFinalInstructionButton = document.getElementById('systemSettings_ai_saveGameGenFinalInstructionButton');
    const systemSettings_ai_musicStudioInstruction = document.getElementById('systemSettings_ai_musicStudioInstruction');
    const systemSettings_ai_saveMusicStudioInstructionButton = document.getElementById('systemSettings_ai_saveMusicStudioInstructionButton');
    const systemSettings_ai_gifCreatorNewInstruction = document.getElementById('systemSettings_ai_gifCreatorNewInstruction');
    const systemSettings_ai_saveGifCreatorNewInstructionButton = document.getElementById('systemSettings_ai_saveGifCreatorNewInstructionButton');
    const systemSettings_ai_gifCreatorAnimateInstruction = document.getElementById('systemSettings_ai_gifCreatorAnimateInstruction');
    const systemSettings_ai_saveGifCreatorAnimateInstructionButton = document.getElementById('systemSettings_ai_saveGifCreatorAnimateInstructionButton');
    const systemSettings_about_version = document.getElementById('systemSettings_about_version');
    const geminiModelSettingsDiv = document.getElementById('geminiModelSettings');
    const groqModelSettingsDiv = document.getElementById('groqModelSettings');
    const openaiModelSettingsDiv = document.getElementById('openaiModelSettings');
    const openrouterModelSettingsDiv = document.getElementById('openrouterModelSettings');
    const xaiModelSettingsDiv = document.getElementById('xaiModelSettings');
    const deepseekModelSettingsDiv = document.getElementById('deepseekModelSettings');
    const hfModelSettingsDiv = document.getElementById('hfModelSettings');
    const transformersjsModelSettingsDiv = document.getElementById('transformersjsModelSettings');
    const customProviderSettingsDiv = document.getElementById('customProviderSettings');

    // Calendar Elements
    const calendarPopup = document.getElementById('calendarPopup');
    const calendarMonthYear = document.getElementById('calendarMonthYear');
    const calendarDays = document.getElementById('calendarDays');
    const calendarPrevMonth = document.getElementById('calendarPrevMonth');
    const calendarNextMonth = document.getElementById('calendarNextMonth');

    // Setup Guide Modal Elements
    const setupGuideModal = document.getElementById('setupGuideModal');
    const setupGuideModalTitle = document.getElementById('setupGuideModalTitle');
    const setupGuideModalInstructions = document.getElementById('setupGuideModalInstructions');
    const setupGuideModalCode = document.getElementById('setupGuideModalCode');
    const setupGuideModalCopyButton = document.getElementById('setupGuideModalCopyButton');
    const setupGuideModalCloseButton = document.getElementById('setupGuideModalCloseButton');
    const setupGuideModalStatus = document.getElementById('setupGuideModalStatus');


    window.GLOBAL_GEMINI_API_KEY = null;
    window.GLOBAL_GROQ_API_KEY = null;
    window.GLOBAL_OPENAI_API_KEY = null;
    window.GLOBAL_OPENROUTER_API_KEY = null;
    window.GLOBAL_XAI_API_KEY = null;
    window.GLOBAL_DEEPSEEK_API_KEY = null;
    window.GLOBAL_HF_TOKEN = null;
    window.GLOBAL_TRANSFORMERSJS_MODEL_ID = null;
    window.GLOBAL_CUSTOM_API_KEY = null;

    let selectedApiProvider = 'gemini';

    // Transformers.js specific state
    let transformersJsPipelineInstance = null;
    let currentLoadedTransformersJsModel = null;
    let isTransformersJsModelLoading = false;


    let activeWindow = null;
    let highestZIndex = 100;
    let VFS = { items: {} };
    window.VFS = VFS; // Expose for testing
        
        // Expose a function for iframed apps to get the current AI configuration
        window.getAiConfigurationForIframe = function() {
            const provider = getStoredOrDefault('k8os_apiProvider', 'gemini');
            let key = null;
            switch(provider) {
                case 'gemini': key = window.GLOBAL_GEMINI_API_KEY; break;
                case 'groq': key = window.GLOBAL_GROQ_API_KEY; break;
                case 'openai': key = window.GLOBAL_OPENAI_API_KEY; break;
                case 'openrouter': key = window.GLOBAL_OPENROUTER_API_KEY; break;
                case 'xai': key = window.GLOBAL_XAI_API_KEY; break;
                case 'deepseek': key = window.GLOBAL_DEEPSEEK_API_KEY; break;
                case 'huggingface': key = window.GLOBAL_HF_TOKEN; break;
                case 'custom': key = window.GLOBAL_CUSTOM_API_KEY; break;
            }
            return {
                provider: provider,
                apiKey: key, // The iframe will use this key for its own API calls
                model: getCurrentGeminiModel(), // Defaulting to Gemini model, can be expanded
                // A function the iframe can call to use the parent's AI provider logic
                callParentAiProvider: callCurrentAiProviderForText
            };
        };

    let gameGen_lastHtmlCode = null;
    let gameGen_lastGameAssetPackage = null;
    let gameGen_lastUserIdea = "";
    let musicStudio_lastJsCode = "";
    let musicStudio_currentAudioContext = null;
    let musicStudio_activeSources = [];
    let browserInstances = {};
    let browserWindowCounter = 0;
    let sparkyHtmlPopupCounter = 0;
    let contextMenuTargetVFSId = null;
    let lastSelectedDesktopIcon = null;
    let lastSelectedFileExplorerRow = null;


    let gifCreator_currentAnimatedSvg = null;
    let gifCreator_genAI_model;
    let vibe_genAI_internal_model;
    let gameGen_main_model;
    let musicStudio_genAI_model;
    let assistant_gemini_model;

    const DEFAULT_BG_COLOR = '#008080';
    const PRESET_BG_COLORS = ['#008080', '#000000', '#808080', '#0000A0', '#3A6EA5', '#D3D3D3'];

    let assistantContainer = null;
    let assistantSpeechBubble = null;
    let assistantSpeechText = null;
    let assistantAvatarSVG = null;
    let assistantSparkyMouth = null;
    let assistantIsVisible = false;
    let assistantSpeechTimeout;
    let assistantIsThinking = false;
    let assistantIsProcessingCommand = false;
    let assistantWasDragging = false;
    let k8osActivityLog = [];
    let sparkyCommandHistory = [];
    let sparkyHistoryIndex = -1;
    let sparky_lastImageFile = null;
    let sparkyAssist_lastImageFile = null;
    const ACTIVITY_LOG_MAX_AGE = 5 * 60 * 1000;
    const ASSISTANT_SUMMARY_INTERVAL = 3 * 60 * 1000;
    let assistantSummaryIntervalId = null;

    // Sparky Movement Variables
    let sparkyPosX = 50, sparkyPosY = 50;
    let sparkyVelX = 1, sparkyVelY = 1; // Pixels per update tick
    let sparkyIsMoving = true;
    let sparkyMoveIntervalId = null;
    const SPARKY_CONTAINER_WIDTH = 70; // Approx width of #k8osAssistant_avatarContainer
    const SPARKY_CONTAINER_HEIGHT = 120; // Approx height including potential bubble

    // Sparky Creations Folder
    let SPARKY_CREATIONS_VFS_ID = null;
    const SPARKY_CREATIONS_FOLDER_NAME = "Sparky's Creations";
    // Trash Bin Folder
    let TRASH_VFS_ID = null;
    const TRASH_FOLDER_NAME = "Trash";
    let PASTED_PICTURES_VFS_ID = null;
    const PASTED_PICTURES_FOLDER_NAME = "Pasted Pictures";


    function ensurePastedPicturesFolder() {
        if (PASTED_PICTURES_VFS_ID) {
            const existing = getVFSEntry(PASTED_PICTURES_VFS_ID);
            if (existing && existing.name === PASTED_PICTURES_FOLDER_NAME && existing.parentId === 'root') {
                return PASTED_PICTURES_VFS_ID;
            }
        }
        const rootChildren = getVFSChildren('root');
        const existingFolder = rootChildren.find(item => item.type === 'folder' && item.name === PASTED_PICTURES_FOLDER_NAME);
        if (existingFolder) {
            PASTED_PICTURES_VFS_ID = existingFolder.id;
            return existingFolder.id;
        } else {
            const newFolder = createVFSEntry({ type: 'folder', name: PASTED_PICTURES_FOLDER_NAME, parentId: 'root' });
            PASTED_PICTURES_VFS_ID = newFolder.id;
            return newFolder.id;
        }
    }

    // --- Setup Guide Modal Functions ---
    function openSetupGuideModal(title, instructions, codeSnippet) {
        if (!setupGuideModal || !setupGuideModalTitle || !setupGuideModalInstructions || !setupGuideModalCode || !setupGuideModalStatus) return;

        setupGuideModalTitle.textContent = title;
        setupGuideModalInstructions.innerHTML = instructions; // Use innerHTML if instructions include <strong> etc.
        setupGuideModalCode.value = codeSnippet;
        setupGuideModalStatus.textContent = "Click 'Copy Code' then paste into your environment.";
        setupGuideModal.style.display = 'flex';
        bringToFront(setupGuideModal); // Make sure it's on top
    }

    function closeSetupGuideModal() {
        if (setupGuideModal) {
            setupGuideModal.style.display = 'none';
        }
    }

    if (setupGuideModalCloseButton) {
        setupGuideModalCloseButton.addEventListener('click', closeSetupGuideModal);
    }

    if (setupGuideModalCopyButton) {
        setupGuideModalCopyButton.addEventListener('click', () => {
            if (setupGuideModalCode && setupGuideModalStatus) {
                navigator.clipboard.writeText(setupGuideModalCode.value).then(() => {
                    setupGuideModalStatus.textContent = "Code copied to clipboard!";
                    setTimeout(() => {
                         if (setupGuideModal.style.display === 'flex') { // Only reset if modal is still open
                            setupGuideModalStatus.textContent = "Click 'Copy Code' then paste into your environment.";
                         }
                    }, 2000);
                }).catch(err => {
                    setupGuideModalStatus.textContent = "Failed to copy. Please copy manually.";
                    console.error('Failed to copy text: ', err);
                });
            }
        });
    }

    function getCustomSetupGuideContent() {
        const title = "⚙️ Custom Endpoint Setup Guide (Python/Flask)";
        const instructions = `
            <p>This guide provides a Python Flask server that can act as a dual-purpose custom endpoint for k8OS.</p>
            <p style="font-size:11px;">It can handle both <strong>LLM Prompts</strong> (from AI apps) and <strong>JavaScript Execution</strong> (from the Workflow app's 'Execute JS' node).</p>
            <ol style="margin-left: 20px; font-size:11px;">
                <li>Save the code below as a Python file (e.g., <code>server.py</code>).</li>
                <li>Install dependencies: <code>pip install Flask flask-cors</code>. For LLM requests, you'll need your own LLM library (e.g., <code>transformers</code>). For JS execution, you must have <strong>Node.js installed</strong> on the server.</li>
                <li><strong>Important:</strong> Replace <code>'YOUR_VERY_SECRET_API_KEY'</code> with a strong, unique API key you create.</li>
                <li><strong>Logic:</strong> The server checks for an <code>action</code> in the JSON payload.
                    <ul>
                        <li style="margin-top:4px;">If <code>action</code> is <code>"execute_js"</code>, it runs the provided code with Node.js.</li>
                        <li>If <code>action</code> is <code>"llm_prompt"</code> or is missing, it passes the prompt to your LLM logic.</li>
                    </ul>
                </li>
                <li>Run the server: <code>python server.py</code>.</li>
                <li>Expose the server to the internet using a tool like <a href="https://ngrok.com/docs/getting-started" target="_blank" rel="noopener noreferrer">ngrok</a> (e.g., <code>ngrok http 5000</code>). This will give you a public URL.</li>
                <li>The endpoint for k8OS is the public URL + <code>/generate</code> (e.g., <code>https://xxxx...ngrok.io/generate</code>).</li>
                <li>In k8OS API Key Settings, select "Custom Endpoint", enter the API key you created.</li>
                <li>In k8OS System Settings, enter the full <code>.../generate</code> URL for "Custom Endpoint URL".</li>
            </ol>
        `;
        const codeSnippet = `
from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import subprocess
import json

# --- Configuration ---
# IMPORTANT: Use an environment variable in production for the API key
ENDPOINT_API_KEY = 'YOUR_VERY_SECRET_API_KEY' # Replace with your chosen API key
# --- End Configuration ---

app = Flask(__name__)
# IMPORTANT: Restrict the origin in a production environment for security
CORS(app) # Enable CORS for all routes

def handle_llm_request(data):
    """Handles traditional Language Model requests."""
    if 'prompt' not in data:
        return jsonify({"error": "Bad Request: Missing 'prompt' in JSON payload for LLM request"}), 400

    prompt = data.get('prompt')
    model_id = data.get('model', 'default_custom_model')

    # --- LLM LOGIC ---
    # Replace this with your actual LLM call (e.g., to a local model)
    llm_response = f"LLM received prompt: '{prompt[:80]}...'. Model: {model_id}."
    # --- End LLM LOGIC ---

    return jsonify({"response": llm_response})

def handle_js_execution(data):
    """Handles requests to execute JavaScript code using Node.js."""
    if 'code' not in data:
        return jsonify({"error": "Bad Request: Missing 'code' in JSON payload for JS execution"}), 400

    js_code = data['code']

    try:
        # Execute the Node.js code in a subprocess
        # IMPORTANT: Using a timeout is crucial for security and stability.
        # Ensure the 'node' executable is in your system's PATH.
        process = subprocess.run(
            ['node', '-e', js_code],
            capture_output=True,
            text=True,
            timeout=10  # 10-second timeout to prevent long-running scripts
        )

        if process.returncode == 0:
            # Success
            return jsonify({"result": process.stdout.strip()})
        else:
            # Error during execution
            return jsonify({"error": "Node.js execution failed", "details": process.stderr.strip()}), 400

    except FileNotFoundError:
        return jsonify({"error": "Internal Server Error", "details": "'node' executable not found. Is Node.js installed and in your PATH?"}), 500
    except subprocess.TimeoutExpired:
        return jsonify({"error": "Request Timeout", "details": "Node.js script took too long to execute."}), 408
    except Exception as e:
        return jsonify({"error": "Internal Server Error", "details": str(e)}), 500

@app.route('/generate', methods=['POST'])
def generate():
    # 1. API Key Authentication
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Unauthorized: Missing or malformed Bearer token"}), 401
    
    token = auth_header.split(' ')[1]
    if token != ENDPOINT_API_KEY:
        return jsonify({"error": "Unauthorized: Invalid API Key"}), 401

    # 2. Get data and determine action
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "Bad Request: Missing JSON payload"}), 400

        action = data.get('action', 'llm_prompt') # Default to 'llm_prompt' if no action is specified

        if action == 'execute_js':
            return handle_js_execution(data)
        elif action == 'llm_prompt':
            return handle_llm_request(data)
        else:
            return jsonify({"error": "Bad Request", "details": f"Unknown action: {action}"}), 400

    except Exception as e:
        print(f"Error during generation: {e}")
        return jsonify({"error": "Internal Server Error", "details": str(e)}), 500

if __name__ == '__main__':
    if not ENDPOINT_API_KEY or ENDPOINT_API_KEY == 'YOUR_VERY_SECRET_API_KEY':
        print("ERROR: Please set your ENDPOINT_API_KEY in the script.")
    else:
        # Port can be configured via environment variable or default to 5000
        port = int(os.environ.get('PORT', 5000))
        print(f"Starting custom endpoint server on port {port}...")
        app.run(host='0.0.0.0', port=port)
`;
        return { title, instructions, codeSnippet };
    }


    // --- Terminal ---
    const terminalWindow = document.getElementById('terminalWindow');
    const terminalContent = document.getElementById('terminal_content');
    let terminalOutput = document.getElementById('terminal_output');
    let terminalInput = document.getElementById('terminal_input');
    let terminalPrompt = document.querySelector('.terminal-prompt');

    let commandHistory = [];
    let historyIndex = -1;
    let currentVfsDirId = 'root';

    function initializeTerminal() {
        if(terminalWindow) {
             terminalContent.addEventListener('click', (e) => {
                if (e.target === terminalContent || e.target === terminalOutput) {
                    terminalInput.focus();
                }
             });
             terminalInput.addEventListener('keydown', handleTerminalInput);
             terminalInput.focus();
        }
    }

    function handleTerminalInput(e) {
        if (e.key === 'Tab') {
            e.preventDefault();
            handleTabCompletion();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            const command = terminalInput.value.trim();
            const currentInputLine = terminalInput.parentElement;
            currentInputLine.removeChild(terminalInput);
            const commandTextNode = document.createTextNode(command);
            currentInputLine.appendChild(commandTextNode);

            if (command) {
                commandHistory.push(command);
                historyIndex = commandHistory.length;
                processCommandChain(command);
            } else {
                createNewInputLine();
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (historyIndex > 0) {
                historyIndex--;
                terminalInput.value = commandHistory[historyIndex];
                terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (historyIndex < commandHistory.length - 1) {
                historyIndex++;
                terminalInput.value = commandHistory[historyIndex];
                terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
            } else {
                historyIndex = commandHistory.length;
                terminalInput.value = '';
            }
        } else if (e.key === 'l' && e.ctrlKey) {
            e.preventDefault();
            terminalCommands.clear();
            createNewInputLine();
        }
    }

    function handleTabCompletion() {
        console.log('Tab completion triggered.');
        const input = terminalInput.value;
        const parts = input.split(/\s+/);
        let currentWord = parts[parts.length - 1];
        if (input.endsWith(' ')) {
            currentWord = '';
        }

        const isCommandCompletion = parts.length <= 1 && !input.includes(' ');
        console.log(`Input: "${input}", Parts: ${parts}, Current Word: "${currentWord}", Is Command Completion: ${isCommandCompletion}`);

        let potentialMatches = [];
        if (isCommandCompletion) {
            potentialMatches = Object.keys(terminalCommands);
            console.log('Completion type: Command. Potential matches:', potentialMatches);
        } else {
            const children = getVFSChildren(currentVfsDirId);
            potentialMatches = children.map(c => c.name.includes(' ') ? `"${c.name}"` : c.name);
            console.log('Completion type: File/Path. Potential matches:', potentialMatches);
        }

        const matches = potentialMatches.filter(p => p.startsWith(currentWord));
        console.log('Filtered matches:', matches);

        if (matches.length === 1) {
            const baseInput = input.substring(0, input.lastIndexOf(currentWord));
            let completed = baseInput + matches[0];
            terminalInput.value = completed + ' ';
            console.log(`Completed to: "${terminalInput.value}"`);
        } else if (matches.length > 1) {
            // If multiple matches, show them to the user
            printToTerminal(matches.join('  '));
            createNewInputLine();
            terminalInput.value = input; // Restore the user's original input
        }
    }

    async function processCommandChain(fullCommand) {
        const andChains = fullCommand.split('&&').map(s => s.trim());
        let lastSuccess = true;

        for (const chain of andChains) {
            if (!lastSuccess) break;

            const commands = chain.split(';').map(c => c.trim()).filter(c => c);
            for (const commandStr of commands) {
                const [commandPart, ...redirectParts] = commandStr.split('>');
                const outputFile = redirectParts.length > 0 ? redirectParts.join('>').trim() : null;

                const args = commandPart.trim().match(/(?:[^\s"]+|"[^"]*")+/g) || [];
                const cmd = args.shift()?.replace(/"/g, '');
                const cleanedArgs = args.map(arg => arg.replace(/"/g, ''));

                let result = { output: '', success: false };
                if (cmd) {
                    const commandFunc = terminalCommands[cmd];
                    if (commandFunc) {
                        try {
                            result = await Promise.resolve(commandFunc(cleanedArgs));
                        } catch (e) {
                            result = { output: `Error: ${e.message}`, success: false };
                        }
                    } else {
                        result = { output: `-k8os: ${cmd}: command not found`, success: false };
                    }
                }

                if (outputFile) {
                    if (result.success) {
                        const existing = getVFSChildren(currentVfsDirId).find(c => c.name === outputFile);
                        if (existing) {
                            updateVFSEntry(existing.id, { content: result.output });
                        } else {
                            createVFSEntry({ name: outputFile, content: result.output, parentId: currentVfsDirId, type: 'file' });
                        }
                        printToTerminal(`Output redirected to ${outputFile}`);
                    } else {
                        printToTerminal(result.output); // Print error instead of redirecting
                    }
                } else if (result.output) {
                    printToTerminal(result.output);
                }

                lastSuccess = result.success;
                if (!lastSuccess) break;
            }
        }
        createNewInputLine();
            return lastSuccess; // Return status for workflow engine
    }

    function createNewInputLine() {
        const currentPath = getVFSPathString(currentVfsDirId);
        const pathForPrompt = currentPath === '/' ? '~' : currentPath.split('/').pop();

        const newLine = document.createElement('div');
        newLine.className = 'terminal-input-line';

        const newPrompt = document.createElement('span');
        newPrompt.className = 'terminal-prompt';

        const pathSpan = document.createElement('span');
        pathSpan.style.color = '#87AF5F';
        pathSpan.textContent = pathForPrompt;

        const dollarSpan = document.createElement('span');
        dollarSpan.style.color = '#5F87AF';
        dollarSpan.textContent = ' $';

        newPrompt.appendChild(pathSpan);
        newPrompt.appendChild(dollarSpan);

        const newInput = document.createElement('input');
        newInput.type = 'text';
        newInput.id = 'terminal_input';
        newInput.autocomplete = 'off';
        newInput.autocorrect = 'off';
        newInput.autocapitalize = 'off';
        newInput.spellcheck = false;

        newLine.appendChild(newPrompt);
        newLine.appendChild(newInput);
        terminalOutput.appendChild(newLine);

        terminalInput = newInput;
        terminalPrompt = newPrompt;
        terminalInput.addEventListener('keydown', handleTerminalInput);
        terminalInput.focus();

        terminalContent.scrollTop = terminalContent.scrollHeight;
    }

    function printToTerminal(text) {
        const outputLine = document.createElement('div');
        outputLine.style.whiteSpace = 'pre-wrap';
        outputLine.textContent = text;
        const currentInputLine = terminalInput.parentElement;
        terminalOutput.insertBefore(outputLine, currentInputLine);
    }

    const terminalCommands = {
        help: () => {
            const text = `k8OS Terminal v0.1
Available commands:
  help         - Show this help message
  clear        - Clear the terminal screen (or Ctrl+L)
  date         - Display the current date and time
  echo [text]  - Display a line of text
  browse [url] - Open URL in the browser
  edit [file]  - Open a file in the text editor

  --- VFS ---
  pwd          - Print working directory
  ls [path]    - List directory contents
  cd [path]    - Change directory
  mkdir [name] - Create a directory
  touch [name] - Create a file
  rm [name]    - Remove a file or empty directory

  --- AI ---
  svg "[prompt]"           - Create an SVG file
  gif "[prompt]"           - Create an animated SVG file
  gif animate [file] "[prompt]" - Animate an existing SVG
  music "[prompt]"         - Create a music file
  gamegen "[prompt]"       - Create a game folder

  --- System ---
  apikey set [prov] [key] - Set an API key (gemini, groq)
  settings set [key] [val] - Change a system setting (e.g., 'desktop.color')
  js [code]              - Execute JavaScript code
  curl [url] > [file]    - Fetch URL content and print or save to file`;
            return { output: text, success: true };
        },
        clear: () => {
            terminalOutput.innerHTML = 'Welcome to k8OS Terminal! Type \'help\' for a list of commands.';
            return { output: '', success: true };
        },
        date: () => ({ output: new Date().toString(), success: true }),
        echo: (args) => ({ output: args.join(' '), success: true }),
        pwd: () => ({ output: getVFSPathString(currentVfsDirId), success: true }),
        ls: (args) => {
            const path = args.join(' ');
            const targetId = path ? resolveVFSPath(path) : currentVfsDirId;
            if (!targetId) return { output: `ls: cannot access '${path}': No such file or directory`, success: false };

            if (targetId !== 'root') {
                const targetEntry = getVFSEntry(targetId);
                if (targetEntry.type !== 'folder') return { output: targetEntry.name, success: true };
            }

            const children = getVFSChildren(targetId);
            const output = children.map(child => child.type === 'folder' ? `${child.name}/` : child.name).join('\n');
            return { output: output, success: true };
        },
        cd: (args) => {
            const targetPath = args.join(' ');
            if (!targetPath) {
                currentVfsDirId = 'root';
                return { output: '', success: true };
            }
            const targetId = resolveVFSPath(targetPath);

            if (!targetId) return { output: `cd: no such file or directory: ${targetPath}`, success: false };

            const targetEntry = getVFSEntry(targetId);
            if (targetId !== 'root' && targetEntry.type !== 'folder') return { output: `cd: not a directory: ${targetEntry.name}`, success: false };

            currentVfsDirId = targetId;
            return { output: '', success: true };
        },
        mkdir: (args) => {
            const dirName = args.join(' ');
            if (!dirName) return { output: 'mkdir: missing operand', success: false };
            const existing = getVFSChildren(currentVfsDirId).find(c => c.name === dirName);
            if (existing) return { output: `mkdir: cannot create directory ‘${dirName}’: File exists`, success: false };
            createVFSEntry({ type: 'folder', name: dirName, parentId: currentVfsDirId });
            return { output: '', success: true };
        },
        touch: (args) => {
            const fileName = args.join(' ');
            if (!fileName) return { output: 'touch: missing file operand', success: false };
            const existing = getVFSChildren(currentVfsDirId).find(c => c.name === fileName);
            if (!existing) {
                createVFSEntry({ type: 'file', name: fileName, parentId: currentVfsDirId, content: '' });
            } else {
                updateVFSEntry(existing.id, { modified: Date.now() });
            }
            return { output: '', success: true };
        },
        rm: (args) => {
            const targetName = args.join(' ');
            if (!targetName) return { output: 'rm: missing operand', success: false };
            const targetId = resolveVFSPath(targetName);
            if (!targetId) return { output: `rm: cannot remove '${targetName}': No such file or directory`, success: false };

            const entry = getVFSEntry(targetId);
            if (entry.type === 'folder' && getVFSChildren(targetId).length > 0) {
                return { output: `rm: cannot remove '${targetName}': Directory not empty`, success: false };
            }
            deleteVFSEntry(targetId);
            return { output: '', success: true };
        },
        browse: (args) => {
            const url = args[0];
            if (!url) return { output: 'browse: missing URL', success: false };
            openNewBrowserWindow(url);
            return { output: '', success: true };
        },
        edit: (args) => {
            const fileName = args.join(' ');
            if (!fileName) return { output: 'edit: missing file operand', success: false };
            let targetId = resolveVFSPath(fileName);
            if (!targetId) {
                const touchResult = terminalCommands.touch(args);
                if (!touchResult.success) return touchResult;
                targetId = resolveVFSPath(fileName);
            }
            const entry = getVFSEntry(targetId);
            if (entry.type !== 'file') return { output: `edit: '${fileName}' is not a file`, success: false };
            openWindow('textEditorWindow', { fileId: targetId });
            return { output: '', success: true };
        },
        svg: async (args) => {
            const prompt = args.join(' ');
            if (!prompt) return { output: 'svg: missing prompt', success: false };
            printToTerminal(`Generating SVG for "${prompt}"...`);
            const svgCode = await internal_generateSingleSvg(prompt, false);
            if (!svgCode) return { output: 'SVG generation failed.', success: false };
            const fileName = `${prompt.substring(0, 20).replace(/[^a-z0-9]/gi, '_') || 'image'}.svg`;
            createVFSEntry({ type: 'file', name: fileName, content: svgCode, parentId: currentVfsDirId, mimeType: 'image/svg+xml' });
            return { output: `Saved to ${fileName}`, success: true };
        },
        music: async (args) => {
            const prompt = args.join(' ');
            if (!prompt) return { output: 'music: missing prompt', success: false };
            printToTerminal(`Generating music for "${prompt}"...`);
            const jsCode = await internal_generateSingleSoundJs(prompt);
            if (!jsCode) return { output: 'Music generation failed.', success: false };
            const fileName = `${prompt.substring(0, 20).replace(/[^a-z0-9]/gi, '_') || 'music'}.js`;
            createVFSEntry({ type: 'file', name: fileName, content: jsCode, parentId: currentVfsDirId, mimeType: 'application/javascript' });
            return { output: `Saved to ${fileName}`, success: true };
        },
        gamegen: async (args) => {
            const prompt = args.join(' ');
            if (!prompt) return { output: 'gamegen: missing prompt', success: false };

            const statusUpdater = (msg) => {
                const statusLine = document.createElement('div');
                statusLine.textContent = `> ${msg}`;
                const currentInputLine = terminalInput.parentElement;
                terminalOutput.insertBefore(statusLine, currentInputLine);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            };

            try {
                const gamePackage = await executeGameGeneration(prompt, false, '', '', statusUpdater);
                if (gamePackage && gamePackage.html) {
                    const gameName = prompt.substring(0, 25).replace(/[^a-z0-9]/gi, '_') || 'generated-game';
                    const gameFolderName = `${gameName}-${Date.now().toString(36)}`;
                    const gameFolder = createVFSEntry({ type: 'folder', name: gameFolderName, parentId: currentVfsDirId });
                    const assetsFolder = createVFSEntry({ type: 'folder', name: 'assets', parentId: gameFolder.id });

                    for (const asset of gamePackage.assets) {
                        createVFSEntry({ type: 'file', name: asset.filename, content: asset.content, mimeType: asset.type === 'svg' ? 'image/svg+xml' : 'application/javascript', parentId: assetsFolder.id });
                    }
                    createVFSEntry({ type: 'file', name: 'index.html', content: gamePackage.html, mimeType: 'text/html', parentId: gameFolder.id });

                    return { output: `Game saved to folder: ${gameFolderName}/`, success: true };
                } else {
                    return { output: 'Game generation failed to produce valid HTML.', success: false };
                }
            } catch(e) {
                return { output: `Game generation failed: ${e.message}`, success: false };
            }
        },
        gif: async (args) => {
            if (args[0] === 'animate' && args.length > 1) {
                const filePath = args[1];
                const prompt = args.slice(2).join(' ');
                if (!prompt) return { output: 'gif animate: missing animation prompt', success: false };

                const fileId = resolveVFSPath(filePath);
                if (!fileId) return { output: `gif: cannot access '${filePath}': No such file or directory`, success: false };

                const entry = getVFSEntry(fileId);
                if (entry.type !== 'file' || !entry.mimeType.includes('svg')) return { output: `gif: '${filePath}' is not an SVG file`, success: false };

                printToTerminal(`Animating ${filePath} with prompt: "${prompt}"...`);
                const baseInstruction = getAppInstruction('gifCreatorAnimate', DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION);
                const fullPrompt = baseInstruction.replace("{STATIC_SVG_CODE}", entry.content).replace("{ANIMATION_PROMPT}", prompt);
                const animatedSvg = await callCurrentAiProviderForText(fullPrompt, 80000, 0.4);
                if (!animatedSvg) return { output: 'Animation failed.', success: false };

                updateVFSEntry(fileId, { content: animatedSvg });
                return { output: `Animated ${filePath} in-place.`, success: true };

            } else {
                const prompt = args.join(' ');
                if (!prompt) return { output: 'gif: missing prompt', success: false };
                printToTerminal(`Generating animated GIF for "${prompt}"...`);
                const animatedSvg = await internal_generateSingleSvg(prompt, true);
                if (!animatedSvg) return { output: 'GIF generation failed.', success: false };
                const fileName = `anim_${prompt.substring(0, 20).replace(/[^a-z0-9]/gi, '_') || 'image'}.svg`;
                createVFSEntry({ type: 'file', name: fileName, content: animatedSvg, parentId: currentVfsDirId, mimeType: 'image/svg+xml' });
                return { output: `Saved to ${fileName}`, success: true };
            }
        },
        apikey: (args) => {
            if (args[0] !== 'set' || args.length < 3) return { output: 'Usage: apikey set [provider] [key]', success: false };
            const provider = args[1].toLowerCase();
            const key = args[2];
            let storageKey = '';
            switch (provider) {
                case 'gemini': storageKey = 'k8os_GlobalGeminiApiKey'; break;
                case 'groq': storageKey = 'k8os_GlobalGroqApiKey'; break;
                // Add other providers here as needed
                default: return { output: `apikey: unknown provider '${provider}'`, success: false };
            }
            localStorage.setItem(storageKey, key);
            loadApiKey(); // Reload keys and re-init apps
            return { output: `API key for ${provider} set.`, success: true };
        },
        settings: (args) => {
            if (args[0] !== 'set' || args.length < 3) return { output: 'Usage: settings set [key] [value]', success: false };
            const key = args[1];
            const value = args.slice(2).join(' ');
            switch(key) {
                case 'desktop.color':
                    setDesktopBackground(value);
                    break;
                default:
                    return { output: `settings: unknown key '${key}'. Supported: desktop.color`, success: false };
            }
            return { output: `Set ${key} to ${value}`, success: true };
        },
        js: (args) => {
            const input = args.join(' ');
            if (!input) return { output: 'js: missing code or file operand', success: false };

            const targetId = resolveVFSPath(input);
            let codeToExecute = input;
            let isFile = false;
            let isMusicScript = false;
            let entryName = input;

            if (targetId) {
                const entry = getVFSEntry(targetId);
                if (entry && entry.type === 'file') {
                    codeToExecute = entry.content || '';
                    isFile = true;
                    entryName = entry.name;
                    if (entry.name.toLowerCase().endsWith('.js')) {
                        isMusicScript = true;
                    }
                }
            }

            try {
                if (isFile && isMusicScript) {
                    // It's a JS file, likely from Music Studio. Play it properly.
                    stopAllMusicStudioSounds(); // Stop any previous sounds
                    musicStudio_currentAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    musicStudio_activeSources = [];

                    const soundFunction = new Function('audioContext', 'activeSources', codeToExecute);
                    soundFunction(musicStudio_currentAudioContext, musicStudio_activeSources);

                    logK8osActivity("Terminal", `Played music script: ${entryName}`);
                    return { output: `Playing music from ${entryName}...`, success: true };
                } else {
                    // It's raw code or a non-JS file's content
                    const result = eval(codeToExecute);
                    return { output: String(result), success: true };
                }
            } catch (e) {
                return { output: e.message, success: false };
            }
        },
        curl: async (args) => {
            const url = args[0];
            if (!url) return { output: 'curl: missing URL', success: false };
            try {
                const response = await fetch(url);
                if (!response.ok) return { output: `curl: request failed with status ${response.status}`, success: false };
                const text = await response.text();
                return { output: text, success: true };
            } catch (e) {
                return { output: `curl: request failed: ${e.message}`, success: false };
            }
        }
    };

    function resolveVFSPath(path) {
        if (path.startsWith('/')) {
            // Absolute path
            const parts = path.split('/').filter(p => p);
            let currentId = 'root';
            for (const part of parts) {
                const children = getVFSChildren(currentId);
                const found = children.find(c => c.name === part);
                if (!found) return null; // Not found
                currentId = found.id;
            }
            return currentId;
        } else {
            // Relative path
            const parts = path.split('/').filter(p => p);
            let currentId = currentVfsDirId;
            for (const part of parts) {
                if (part === '..') {
                    const parent = getVFSEntry(currentId)?.parentId;
                    currentId = parent || 'root';
                } else if (part !== '.') {
                    const children = getVFSChildren(currentId);
                    const found = children.find(c => c.name === part);
                    if (!found) return null;
                    currentId = found.id;
                }
            }
            return currentId;
        }
    }

    // --- End Terminal ---

    // --- VFS Functions ---
    function ensureVFSPath(path) {
        const parts = path.split('/').filter(p => p);
        let currentParentId = 'root';

        for (const part of parts) {
            const children = getVFSChildren(currentParentId);
            let foundFolder = children.find(child => child.type === 'folder' && child.name === part);

            if (foundFolder) {
                currentParentId = foundFolder.id;
            } else {
                const newFolder = createVFSEntry({
                    type: 'folder',
                    name: part,
                    parentId: currentParentId
                });
                currentParentId = newFolder.id;
            }
        }
        return currentParentId;
    }
    function handleItemDropOnTrash(e) {
        e.preventDefault();
        e.stopPropagation();
        const vfsItemIds = (e.dataTransfer.getData('text/vfs-item-ids') || e.dataTransfer.getData('text/vfs-item-id') || "").split(',').filter(id => id);
        
        if (vfsItemIds.length > 0) {
            let itemsMoved = 0;
            vfsItemIds.forEach(vfsItemId => {
                const item = getVFSEntry(vfsItemId);
                if (item && item.id !== TRASH_VFS_ID && item.parentId !== TRASH_VFS_ID) {
                    updateVFSEntry(vfsItemId, { parentId: TRASH_VFS_ID });
                    logK8osActivity("VFS", `Dragged '${item.name}' to trash.`);
                    itemsMoved++;
                }
            });

            if (itemsMoved > 0) {
                renderDesktopVFSIcons();
                const fileExplorerWindow = document.getElementById('fileExplorerWindow');
                if (fileExplorerWindow && fileExplorerWindow.style.display === 'flex') {
                    renderVFSFileList(currentFEVfsPathId);
                }
            }
        }
    }
    function generateUniqueId() { return Date.now().toString(36) + Math.random().toString(36).substring(2, 7); }
    function loadVFS() {
        const storedVFSItems = localStorage.getItem('k8os_vfs_items');
        if (storedVFSItems) { try { VFS.items = JSON.parse(storedVFSItems); } catch (e) { console.error("Error parsing VFS from localStorage:", e); VFS.items = {}; } }
        else { VFS.items = {}; }
        ensureSparkyCreationsFolder();
        ensureTrashFolder();
        ensurePastedPicturesFolder();
        renderDesktopVFSIcons();
    }
    function saveVFS() { try { localStorage.setItem('k8os_vfs_items', JSON.stringify(VFS.items)); } catch (e) { console.error("Error saving VFS to localStorage:", e); alert("Error saving file system state. LocalStorage might be full."); } }
    function createVFSEntry(entryData) {
        if (!entryData.id) entryData.id = generateUniqueId();
        if (!entryData.parentId) entryData.parentId = 'root';
        if (!entryData.modified) entryData.modified = Date.now();
        VFS.items[entryData.id] = entryData; saveVFS(); return VFS.items[entryData.id];
    }
    window.createVFSEntry = createVFSEntry; // Expose for testing
    function getVFSEntry(id) { return VFS.items[id]; }
    function updateVFSEntry(id, updates) { if (VFS.items[id]) { VFS.items[id] = { ...VFS.items[id], ...updates, modified: Date.now() }; saveVFS(); return VFS.items[id]; } return null; }
    function deleteVFSEntry(id) {
        if (VFS.items[id]) {
            const entryType = VFS.items[id].type; delete VFS.items[id];
            if (entryType === 'folder') { const children = Object.values(VFS.items).filter(item => item.parentId === id); children.forEach(child => deleteVFSEntry(child.id)); }
            saveVFS(); renderDesktopVFSIcons(); if(fe_fileListElement && currentFEVfsPathId) renderVFSFileList(currentFEVfsPathId); return true; // Refresh File Explorer if open
        } return false;
    }
    function getVFSChildren(parentId, sortBy = 'name', sortDir = 'asc') {
        let children = Object.values(VFS.items).filter(item => item.parentId === parentId);

        children.sort((a, b) => {
            // Always sort folders before files
            if (a.type === 'folder' && b.type !== 'folder') return -1;
            if (a.type !== 'folder' && b.type === 'folder') return 1;

            const valA = getSortValue(a, sortBy);
            const valB = getSortValue(b, sortBy);

            let comparison = 0;
            if (typeof valA === 'string' && typeof valB === 'string') {
                comparison = valA.localeCompare(valB, undefined, { numeric: true, sensitivity: 'base' });
            } else {
                comparison = valA < valB ? -1 : (valA > valB ? 1 : 0);
            }

            return sortDir === 'asc' ? comparison : -comparison;
        });

        return children;
    }

    function getSortValue(item, sortBy) {
        switch (sortBy) {
            case 'type':
                return item.type || '';
            case 'modified':
                return item.modified || 0;
            case 'name':
            default:
                return item.name;
        }
    }
    function isAncestor(potentialAncestorId, childId) {
        let current = getVFSEntry(childId);
        if (!current) return false;
        while (current.parentId && current.parentId !== 'root') {
            if (current.parentId === potentialAncestorId) {
                return true;
            }
            current = getVFSEntry(current.parentId);
            if (!current) return false;
        }
        return false;
    }

    function getVFSPathString(itemId) {
        if (itemId === 'root') return '/';
        const entry = getVFSEntry(itemId);
        if (!entry) return '/unknown';

        let pathParts = [];
        let currentItem = entry;
        while(currentItem && currentItem.id !== 'root') {
            pathParts.unshift(currentItem.name);
            const parent = getVFSEntry(currentItem.parentId);
            currentItem = parent;
        }
        return '/' + pathParts.join('/');
    }

    function ensureSparkyCreationsFolder() {
        if (SPARKY_CREATIONS_VFS_ID) {
            const existing = getVFSEntry(SPARKY_CREATIONS_VFS_ID);
            if (existing && existing.name === SPARKY_CREATIONS_FOLDER_NAME && existing.parentId === 'root') {
                return SPARKY_CREATIONS_VFS_ID;
            }
        }
        const rootChildren = getVFSChildren('root');
        const existingFolder = rootChildren.find(item => item.type === 'folder' && item.name === SPARKY_CREATIONS_FOLDER_NAME);
        if (existingFolder) {
            SPARKY_CREATIONS_VFS_ID = existingFolder.id;
            return existingFolder.id;
        } else {
            const newFolder = createVFSEntry({ type: 'folder', name: SPARKY_CREATIONS_FOLDER_NAME, parentId: 'root' });
            SPARKY_CREATIONS_VFS_ID = newFolder.id;
            return newFolder.id;
        }
    }

    function ensureTrashFolder() {
        if (TRASH_VFS_ID) {
            const existing = getVFSEntry(TRASH_VFS_ID);
            if (existing && existing.name === TRASH_FOLDER_NAME && existing.parentId === 'root') {
                return TRASH_VFS_ID;
            }
        }
        const rootChildren = getVFSChildren('root');
        const existingFolder = rootChildren.find(item => item.type === 'folder' && item.name === TRASH_FOLDER_NAME);
        if (existingFolder) {
            TRASH_VFS_ID = existingFolder.id;
            return existingFolder.id;
        } else {
            const newFolder = createVFSEntry({ type: 'folder', name: TRASH_FOLDER_NAME, parentId: 'root' });
            TRASH_VFS_ID = newFolder.id;
            return newFolder.id;
        }
    }

    function renderDesktopVFSIcons() {
        document.querySelectorAll('.desktop-icon[data-item-type="file"], .desktop-icon[data-item-type="folder"]').forEach(icon => icon.remove());
        const desktopItems = getVFSChildren('root');
        desktopItems.forEach(item => {
            if ((item.name === SPARKY_CREATIONS_FOLDER_NAME || item.name === TRASH_FOLDER_NAME) && item.parentId === 'root') {
                 if (item.name === SPARKY_CREATIONS_FOLDER_NAME && !SPARKY_CREATIONS_VFS_ID) SPARKY_CREATIONS_VFS_ID = item.id;
                 if (item.name === TRASH_FOLDER_NAME && !TRASH_VFS_ID) TRASH_VFS_ID = item.id;
                 return;
            }

            const iconEl = document.createElement('div'); iconEl.className = 'desktop-icon';
            iconEl.dataset.itemId = item.id; iconEl.dataset.itemType = item.type;
            iconEl.draggable = true;
            iconEl.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/vfs-item-id', item.id);
                e.dataTransfer.effectAllowed = 'move';
            });
            const placeholder = document.createElement('div'); placeholder.className = 'icon-placeholder';
            placeholder.textContent = item.type === 'file' ? (item.name.endsWith('.html') || item.name.endsWith('.htm') ? '🌐' : '📄') : '📁';
            const span = document.createElement('span'); span.textContent = item.name;
            iconEl.appendChild(placeholder); iconEl.appendChild(span); desktopElement.appendChild(iconEl);
        });
        initializeDesktopIconBehaviors();
    }
    function initializeDesktopIconBehaviors() {
        // Clear selections when clicking on the desktop itself
        desktopElement.addEventListener('click', (e) => {
            if (e.target === desktopElement) {
                document.querySelectorAll('.desktop-icon.selected').forEach(i => i.classList.remove('selected'));
                lastSelectedDesktopIcon = null;
            }
        });

        document.querySelectorAll('.desktop-icon').forEach(icon => {
            const newIcon = icon.cloneNode(true); icon.parentNode.replaceChild(newIcon, icon);
            newIcon.addEventListener('dblclick', (e) => handleDesktopIconDblClick(e.currentTarget));
            
            newIcon.addEventListener('dragstart', (e) => {
                const selectedIcons = document.querySelectorAll('.desktop-icon.selected[data-item-id]');
                let draggedItemIds = [];

                if (selectedIcons.length > 0 && newIcon.classList.contains('selected')) {
                    selectedIcons.forEach(icon => {
                        draggedItemIds.push(icon.dataset.itemId);
                    });
                } else {
                    if (newIcon.dataset.itemId) {
                        draggedItemIds.push(newIcon.dataset.itemId);
                    }
                }
                
                if (draggedItemIds.length > 0) {
                    e.dataTransfer.setData('text/vfs-item-ids', draggedItemIds.join(','));
                    e.dataTransfer.effectAllowed = 'move';
                } else {
                    e.preventDefault();
                }
            });

            newIcon.addEventListener('click', (e) => {
                const desktopIcons = Array.from(document.querySelectorAll('.desktop-icon'));
                const clickedIcon = e.currentTarget;
                const clickedIndex = desktopIcons.indexOf(clickedIcon);

                const isCtrlOrMeta = e.ctrlKey || e.metaKey;
                const isShift = e.shiftKey;

                if (isShift && lastSelectedDesktopIcon) {
                    const lastIndex = desktopIcons.indexOf(lastSelectedDesktopIcon);
                    const start = Math.min(clickedIndex, lastIndex);
                    const end = Math.max(clickedIndex, lastIndex);
                    
                    if (!isCtrlOrMeta) {
                        desktopIcons.forEach(icon => icon.classList.remove('selected'));
                    }

                    for (let i = start; i <= end; i++) {
                        desktopIcons[i].classList.add('selected');
                    }
                } else if (isCtrlOrMeta) {
                    clickedIcon.classList.toggle('selected');
                } else {
                    desktopIcons.forEach(icon => {
                        if (icon !== clickedIcon) icon.classList.remove('selected');
                    });
                    clickedIcon.classList.add('selected');
                }
                
                if (clickedIcon.classList.contains('selected')) {
                    lastSelectedDesktopIcon = clickedIcon;
                } else {
                    const selectedIcons = document.querySelectorAll('.desktop-icon.selected');
                    lastSelectedDesktopIcon = selectedIcons.length > 0 ? selectedIcons[selectedIcons.length - 1] : null;
                }
                
                contextMenuTargetVFSId = clickedIcon.dataset.itemId || null;
                if(startMenu) startMenu.style.display = 'none';
                if(desktopContextMenu) desktopContextMenu.style.display = 'none';
            });

            newIcon.addEventListener('contextmenu', (e) => handleDesktopContextMenu(e));

            // Add specific logic for the Trash Bin icon
            if (newIcon.dataset.appId === 'trashBin') {
                newIcon.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                newIcon.addEventListener('drop', handleItemDropOnTrash);
            }
        });
    }
    function handleDesktopIconDblClick(iconElement) {
        const itemType = iconElement.dataset.itemType; const appId = iconElement.dataset.appId;
        const itemId = iconElement.dataset.itemId; const vfsPathId = iconElement.dataset.vfsPathId;
        if (itemType === 'app') {
            if (appId === 'webBrowserLauncher') { openNewBrowserWindow(); }
            else if (appId === 'fileExplorerWindow') { openWindow(appId, { vfsPathId: vfsPathId || 'root' }); }
            else if (appId === 'trashBin') { openWindow('fileExplorerWindow', { vfsPathId: TRASH_VFS_ID }); }
            else { openWindow(appId); }
        } else if (itemType === 'file') {
            const fileEntry = getVFSEntry(itemId);
            if (fileEntry) {
                if (fileEntry.mimeType === 'text/html' || fileEntry.name.endsWith('.html') || fileEntry.name.endsWith('.htm')) {
                    openNewBrowserWindow(null, fileEntry.id);
                } else {
                    openWindow('textEditorWindow', { fileId: fileEntry.id });
                }
            }
        } else if (itemType === 'folder') { openWindow('fileExplorerWindow', { vfsPathId: itemId }); }
    }
    function openTextEditorWindow(options = {}) {
        const windowEl = document.getElementById('textEditorWindow');
        if (!windowEl || !textEditor_contentArea || !textEditor_status || !textEditor_currentFileName) return;
        currentTextEditorFileId = null; textEditor_contentArea.value = '';
        textEditor_status.textContent = "Status: Idle."; textEditor_currentFileName.textContent = "Untitled";
        const titleBarText = windowEl.querySelector('.title-bar-text');
        if (options.fileId) {
            const fileEntry = getVFSEntry(options.fileId);
            if (fileEntry && fileEntry.type === 'file') {
                currentTextEditorFileId = fileEntry.id; textEditor_contentArea.value = fileEntry.content || '';
                textEditor_status.textContent = `Status: Opened ${fileEntry.name}.`; textEditor_currentFileName.textContent = fileEntry.name;
                if (titleBarText) titleBarText.textContent = `🗒️ ${fileEntry.name} - Text Editor`;
            } else { textEditor_status.textContent = "Error: File not found or invalid."; if (titleBarText) titleBarText.textContent = `🗒️ Text Editor`; }
        } else { if (titleBarText) titleBarText.textContent = `🗒️ Text Editor`; }
    }


    function openImageToCodeWindow() {
        // Placeholder for image to code window initialization
        if (!imageToCode_preview || !imageToCode_pasteInstructions || !imageToCode_status) return;
        imageToCode_preview.src = '';
        imageToCode_preview.style.display = 'none';
        imageToCode_pasteInstructions.style.display = 'block';
        imageToCode_generatedCode.value = '';
        imageToCode_prompt.value = '';
        imageToCode_status.textContent = 'Status: Ready.';
        imageToCode_lastPastedFile = null;
        imageToCode_generateButton.disabled = true;
    }
    if (textEditor_saveButton) {
        textEditor_saveButton.addEventListener('click', () => {
            if (!textEditor_contentArea || !textEditor_status) return; const content = textEditor_contentArea.value;
            if (currentTextEditorFileId) {
                const updatedFile = updateVFSEntry(currentTextEditorFileId, { content: content });
                if (updatedFile) { textEditor_status.textContent = `Status: File '${updatedFile.name}' saved.`; logK8osActivity("Text Editor", `Saved file: ${updatedFile.name}`); }
                else { textEditor_status.textContent = "Error: Could not save file."; }
            } else {
                let fileName = prompt("Enter file name (e.g., mydoc.txt):", "untitled.txt");
                if (fileName) {
                    const defaultParentId = currentFEVfsPathId && currentFEVfsPathId !== 'root' ? currentFEVfsPathId : (SPARKY_CREATIONS_VFS_ID || 'root');
                    const newFile = createVFSEntry({ type: 'file', name: fileName, mimeType: (fileName.endsWith('.html') || fileName.endsWith('.htm')) ? 'text/html' : 'text/plain', content: content, parentId: defaultParentId });
                    currentTextEditorFileId = newFile.id; textEditor_currentFileName.textContent = newFile.name;
                    const titleBarText = document.getElementById('textEditorWindow').querySelector('.title-bar-text');
                    if (titleBarText) titleBarText.textContent = `🗒️ ${newFile.name} - Text Editor`;
                    const parentFolder = getVFSEntry(newFile.parentId);
                    textEditor_status.textContent = `Status: File '${newFile.name}' saved to "${parentFolder ? parentFolder.name : 'Files (Root)'}".`;

                    if(newFile.parentId === 'root' && newFile.name !== SPARKY_CREATIONS_FOLDER_NAME) renderDesktopVFSIcons();
                    if(fe_fileListElement && newFile.parentId === currentFEVfsPathId) renderVFSFileList(currentFEVfsPathId);
                    logK8osActivity("Text Editor", `Saved new file: ${newFile.name}`);
                }
            }
        });
    }
    if (desktopElement) {
        desktopElement.addEventListener('dragover', (event) => {
            event.preventDefault();
            if (event.dataTransfer.types.includes('text/vfs-item-id')) {
                event.dataTransfer.dropEffect = 'move';
            } else {
                event.dataTransfer.dropEffect = 'copy';
            }
        });

        desktopElement.addEventListener('drop', (event) => {
            event.preventDefault();
            const vfsItemId = event.dataTransfer.getData('text/vfs-item-id');

            if (vfsItemId) {
                // This is a VFS item being moved
                const item = getVFSEntry(vfsItemId);
                if (item && item.parentId !== 'root') {
                    updateVFSEntry(vfsItemId, { parentId: 'root' });
                    renderDesktopVFSIcons(); // Refresh desktop to show new icon
                    // Refresh file explorer if it's open and showing the old parent folder
                    const fileExplorerWindow = document.getElementById('fileExplorerWindow');
                    if(fileExplorerWindow && fileExplorerWindow.style.display === 'flex' && currentFEVfsPathId === item.parentId) {
                        renderVFSFileList(currentFEVfsPathId);
                    }
                    logK8osActivity("VFS", `Moved '${item.name}' to desktop.`);
                }
            } else {
                // This is an external file drop
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    for (const file of files) {
                        if (file.type.startsWith('text/') || file.type === '' || file.type === 'application/octet-stream' || file.type.endsWith('json') || file.type.endsWith('javascript') || file.type.endsWith('xml') || file.type.endsWith('csv') || file.type.startsWith('image/svg+xml') || file.type.endsWith('html') || file.type.endsWith('htm')) {
                            const reader = new FileReader();
                            reader.onload = (e) => { createVFSEntry({ type: 'file', name: file.name, mimeType: file.type || 'text/plain', content: e.target.result, parentId: 'root' }); renderDesktopVFSIcons(); logK8osActivity("Desktop", `Dropped file: ${file.name}`); };
                            reader.onerror = (e) => { console.error("Error reading dropped file:", file.name, e); alert(`Error reading file: ${file.name}`); };
                            reader.readAsText(file);
                        } else { alert(`File type '${file.type}' not supported for Text Editor/Browser via drop. Only text-based and HTML/SVG files can be dropped for now.`); logK8osActivity("Desktop", `Dropped unsupported file: ${file.name} (${file.type})`); }
                    }
                }
            }
        });
        desktopElement.addEventListener('contextmenu', handleDesktopContextMenu);
    }
    let currentFEVfsPathId = 'root';
    let fe_currentSort = { key: 'name', dir: 'asc' };

    function initFileExplorerAppForVFS(options = {}) {
        lastSelectedFileExplorerRow = null; // Reset selection when changing folder
        currentFEVfsPathId = options.vfsPathId || 'root';
        if (!fe_folderNameDisplayElement || !fe_searchInput || !fe_statusElement) { console.error("File Explorer UI missing for VFS!"); return; }
        
        const currentFolder = getVFSEntry(currentFEVfsPathId);
        fe_folderNameDisplayElement.textContent = `Folder: ${currentFolder ? getVFSPathString(currentFEVfsPathId) : 'Unknown'}`;
        fe_searchInput.value = '';
        fe_searchInput.oninput = () => renderVFSFileList(currentFEVfsPathId, fe_searchInput.value.toLowerCase().trim());

        // Add sorting and selection-clearing event listeners to headers (only once per window open)
        const fileExplorerWindow = document.getElementById('fileExplorerWindow');
        if (!fileExplorerWindow.dataset.sortListenersAdded) {
             fileExplorerWindow.querySelectorAll('.fe-sortable-header').forEach(header => {
                header.addEventListener('click', () => {
                    const sortKey = header.dataset.sortKey;
                    if (fe_currentSort.key === sortKey) {
                        fe_currentSort.dir = fe_currentSort.dir === 'asc' ? 'desc' : 'asc';
                    } else {
                        fe_currentSort.key = sortKey;
                        fe_currentSort.dir = 'asc';
                    }
                    renderVFSFileList(currentFEVfsPathId, fe_searchInput.value.toLowerCase().trim());
                });
            });

            const fe_fileListContainer = document.getElementById('fe_fileListContainer');
            if (fe_fileListContainer) {
                fe_fileListContainer.addEventListener('click', (e) => {
                    // If the click is on the container itself (or the table, but not a row), clear selection.
                    if (!e.target.closest('tr[data-item-id]')) {
                        document.querySelectorAll('#fe_fileList tr.selected').forEach(r => r.classList.remove('selected'));
                        lastSelectedFileExplorerRow = null;
                    }
                });
            }

            fileExplorerWindow.dataset.sortListenersAdded = 'true';
        }

        renderVFSFileList(currentFEVfsPathId);
    }

    function renderVFSFileList(parentId, searchTerm = '') {
        if (!fe_fileListElement || !fe_statusElement) return;

        // Update header visuals
        document.querySelectorAll('#fileExplorerWindow .fe-sortable-header').forEach(h => {
            let headerText = h.dataset.sortKey.charAt(0).toUpperCase() + h.dataset.sortKey.slice(1);
            if (h.dataset.sortKey === fe_currentSort.key) {
                headerText += fe_currentSort.dir === 'asc' ? ' &#x25B2;' : ' &#x25BC;';
                h.classList.add('active-sort');
            } else {
                h.classList.remove('active-sort');
            }
            h.innerHTML = headerText.replace('Modified', 'Date Modified');
        });

        let items = getVFSChildren(parentId, fe_currentSort.key, fe_currentSort.dir);
        if (searchTerm) {
            items = items.filter(item => item.name.toLowerCase().includes(searchTerm));
        }

        fe_fileListElement.innerHTML = ''; // Clear the table body

        // "Up" directory row
        if (parentId !== 'root') {
            const parentItem = getVFSEntry(parentId);
            if (parentItem && parentItem.parentId !== undefined) {
                const row = fe_fileListElement.insertRow();
                row.dataset.itemId = parentItem.parentId;
                row.dataset.itemType = 'folder';
                row.style.cursor = 'pointer';
                row.addEventListener('dblclick', () => { initFileExplorerAppForVFS({ vfsPathId: parentItem.parentId }); });

                const nameCell = row.insertCell();
                nameCell.innerHTML = `<span class="fe-item-icon">⤴️</span>..`;
                row.insertCell().textContent = 'Folder';
                row.insertCell();
            }
        }
        
        if (items.length === 0 && fe_fileListElement.rows.length === 0) {
            const row = fe_fileListElement.insertRow();
            const cell = row.insertCell();
            cell.colSpan = 3;
            cell.textContent = searchTerm ? 'No matches found.' : 'This folder is empty.';
            cell.style.textAlign = 'center';
            cell.style.padding = '10px';
        }

        items.forEach(item => {
            const row = fe_fileListElement.insertRow();
            row.dataset.itemId = item.id;
            row.dataset.itemType = item.type;
            row.draggable = true;
            row.style.cursor = 'pointer';

            row.addEventListener('dragstart', (e) => {
                const selectedRows = fe_fileListElement.querySelectorAll('tr.selected[data-item-id]');
                let draggedItemIds = [];

                if (selectedRows.length > 0 && row.classList.contains('selected')) {
                    selectedRows.forEach(r => {
                        draggedItemIds.push(r.dataset.itemId);
                    });
                } else {
                    draggedItemIds.push(item.id);
                }

                if (draggedItemIds.length > 0) {
                    e.dataTransfer.setData('text/vfs-item-ids', draggedItemIds.join(','));
                    e.dataTransfer.effectAllowed = 'move';
                } else {
                    e.preventDefault();
                }
            });

            // Mobile long-press for selection
            let longPressTimer;
            let isLongPress = false;
            row.addEventListener('touchstart', (e) => {
                isLongPress = false;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    // On long press, we toggle selection. This is the primary way to enter multi-select on mobile.
                    row.classList.toggle('selected');
                    if (navigator.vibrate) { navigator.vibrate(50); } // Haptic feedback
                    
                    // Update the last selected row, which is important for subsequent shift-clicks (on devices with both touch and keyboard)
                    const selectedRows = fe_fileListElement.querySelectorAll('tr.selected');
                    lastSelectedFileExplorerRow = selectedRows.length > 0 ? selectedRows[selectedRows.length - 1] : null;
                }, 500);
            });

            row.addEventListener('touchend', (e) => {
                clearTimeout(longPressTimer);
                if (isLongPress) {
                    e.preventDefault(); // Prevent the click event from firing after a long press to avoid double-toggling selection
                }
            });

            row.addEventListener('touchmove', (e) => {
                // If the user starts scrolling, it's not a long press
                clearTimeout(longPressTimer);
            });
            
            row.addEventListener('click', (e) => {
                const fileRows = Array.from(fe_fileListElement.querySelectorAll('tr[data-item-id]'));
                const clickedRow = e.currentTarget;
                const clickedIndex = fileRows.indexOf(clickedRow);
                const isCtrlOrMeta = e.ctrlKey || e.metaKey;
                const isShift = e.shiftKey;

                if (isShift && lastSelectedFileExplorerRow) {
                    const lastIndex = fileRows.indexOf(lastSelectedFileExplorerRow);
                    const start = Math.min(clickedIndex, lastIndex);
                    const end = Math.max(clickedIndex, lastIndex);
                    if (!isCtrlOrMeta) {
                        fileRows.forEach(r => r.classList.remove('selected'));
                    }
                    for (let i = start; i <= end; i++) {
                        fileRows[i].classList.add('selected');
                    }
                } else if (isCtrlOrMeta) {
                    clickedRow.classList.toggle('selected');
                } else {
                    document.querySelectorAll('#fe_fileList tr.selected').forEach(r => r.classList.remove('selected'));
                    clickedRow.classList.add('selected');
                }

                if (clickedRow.classList.contains('selected')) {
                    lastSelectedFileExplorerRow = clickedRow;
                } else {
                    const selectedRows = fe_fileListElement.querySelectorAll('tr.selected');
                    lastSelectedFileExplorerRow = selectedRows.length > 0 ? selectedRows[selectedRows.length - 1] : null;
                }
            });

            row.addEventListener('dblclick', () => {
                if (item.type === 'folder') { initFileExplorerAppForVFS({ vfsPathId: item.id }); }
                else if (item.type === 'file') {
                    if (item.mimeType === 'text/html' || item.name.endsWith('.html') || item.name.endsWith('.htm')) {
                        openNewBrowserWindow(null, item.id);
                    } else {
                        openWindow('textEditorWindow', { fileId: item.id });
                    }
                }
            });
            row.addEventListener('contextmenu', (e) => handleDesktopContextMenu(e, item.id));
            
            if (item.type === 'folder') {
                 row.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; row.style.backgroundColor = '#E0E0E0'; });
                 row.addEventListener('dragleave', () => { row.style.backgroundColor = ''; });
                 row.addEventListener('drop', (e) => {
                    e.preventDefault(); e.stopPropagation(); row.style.backgroundColor = '';
                    const vfsItemIds = (e.dataTransfer.getData('text/vfs-item-ids') || "").split(',').filter(id => id);
                    const targetFolderId = item.id;
                    
                    if (vfsItemIds.length > 0 && targetFolderId) {
                        let itemsMoved = false;
                        vfsItemIds.forEach(draggedItemId => {
                            // Prevent dropping a folder into itself or its own children
                            if (draggedItemId && draggedItemId !== targetFolderId && !isAncestor(draggedItemId, targetFolderId)) {
                                const draggedItem = getVFSEntry(draggedItemId);
                                if(draggedItem && draggedItem.parentId !== targetFolderId) {
                                    updateVFSEntry(draggedItemId, { parentId: targetFolderId });
                                    logK8osActivity("VFS", `Moved '${draggedItem.name}' to '${item.name}'.`);
                                    itemsMoved = true;
                                }
                            }
                        });

                        if (itemsMoved) {
                            renderDesktopVFSIcons();
                            renderVFSFileList(currentFEVfsPathId);
                        }
                    }
                });
            }

            const nameCell = row.insertCell();
            const icon = item.type === 'file' ? (item.name.endsWith('.html') || item.name.endsWith('.htm') ? '🌐' : '📄') : '📁';
            nameCell.innerHTML = `<span class="fe-item-icon">${icon}</span>${item.name}`;

            const typeCell = row.insertCell();
            typeCell.textContent = item.type === 'folder' ? 'Folder' : (item.mimeType ? item.mimeType.split('/')[1] : 'File');

            const modifiedCell = row.insertCell();
            modifiedCell.textContent = new Date(item.modified).toLocaleString();
        });

        fe_statusElement.textContent = `Status: ${items.length} item(s).`;
    }

    async function downloadVFSEntryAsZip(itemId) {
        if (typeof JSZip === 'undefined') {
            alert("JSZip library not loaded. Cannot create ZIP.");
            console.error("JSZip not found.");
            return;
        }

        const itemToZip = getVFSEntry(itemId);
        const zip = new JSZip();
        let zipFileName = "download.zip";

        const feStatusOriginal = fe_statusElement ? fe_statusElement.textContent : "";
        const updateFEStatus = (msg) => { if (fe_statusElement) fe_statusElement.textContent = `Status: ${msg}`; }

        updateFEStatus("Preparing ZIP...");

        try {
            if (itemId === 'root' || (itemToZip && itemToZip.type === 'folder')) {
                zipFileName = (itemToZip && itemId !== 'root' ? itemToZip.name : 'k8os_All_Files') + '.zip';
                updateFEStatus(`Zipping ${zipFileName}...`);

                async function addFolderToZip(folderId, currentZipFolder) {
                    const children = getVFSChildren(folderId);
                    for (const child of children) {
                        if (child.type === 'file') {
                            currentZipFolder.file(child.name, child.content || "", {
                                date: new Date(child.modified || Date.now())
                            });
                        } else if (child.type === 'folder') {
                           await addFolderToZip(child.id, currentZipFolder.folder(child.name));
                        }
                    }
                }
                 if (itemId === 'root') {
                    const rootChildren = getVFSChildren('root');
                    for (const child of rootChildren) {
                        if (child.id === SPARKY_CREATIONS_VFS_ID) {
                            const sparkyBaseFolder = zip.folder(SPARKY_CREATIONS_FOLDER_NAME);
                            await addFolderToZip(SPARKY_CREATIONS_VFS_ID, sparkyBaseFolder);
                        } else if (child.type === 'file') {
                            zip.file(child.name, child.content || "", { date: new Date(child.modified || Date.now()) });
                        } else if (child.type === 'folder') {
                            if (child.id !== SPARKY_CREATIONS_VFS_ID) {
                                await addFolderToZip(child.id, zip.folder(child.name));
                            }
                        }
                    }
                    if (!rootChildren.find(c => c.id === SPARKY_CREATIONS_VFS_ID) && SPARKY_CREATIONS_VFS_ID && getVFSEntry(SPARKY_CREATIONS_VFS_ID)) {
                         const sparkyBaseFolder = zip.folder(SPARKY_CREATIONS_FOLDER_NAME);
                         await addFolderToZip(SPARKY_CREATIONS_VFS_ID, sparkyBaseFolder);
                    }

                } else {
                    await addFolderToZip(itemId, zip);
                }


            } else if (itemToZip && itemToZip.type === 'file') {
                downloadVFSEntry(itemId);
                updateFEStatus(feStatusOriginal);
                return;
            } else {
                alert("Cannot ZIP this item type or item not found.");
                updateFEStatus(feStatusOriginal);
                return;
            }

            if (Object.keys(zip.files).length === 0) {
                alert("No files to add to ZIP (folder might be empty).");
                updateFEStatus(feStatusOriginal);
                return;
            }

            updateFEStatus("Generating ZIP file...");
            const content = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
            downloadFile(content, zipFileName, "application/zip");
            logK8osActivity("File System", `Downloaded ZIP: ${zipFileName}`);
            updateFEStatus("ZIP downloaded.");

        } catch (error) {
            console.error("Error creating ZIP:", error);
            alert(`Error creating ZIP: ${error.message}`);
            updateFEStatus(`ZIP Error: ${error.message.substring(0, 50)}`);
        } finally {
             setTimeout(() => { if (fe_statusElement && fe_statusElement.textContent.startsWith("Status: ZIP")) updateFEStatus(feStatusOriginal); }, 3000);
        }
    }

    function getStoredOrDefault(key, defaultValue) { return localStorage.getItem(key) || defaultValue; }
    function getCurrentGeminiModel() { return getStoredOrDefault('k8os_globalGeminiAiModel', DEFAULT_GEMINI_AI_MODEL); }
    function getCurrentGroqModel() { return getStoredOrDefault('k8os_globalGroqAiModel', DEFAULT_GROQ_AI_MODEL); }
    function getCurrentOpenAiModel() { return getStoredOrDefault('k8os_globalOpenAiModel', DEFAULT_OPENAI_MODEL); }
    function getCurrentGroqMaxTokens() { return parseInt(getStoredOrDefault('k8os_globalGroqMaxTokens', DEFAULT_GROQ_MAX_TOKENS.toString()), 10); }
    function getCurrentOpenRouterModel() { return getStoredOrDefault('k8os_globalOpenRouterAiModel', DEFAULT_OPENROUTER_AI_MODEL); }
    function getCurrentXaiModel() { return getStoredOrDefault('k8os_globalXaiModel', DEFAULT_XAI_MODEL); }
    function getCurrentOpenRouterHttpReferer() { return getStoredOrDefault('k8os_globalOpenRouterHttpReferer', ''); }
    function getCurrentDeepSeekModel() { return getStoredOrDefault('k8os_globalDeepSeekAiModel', DEFAULT_DEEPSEEK_CHAT_MODEL); }
    function getCurrentDeepSeekMaxTokens() { return parseInt(getStoredOrDefault('k8os_globalDeepSeekMaxTokens', DEFAULT_DEEPSEEK_MAX_TOKENS.toString()), 10); }
    function getCurrentHfModelId() { return getStoredOrDefault('k8os_globalHfModelId', DEFAULT_HF_MODEL_ID); }
    function getCurrentTransformersJsModelId() { return getStoredOrDefault('k8os_globalTransformersJsModelId', DEFAULT_TRANSFORMERSJS_MODEL_ID); }
    function getCurrentCustomEndpointUrl() { return getStoredOrDefault('k8os_globalCustomEndpointUrl', ''); }
    function getCurrentCustomModelId() { return getStoredOrDefault('k8os_globalCustomModelId', ''); }

    function getAppInstruction(appKey, defaultInstruction) { return getStoredOrDefault(`k8os_instr_${appKey}`, defaultInstruction); }

    function loadApiKey() {
        selectedApiProvider = getStoredOrDefault('k8os_apiProvider', 'gemini');
        window.GLOBAL_GEMINI_API_KEY = localStorage.getItem('k8os_GlobalGeminiApiKey');
        window.GLOBAL_GROQ_API_KEY = localStorage.getItem('k8os_GlobalGroqApiKey');
        window.GLOBAL_OPENAI_API_KEY = localStorage.getItem('k8os_GlobalOpenAIApiKey');
        window.GLOBAL_OPENROUTER_API_KEY = localStorage.getItem('k8os_GlobalOpenRouterApiKey');
        window.GLOBAL_XAI_API_KEY = localStorage.getItem('k8os_GlobalXaiApiKey');
        window.GLOBAL_DEEPSEEK_API_KEY = localStorage.getItem('k8os_GlobalDeepSeekApiKey');
        window.GLOBAL_HF_TOKEN = localStorage.getItem('k8os_GlobalHfToken');
        window.GLOBAL_TRANSFORMERSJS_MODEL_ID = getCurrentTransformersJsModelId();
        window.GLOBAL_CUSTOM_API_KEY = localStorage.getItem('k8os_GlobalCustomApiKey');


        const initialBgColor = localStorage.getItem('k8os_desktopBgColor') || DEFAULT_BG_COLOR;
        document.body.style.backgroundColor = initialBgColor;
        const initialBgImageUrl = localStorage.getItem('k8os_desktopBgImageUrl');
        const initialBgImageSize = localStorage.getItem('k8os_desktopBgImageSize') || 'cover';
        const initialBgImageRepeat = localStorage.getItem('k8os_desktopBgImageRepeat') || 'no-repeat';
        if (initialBgImageUrl) { applyCustomImageBackground(initialBgImageUrl, initialBgImageSize, initialBgImageRepeat, false);  }
        if (apiProviderSelect) apiProviderSelect.value = selectedApiProvider;
        updateApiKeyUI(); enableAppButtons(); initAllAiApps(); initSystemSettingsApp();
        loadVFS();
        if (localStorage.getItem('k8os_assistant_enabled') === 'true' &&
            (window.GLOBAL_GEMINI_API_KEY || window.GLOBAL_GROQ_API_KEY || window.GLOBAL_OPENROUTER_API_KEY || window.GLOBAL_DEEPSEEK_API_KEY ||
             window.GLOBAL_HF_TOKEN || window.GLOBAL_TRANSFORMERSJS_MODEL_ID ||
             (window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl())
            )
        ) {
            initAndShowAssistant();
            initSparkyDynamicBehavior();
        }

        if (customSetupLink) {
            customSetupLink.addEventListener('click', (e) => {
                e.preventDefault();
                const content = getCustomSetupGuideContent();
                openSetupGuideModal(content.title, content.instructions, content.codeSnippet);
            });
        }
    }

    function initSparkyAssistEventListeners() {
        function handlePasteForSparkyAssist(e) {
            const assistModal = document.getElementById('textEditorAssistModal');
            if (!assistModal || activeWindow !== assistModal) return;

            const items = (e.clipboardData || window.clipboardData).items;
            let imageFile = null;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf("image") !== -1) {
                    imageFile = items[i].getAsFile();
                    break; // We only handle the first image
                }
            }

            if (imageFile) {
                e.preventDefault(); 
                handleImageAttachment(imageFile, sparkyAssist_imagePreviewContainer, (file) => { sparkyAssist_lastImageFile = file; });
            }
        }
        document.addEventListener('paste', handlePasteForSparkyAssist, false);
    }

    function initSparkyEventListeners() {
        function handlePasteForSparky(e) {
            const inputContainer = document.getElementById('k8osAssistant_inputContainer');
            // Check if the input container is currently visible
            if (!inputContainer || inputContainer.style.display !== 'flex') return;

            const items = (e.clipboardData || window.clipboardData).items;
            let imageFile = null;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf("image") !== -1) {
                    imageFile = items[i].getAsFile();
                    break;
                }
            }

            if (imageFile) {
                e.preventDefault(); 
                handleImageAttachment(imageFile, sparky_imagePreviewContainer, (file) => { sparky_lastImageFile = file; });
            }
        }
        document.addEventListener('paste', handlePasteForSparky, false);
    }
    function updateApiKeyUI() {
        if (!apiKeyInputLabel || !apiKeyInput || !apiKeyStatus || !geminiApiKeyLink || !groqApiKeyLink || !openaiApiKeyLink || !openrouterApiKeyLink || !deepseekApiKeyLink || !hfApiKeyLink || !customSetupLink || !apiKeyInfoText || !apiKeyLinksContainer) return;
        let currentKey = null; let providerName = ''; let keyLabel = 'API Key/Token:';
        apiKeyInput.style.display = 'block'; apiKeyInputLabel.style.display = 'block';
        apiKeyInfoText.style.display = 'none'; apiKeyLinksContainer.style.display = 'block';

        geminiApiKeyLink.style.display = 'none'; groqApiKeyLink.style.display = 'none'; openaiApiKeyLink.style.display = 'none'; openrouterApiKeyLink.style.display = 'none'; xaiApiKeyLink.style.display = 'none'; deepseekApiKeyLink.style.display = 'none'; hfApiKeyLink.style.display = 'none'; customSetupLink.style.display = 'none';
        if (geminiModelSettingsDiv) geminiModelSettingsDiv.style.display = 'none';
        if (groqModelSettingsDiv) groqModelSettingsDiv.style.display = 'none';
        if (openaiModelSettingsDiv) openaiModelSettingsDiv.style.display = 'none';
        if (openrouterModelSettingsDiv) openrouterModelSettingsDiv.style.display = 'none';
        if (xaiModelSettingsDiv) xaiModelSettingsDiv.style.display = 'none';
        if (deepseekModelSettingsDiv) deepseekModelSettingsDiv.style.display = 'none';
        if (hfModelSettingsDiv) hfModelSettingsDiv.style.display = 'none';
        if (transformersjsModelSettingsDiv) transformersjsModelSettingsDiv.style.display = 'none';
        if (customProviderSettingsDiv) customProviderSettingsDiv.style.display = 'none';


        switch (selectedApiProvider) {
            case 'gemini': currentKey = window.GLOBAL_GEMINI_API_KEY; providerName = 'Gemini'; keyLabel = 'Gemini API Key:'; geminiApiKeyLink.style.display = 'inline'; if (geminiModelSettingsDiv) geminiModelSettingsDiv.style.display = 'block'; break;
            case 'groq': currentKey = window.GLOBAL_GROQ_API_KEY; providerName = 'Groq'; keyLabel = 'Groq API Key:'; groqApiKeyLink.style.display = 'inline'; if (groqModelSettingsDiv) groqModelSettingsDiv.style.display = 'block'; break;
            case 'openai': currentKey = window.GLOBAL_OPENAI_API_KEY; providerName = 'OpenAI'; keyLabel = 'OpenAI API Key:'; openaiApiKeyLink.style.display = 'inline'; if (openaiModelSettingsDiv) openaiModelSettingsDiv.style.display = 'block'; break;
            case 'openrouter': currentKey = window.GLOBAL_OPENROUTER_API_KEY; providerName = 'OpenRouter'; keyLabel = 'OpenRouter API Key:'; openrouterApiKeyLink.style.display = 'inline'; if (openrouterModelSettingsDiv) openrouterModelSettingsDiv.style.display = 'block'; break;
            case 'xai': currentKey = window.GLOBAL_XAI_API_KEY; providerName = 'XAI'; keyLabel = 'XAI API Key:'; xaiApiKeyLink.style.display = 'inline'; if (xaiModelSettingsDiv) xaiModelSettingsDiv.style.display = 'block'; break;
            case 'deepseek': currentKey = window.GLOBAL_DEEPSEEK_API_KEY; providerName = 'DeepSeek'; keyLabel = 'DeepSeek API Key:'; deepseekApiKeyLink.style.display = 'inline'; if (deepseekModelSettingsDiv) deepseekModelSettingsDiv.style.display = 'block'; break;
            case 'huggingface': currentKey = window.GLOBAL_HF_TOKEN; providerName = 'Hugging Face'; keyLabel = 'HF API Token:'; hfApiKeyLink.style.display = 'inline'; if (hfModelSettingsDiv) hfModelSettingsDiv.style.display = 'block'; break;
            case 'transformersjs':
                providerName = 'Transformers.js (Local LLM)';
                keyLabel = 'Model ID (Local):';
                apiKeyInput.style.display = 'none';
                apiKeyInputLabel.style.display = 'none';
                apiKeyInfoText.textContent = 'No API Key needed for Transformers.js. Configure Model ID in System Settings.';
                apiKeyInfoText.style.display = 'block';
                apiKeyLinksContainer.style.display = 'none';
                if (transformersjsModelSettingsDiv) transformersjsModelSettingsDiv.style.display = 'block';
                break;
            case 'custom':
                currentKey = window.GLOBAL_CUSTOM_API_KEY; providerName = 'Custom Endpoint'; keyLabel = 'Custom Endpoint API Key:'; customSetupLink.style.display = 'inline';
                apiKeyInfoText.textContent = "Enter your Custom Endpoint's specific API key here. Configure URL in System Settings.";
                apiKeyInfoText.style.display = 'block';
                if (customProviderSettingsDiv) customProviderSettingsDiv.style.display = 'block';
                break;
        }
        apiKeyInputLabel.textContent = keyLabel; apiKeyInput.value = currentKey || '';
        if (selectedApiProvider === 'transformersjs') {
            apiKeyStatus.textContent = `Status: ${providerName} selected. Configure Model ID in System Settings.`;
        } else if (currentKey) {
            apiKeyStatus.textContent = `Status: ${providerName} Key/Token Loaded.`;
        } else {
            apiKeyStatus.textContent = `Status: No ${providerName} key/token set.`;
        }
    }
    if (apiProviderSelect) { apiProviderSelect.addEventListener('change', (e) => { selectedApiProvider = e.target.value; localStorage.setItem('k8os_apiProvider', selectedApiProvider); updateApiKeyUI(); enableAppButtons(); initAllAiApps(); initSystemSettingsApp(); if (assistantIsVisible) { if (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) { } else if (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) { } else { assistant_gemini_model = null; } } initImageToCodeApp(); }); }
    if (saveApiKeyButton) {
        saveApiKeyButton.addEventListener('click', () => {
            if (selectedApiProvider === 'transformersjs') {
                 apiKeyStatus.textContent = `Status: Transformers.js selected. Configure Model ID in System Settings.`;
                 enableAppButtons(); initAllAiApps();
                 if (window.GLOBAL_TRANSFORMERSJS_MODEL_ID) {
                     localStorage.setItem('k8os_assistant_enabled', 'true');
                     initAndShowAssistant(); initSparkyDynamicBehavior();
                     updateAssistantSpeech(`Sparky ready with local LLM!`);
                 }
                 return;
            }

            const key = apiKeyInput.value.trim(); let storageKey = ''; let providerName = ''; let globalVarSetter = () => {};
            switch (selectedApiProvider) {
                case 'gemini': storageKey = 'k8os_GlobalGeminiApiKey'; providerName = 'Gemini'; globalVarSetter = (k) => window.GLOBAL_GEMINI_API_KEY = k; break;
                case 'groq': storageKey = 'k8os_GlobalGroqApiKey'; providerName = 'Groq'; globalVarSetter = (k) => window.GLOBAL_GROQ_API_KEY = k; break;
                case 'openai': storageKey = 'k8os_GlobalOpenAIApiKey'; providerName = 'OpenAI'; globalVarSetter = (k) => window.GLOBAL_OPENAI_API_KEY = k; break;
                case 'openrouter': storageKey = 'k8os_GlobalOpenRouterApiKey'; providerName = 'OpenRouter'; globalVarSetter = (k) => window.GLOBAL_OPENROUTER_API_KEY = k; break;
                case 'xai': storageKey = 'k8os_GlobalXaiApiKey'; providerName = 'XAI'; globalVarSetter = (k) => window.GLOBAL_XAI_API_KEY = k; break;
                case 'deepseek': storageKey = 'k8os_GlobalDeepSeekApiKey'; providerName = 'DeepSeek'; globalVarSetter = (k) => window.GLOBAL_DEEPSEEK_API_KEY = k; break;
                case 'huggingface': storageKey = 'k8os_GlobalHfToken'; providerName = 'Hugging Face'; globalVarSetter = (k) => window.GLOBAL_HF_TOKEN = k; break;
                case 'custom': storageKey = 'k8os_GlobalCustomApiKey'; providerName = 'Custom Endpoint'; globalVarSetter = (k) => window.GLOBAL_CUSTOM_API_KEY = k; break;
            }
            if (key) { globalVarSetter(key); localStorage.setItem(storageKey, key); apiKeyStatus.textContent = `Status: ${providerName} Key/Token Saved!`; enableAppButtons(); initAllAiApps(); localStorage.setItem('k8os_assistant_enabled', 'true'); initAndShowAssistant(); initSparkyDynamicBehavior(); updateAssistantSpeech(`Hi! I'm Sparky. Ready to create!`); }
            else { globalVarSetter(null); localStorage.removeItem(storageKey); apiKeyStatus.textContent = `Status: ${providerName} Key/Token cleared.`; disableAppButtons(); localStorage.removeItem('k8os_assistant_enabled'); hideAssistant(); stopAssistantSummaryTimer(); stopSparkyMovement(); }
        });
    }
    function logK8osActivity(toolName, actionDescription) { const now = Date.now(); k8osActivityLog = k8osActivityLog.filter(entry => now - entry.timestamp < ACTIVITY_LOG_MAX_AGE); k8osActivityLog.push({ timestamp: now, tool: toolName, action: actionDescription.substring(0, 100) }); }
    function startAssistantSummaryTimer() {
        if (assistantSummaryIntervalId) clearInterval(assistantSummaryIntervalId);
        assistantSummaryIntervalId = setInterval(async () => {
            if (!assistantIsVisible || assistantIsThinking || assistantIsProcessingCommand || !localStorage.getItem('k8os_assistant_enabled')) return;
            const threeMinutesAgo = Date.now() - ASSISTANT_SUMMARY_INTERVAL; const recentActivities = k8osActivityLog.filter(entry => entry.timestamp >= threeMinutesAgo);
            if (recentActivities.length === 0) { return; }
            let activitySummaryForPrompt = "User's recent k8OS activities (last 3 mins):\n"; const distinctRecentActivities = []; const activityTexts = new Set();
            for (let i = recentActivities.length - 1; i >= 0 && distinctRecentActivities.length < 4; i--) { const activityText = `In ${recentActivities[i].tool}: ${recentActivities[i].action}`; if (!activityTexts.has(activityText)) { distinctRecentActivities.unshift(activityText); activityTexts.add(activityText); } }
            distinctRecentActivities.forEach(text => { activitySummaryForPrompt += `- ${text}\n`; });
            if (recentActivities.length > distinctRecentActivities.length) { activitySummaryForPrompt += "- And perhaps a few more creative sparks!\n"; }
            const summaryPrompt = `You are Sparky, a friendly k8OS assistant.\n${activitySummaryForPrompt}\nGive a very short, cheerful, and slightly playful summary of their recent activity (1-2 brief sentences, max 20 words). Be encouraging. Don't list items.\nExamples: "Wow, busy bee! Creating cool stuff!", "Looks like you're on a creative roll! Keep it up!", "Lots of awesome things happening! Nice work!"\nOutput ONLY the summary, no extra formatting.`;
            assistantIsThinking = true;
            let summaryComment = "You've been busy!";
            try {
                const statusUpdater = (msg) => { /* Sparky doesn't need detailed model loading status here */ };
                summaryComment = await callCurrentAiProviderForText(summaryPrompt, 30, 0.8, statusUpdater);
            } catch (error) { console.warn(`Assistant summary generation error:`, error); summaryComment = "You're doing great things!"; }  finally { assistantIsThinking = false; }
            summaryComment = summaryComment.replace(/^["']|["']$/g, '').replace(/\n/g, ' ').trim();
            if (summaryComment) updateAssistantSpeech(summaryComment, false);
        }, ASSISTANT_SUMMARY_INTERVAL);
    }
    function stopAssistantSummaryTimer() { if (assistantSummaryIntervalId) { clearInterval(assistantSummaryIntervalId); assistantSummaryIntervalId = null; } }

    function initAndShowAssistant() {
        if (!assistantContainer) {
            assistantContainer = document.getElementById('k8osAssistant');
            assistantSpeechBubble = document.getElementById('k8osAssistant_speechBubble');
            assistantSpeechText = document.getElementById('k8osAssistant_speechText');
            assistantAvatarSVG = document.getElementById('assistantAvatarSVG');
            if (assistantAvatarSVG) { assistantSparkyMouth = assistantAvatarSVG.querySelector('#sparkyMouth'); }

            const assistantInputContainer = document.getElementById('k8osAssistant_inputContainer');
            const assistantCommandInput = document.getElementById('k8osAssistant_commandInput');
            const assistantSendCommandButton = document.getElementById('k8osAssistant_sendCommandButton');

            if (assistantContainer && assistantAvatarSVG && assistantInputContainer && assistantCommandInput && assistantSendCommandButton) {
                 assistantAvatarSVG.addEventListener('click', () => {
                    if (assistantIsProcessingCommand) {
                        updateAssistantSpeech("Working...", true, false);
                        return;
                    }
                    
                    if (assistantWasDragging) {
                        return;
                    }

                    const inputContainer = document.getElementById('k8osAssistant_inputContainer');
                    const isInputVisible = inputContainer.style.display === 'flex';

                    if (isInputVisible) {
                        inputContainer.style.display = 'none';
                    } else {
                        promptSparkyForCommand();
                    }
                });
                initializeAssistantDrag();
            }
        }
        if (assistantContainer) {
            assistantContainer.style.display = 'flex';
            assistantIsVisible = true;
            if (!localStorage.getItem('k8os_assistant_has_greeted')) {
                updateAssistantSpeech("Sparky online!", false, false, true);
                localStorage.setItem('k8os_assistant_has_greeted', 'true');
            }
            startAssistantSummaryTimer();
        }
    }
    function hideAssistant() {
        if (assistantContainer) { assistantContainer.style.display = 'none'; }
        assistantIsVisible = false;
        if (assistantSpeechBubble) assistantSpeechBubble.classList.remove('visible');
        const inputContainer = document.getElementById('k8osAssistant_inputContainer');
        if (inputContainer) inputContainer.style.display = 'none';
        if (assistantSparkyMouth) assistantSparkyMouth.classList.remove('talking');
        clearTimeout(assistantSpeechTimeout);
        stopAssistantSummaryTimer();
        stopSparkyMovement();
    }
    function updateAssistantSpeech(message, autoHide = true, isTemporaryThinkingMessage = false, keepVisibleLonger = false) {
        if (!assistantIsVisible || !assistantSpeechBubble || !assistantSpeechText) return;

        const inputContainer = document.getElementById('k8osAssistant_inputContainer');
        if (inputContainer && inputContainer.style.display === 'flex' && !isTemporaryThinkingMessage) {
            // Don't immediately show speech bubble if input is active, unless it's a thinking message
        } else {
            assistantSpeechText.textContent = message;
            assistantSpeechBubble.classList.add('visible');
        }

        if (assistantSparkyMouth) { if (!isTemporaryThinkingMessage && message.length > 0) { assistantSparkyMouth.classList.add('talking'); } else { assistantSparkyMouth.classList.remove('talking'); } }
        clearTimeout(assistantSpeechTimeout);
        if (autoHide && !isTemporaryThinkingMessage) { assistantSpeechTimeout = setTimeout(() => { assistantSpeechBubble.classList.remove('visible'); if (assistantSparkyMouth) assistantSparkyMouth.classList.remove('talking'); }, keepVisibleLonger ? 10000 : 5000); } // Reduced duration
    }

    function initializeAssistantDrag() {
        if (!assistantContainer || !assistantAvatarSVG) return;

        let isDragging = false;
        let initialLeft, initialTop, startX, startY;
        const normalMouthPath = "M 40 60 Q 50 63 60 60";
        const surprisedMouthPath = "M 45 60 a 5 5 0 1 0 10 0 a 5 5 0 1 0 -10 0";
        const assistantAvatarContainer = document.getElementById('k8osAssistant_avatarContainer');

        const onDragStart = (clientX, clientY) => {
            isDragging = true;
            assistantWasDragging = false; // Reset flag
            stopSparkyMovement();
            if (assistantSparkyMouth) {
                assistantSparkyMouth.classList.remove('talking');
                assistantSparkyMouth.setAttribute('d', surprisedMouthPath);
            }
            if (assistantAvatarContainer) assistantAvatarContainer.style.cursor = 'grabbing';


            initialLeft = assistantContainer.offsetLeft;
            initialTop = assistantContainer.offsetTop;
            startX = clientX;
            startY = clientY;

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd);
        };

        const onDragMove = (clientX, clientY) => {
            if (!isDragging) return;
            assistantWasDragging = true; // It's a drag if the mouse moves
            let newX = initialLeft + (clientX - startX);
            let newY = initialTop + (clientY - startY);
            const desktopRect = desktopElement.getBoundingClientRect();
            const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;

            newX = Math.max(0, Math.min(newX, desktopRect.width - assistantContainer.offsetWidth));
            newY = Math.max(0, Math.min(newY, desktopRect.height - assistantContainer.offsetHeight - taskbarHeight));
            
            assistantContainer.style.left = newX + 'px';
            assistantContainer.style.top = newY + 'px';
        };

        const onDragEnd = () => {
            if (!isDragging) return;
            isDragging = false;

            if (assistantSparkyMouth) {
                assistantSparkyMouth.setAttribute('d', normalMouthPath);
            }
            if (assistantAvatarContainer) assistantAvatarContainer.style.cursor = 'pointer';

            // Update the state variables to the new position
            sparkyPosX = assistantContainer.offsetLeft;
            sparkyPosY = assistantContainer.offsetTop;
            
            startSparkyMovement();

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
        };

        const onMouseDown = (e) => {
            onDragStart(e.clientX, e.clientY);
        };
        const onMouseMove = (e) => onDragMove(e.clientX, e.clientY);
        const onMouseUp = () => onDragEnd();

        const onTouchStart = (e) => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                onDragStart(touch.clientX, touch.clientY);
            }
        };
        const onTouchMove = (e) => {
            if (e.touches.length === 1) {
                e.preventDefault();
                onDragMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        };
        const onTouchEnd = () => onDragEnd();

        assistantAvatarSVG.addEventListener('mousedown', onMouseDown);
        assistantAvatarSVG.addEventListener('touchstart', onTouchStart, { passive: true });
        assistantSpeechBubble.addEventListener('mousedown', onMouseDown);
        assistantSpeechBubble.addEventListener('touchstart', onTouchStart, { passive: true });
    }


    async function ensureTransformersJsPipeline(modelId, progressFn) {
        if (isTransformersJsModelLoading && currentLoadedTransformersJsModel === modelId) {
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => {
                    if (!isTransformersJsModelLoading) {
                        clearInterval(interval);
                        if (transformersJsPipelineInstance && currentLoadedTransformersJsModel === modelId) {
                            resolve(transformersJsPipelineInstance);
                        } else {
                            reject(new Error(`Failed to get pipeline for ${modelId} after waiting.`));
                        }
                    }
                }, 100);
            });
        }
        if (!transformersJsPipelineInstance || currentLoadedTransformersJsModel !== modelId) {
            if(isTransformersJsModelLoading) {
                 throw new Error("Transformers.js: Cannot load a new model while another is already loading.");
            }
            isTransformersJsModelLoading = true;
            currentLoadedTransformersJsModel = modelId;
            try {
                if (progressFn) progressFn({ status: 'loading', file: modelId, progress: 0 });
                transformersJsPipelineInstance = await transformersPipeline('text-generation', modelId, {
                    progress_callback: (progress) => {
                        if (progressFn) progressFn(progress);
                        if (systemSettings_transformersjs_status && document.getElementById('systemSettingsWindow')?.style.display === 'flex') {
                             systemSettings_transformersjs_status.textContent = `Loading ${modelId}: ${Math.round(progress.progress)}% (${progress.file})`;
                        }
                    }
                });
                if (progressFn) progressFn({ status: 'loaded', file: modelId, progress: 100 });
                 if (systemSettings_transformersjs_status && document.getElementById('systemSettingsWindow')?.style.display === 'flex') {
                     systemSettings_transformersjs_status.textContent = `Model ${modelId} loaded.`;
                }
            } catch (error) {
                if (progressFn) progressFn({ status: 'error', file: modelId, message: error.message });
                 if (systemSettings_transformersjs_status && document.getElementById('systemSettingsWindow')?.style.display === 'flex') {
                     systemSettings_transformersjs_status.textContent = `Error loading ${modelId}: ${error.message.substring(0,100)}`;
                }
                transformersJsPipelineInstance = null;
                currentLoadedTransformersJsModel = null;
                throw error;
            } finally {
                isTransformersJsModelLoading = false;
            }
        }
        return transformersJsPipelineInstance;
    }

    async function callTransformersJsApi(promptContent, maxTokens, temperature, statusUpdater = null) {
        const modelId = getCurrentTransformersJsModelId();
        if (!modelId) {
            throw new Error("Transformers.js Model ID not configured in System Settings.");
        }
        const progressFnForPipeline = (progress) => {
            if (statusUpdater) {
                if (progress.status === 'loading') { statusUpdater(`Loading ${progress.file}: ${Math.round(progress.progress)}%`); }
                else if (progress.status === 'loaded') { statusUpdater(`Model ${progress.file} loaded.`); }
                else if (progress.status === 'error') { statusUpdater(`Error loading ${progress.file}: ${progress.message}`); }
                else { statusUpdater(`Loading ${modelId}: ${Math.round(progress.progress || 0)}% (${progress.file || 'model files'})`); }
            }
        };
        try {
            const generator = await ensureTransformersJsPipeline(modelId, progressFnForPipeline);
            if (statusUpdater) statusUpdater(`Generating with ${modelId}...`);
            const generationParams = { max_new_tokens: maxTokens || DEFAULT_TRANSFORMERSJS_MAX_NEW_TOKENS, num_return_sequences: 1, do_sample: true, temperature: temperature, top_k: 50, };
            if (modelId.toLowerCase().includes('coder')) { generationParams.temperature = 0.2; generationParams.top_k = 10; }
            const result = await generator(promptContent, generationParams);
            if (result && Array.isArray(result) && result.length > 0 && result[0].generated_text) { if (statusUpdater) statusUpdater("Generation complete."); return result[0].generated_text; }
            else if (typeof result === 'string') { if (statusUpdater) statusUpdater("Generation complete."); return result; }
            else { if (statusUpdater) statusUpdater("Generation finished, but no text was returned or format unexpected."); console.warn("Unexpected result format from Transformers.js model:", result); throw new Error("No output or unexpected format received from Transformers.js model.");}
        } catch (error) { if (statusUpdater) statusUpdater(`Error: ${error.message.substring(0,150)}`); throw error; }
    }

    async function callCustomEndpointApi(endpointUrl, apiKey, payload) {
        if (!endpointUrl) {
            throw new Error("Custom Endpoint URL not configured.");
        }
        if (!apiKey) {
            throw new Error("Custom Endpoint API Key not set.");
        }

        try {
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            };

            const response = await fetch(endpointUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error("Custom Endpoint API Error Response Text:", errorText);
                let errorMessage = `Custom Endpoint request failed: ${response.status} ${response.statusText}. URL: ${endpointUrl}.`;
                try {
                    const errorData = JSON.parse(errorText);
                    errorMessage += ` ${errorData?.error || errorData?.message || ''}`;
                } catch (e) {
                    errorMessage += ` Response: ${errorText.substring(0, 100)}...`;
                }
                throw new Error(errorMessage);
            }

            const data = await response.json();
            // Expecting a { "response": "text output" } or { "result": "..." } structure
            if (data && typeof data.response !== 'undefined') {
                return data.response;
            } else if (data && typeof data.result !== 'undefined') {
                return data.result;
            } else if (typeof data === 'string'){
                return data;
            } else {
                console.warn("Custom Endpoint API response format unexpected:", data);
                // For flexibility, return the whole JSON object if it's not in the expected format.
                return JSON.stringify(data);
            }
        } catch (error) {
            console.error("Error calling Custom Endpoint API:", error);
            throw error;
        }
    }


const DEFAULT_PIC_TO_CODE_PROMPT = `Based on the provided image, generate a complete, single-file HTML document with inline CSS in a <style> tag.
The output should be a modern, clean, and responsive representation of the user's image.
Use appropriate semantic HTML5 elements.
If the user provides an additional prompt, prioritize their instructions.
User's prompt: "{USER_PROMPT}"
Output ONLY the raw HTML code, starting with <!DOCTYPE html> and ending with </html>. Do not include any explanations, markdown, or comments outside the HTML itself.`;

    function getBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                // Remove the data URI prefix
                const base64String = reader.result.replace(/^data:.+;base64,/, '');
                resolve(base64String);
            };
            reader.onerror = error => reject(error);
        });
    }

    async function callCurrentAiProviderForMultimodal(systemPromptTemplate, userPromptText, imageBase64, imageMimeType, contentParts = null) {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());

        if (!keyAvailable) {
            let errorMsg = `API key for current provider (${selectedApiProvider}) not available.`;
            if (selectedApiProvider === 'custom' && !getCurrentCustomEndpointUrl()) {
                errorMsg = "Custom Endpoint URL not configured in System Settings.";
            } else if (selectedApiProvider === 'custom' && !window.GLOBAL_CUSTOM_API_KEY) {
                errorMsg = "Custom Endpoint API Key not set in API Key Settings.";
            }
            throw new Error(errorMsg);
        }
        
        let finalParts;

        if (contentParts) {
            // Use the pre-constructed parts array (e.g., from Text Editor Assist)
            finalParts = contentParts;
        } else {
            // Construct parts from individual arguments (e.g., from Sparky or Pic-to-Code)
            const fullPrompt = systemPromptTemplate.replace("{USER_PROMPT}", userPromptText || "No additional instructions.");
            finalParts = [
                { text: fullPrompt },
                { inline_data: { data: imageBase64, mime_type: imageMimeType } }
            ];
        }

        if (selectedApiProvider === 'gemini') {
            const model = assistant_gemini_model || (gameGen_main_model || vibe_genAI_internal_model);
            if (!model) {
                initAllAiApps();
                const recheckedModel = assistant_gemini_model || (gameGen_main_model || vibe_genAI_internal_model);
                if (!recheckedModel) throw new Error("Gemini model not initialized.");
            }
            
            const result = await model.generateContent({
                contents: [{ role: "user", parts: finalParts }],
                generationConfig: { temperature: 0.2, maxOutputTokens: 8192 }
            });
            
            let responseText = result.response.text().trim();
            if (responseText.startsWith("```html")) {
                responseText = responseText.substring(7, responseText.lastIndexOf("```")).trim();
            } else if (responseText.startsWith("```")) {
                 responseText = responseText.substring(3, responseText.lastIndexOf("```")).trim();
            }
            return responseText;

        } else if (selectedApiProvider === 'openrouter') {
            // OpenRouter expects a different format for multimodal requests
            const openRouterContent = finalParts.map(part => {
                if (part.text) {
                    return { type: "text", text: part.text };
                }
                if (part.inline_data) {
                    const dataUrl = `data:${part.inline_data.mime_type};base64,${part.inline_data.data}`;
                    return { type: "image_url", image_url: { "url": dataUrl } };
                }
                return null;
            }).filter(p => p);

            const messages = [{ role: "user", content: openRouterContent }];
            return await callOpenRouterApi(messages, 0.2, 4096);

        } else if (selectedApiProvider === 'custom') {
            // This case is for Cloudflare AI compatible endpoints
            const cfContent = finalParts.map(part => {
                if (part.text) {
                    return { type: "text", text: part.text };
                }
                if (part.inline_data) {
                    const dataUrl = `data:${part.inline_data.mime_type};base64,${part.inline_data.data}`;
                    return { type: "image_url", image_url: { url: dataUrl } };
                }
                return null;
            }).filter(p => p);

            // Construct the payload for the custom Cloudflare worker
            const payload = {
                messages: [{ role: "user", content: cfContent }],
                model: getCurrentCustomModelId() || '@cf/meta/llama-4-scout-17b-16e-instruct', // Default to the specified model
                max_tokens: 8192,
                temperature: 0.2,
            };

            return await callCustomEndpointApi(
                getCurrentCustomEndpointUrl(),
                window.GLOBAL_CUSTOM_API_KEY,
                payload
            );
        } else {
            throw new Error(`The selected AI provider '${selectedApiProvider}' does not support this multimodal feature yet.`);
        }
    }

    async function callCurrentAiProviderForText(promptContent, maxTokens = 50, temperature = 0.8, statusUpdater = null) {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openai' && window.GLOBAL_OPENAI_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'xai' && window.GLOBAL_XAI_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());

        if (!keyAvailable) {
            let missingInfo = "API key/Model ID";
            if (selectedApiProvider === 'custom' && !getCurrentCustomEndpointUrl()) missingInfo = "Custom Endpoint URL";
            else if (selectedApiProvider === 'custom' && !window.GLOBAL_CUSTOM_API_KEY) missingInfo = "Custom API Key";
            throw new Error(`${missingInfo} for current provider not available/configured.`);
        }

        if (selectedApiProvider === 'gemini') {
            if (!assistant_gemini_model) {
                const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                assistant_gemini_model = genAI.getGenerativeModel({
                    model: getCurrentGeminiModel(),
                    safetySettings: [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ],
                });
            }
            const result = await assistant_gemini_model.generateContent({
                contents: [{role: "user", parts: [{text: promptContent}]}],
                generationConfig: { temperature: temperature, maxOutputTokens: maxTokens }
            });
            return result.response.text().trim();
        } else if (selectedApiProvider === 'groq') {
            const messages = [{ role: "user", content: promptContent }];
            return await callGroqApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'openai') {
            const messages = [{ role: "user", content: promptContent }];
            return await callOpenAiApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'openrouter') {
            const messages = [{ role: "user", content: promptContent }];
            return await callOpenRouterApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'xai') {
            const messages = [{ role: "user", content: promptContent }];
            return await callXaiApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'deepseek') {
            const messages = [{ role: "user", content: promptContent }];
            return await callDeepSeekApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'huggingface') {
            return await callHuggingFaceApi(getCurrentHfModelId(), { inputs: promptContent, parameters: { max_new_tokens: maxTokens, temperature: temperature } });
        } else if (selectedApiProvider === 'transformersjs') {
            return await callTransformersJsApi(promptContent, maxTokens, temperature, statusUpdater);
        } else if (selectedApiProvider === 'custom') {
             const payload = {
                prompt: promptContent,
                model: getCurrentCustomModelId() || undefined,
                max_tokens: maxTokens || DEFAULT_CUSTOM_MAX_TOKENS,
                temperature: temperature,
            };
            return await callCustomEndpointApi(
                getCurrentCustomEndpointUrl(),
                window.GLOBAL_CUSTOM_API_KEY,
                payload
            );
        }
        return "AI provider not supported for this operation yet.";
    }

    function promptSparkyForCommand() {
        const inputContainer = document.getElementById('k8osAssistant_inputContainer');
        const commandInput = document.getElementById('k8osAssistant_commandInput');
        const sendButton = document.getElementById('k8osAssistant_sendCommandButton');
        const speechBubble = document.getElementById('k8osAssistant_speechBubble');

        if (inputContainer && commandInput && sendButton && speechBubble) {
            speechBubble.classList.remove('visible');
            inputContainer.style.display = 'flex';
            commandInput.value = '';
            commandInput.focus();

            const newSendButton = sendButton.cloneNode(true);
            sendButton.parentNode.replaceChild(newSendButton, sendButton);
            const newCommandInput = commandInput.cloneNode(true);
            commandInput.parentNode.replaceChild(newCommandInput, commandInput);

            const handleSendCommand = () => {
                const userInput = newCommandInput.value.trim();
                inputContainer.style.display = 'none';
                if (userInput) {
                    sparkyCommandHistory.push(userInput);
                    sparkyHistoryIndex = sparkyCommandHistory.length;
                    processSparkyCommand(userInput);
                } else {
                    updateAssistantSpeech("?", true);
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleSendCommand();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (sparkyHistoryIndex > 0) {
                        sparkyHistoryIndex--;
                        newCommandInput.value = sparkyCommandHistory[sparkyHistoryIndex];
                        newCommandInput.setSelectionRange(newCommandInput.value.length, newCommandInput.value.length);
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (sparkyHistoryIndex < sparkyCommandHistory.length - 1) {
                        sparkyHistoryIndex++;
                        newCommandInput.value = sparkyCommandHistory[sparkyHistoryIndex];
                        newCommandInput.setSelectionRange(newCommandInput.value.length, newCommandInput.value.length);
                    } else {
                        sparkyHistoryIndex = sparkyCommandHistory.length;
                        newCommandInput.value = '';
                    }
                }
            };

            newSendButton.addEventListener('click', handleSendCommand);
            newCommandInput.addEventListener('keydown', handleKeyDown);
        } else {
            console.error("Sparky input UI elements not found!");
            const userInput = prompt("Sparky: What's up?");
            if (userInput && userInput.trim() !== "") processSparkyCommand(userInput.trim());
        }
    }

    function createSparkyHtmlPopupWindowHTML(instanceId, initialTitle = "✨ Sparky's Creation") {
        return `
            <div class="title-bar">
                <span class="title-bar-text" id="${instanceId}_titleBarText">${initialTitle}</span>
                <div class="title-bar-controls">
                    <button class="minimize-button" title="Minimize">0</button>
                    <button class="fullscreen-button" title="Toggle Fullscreen">1</button>
                    <button class="close-button" title="Close">r</button>
                </div>
            </div>
            <div class="window-content">
                <iframe id="${instanceId}_iframeContent" class="sparkyHtmlPopupWindow_iframeContent" sandbox="allow-scripts allow-forms allow-popups allow-same-origin"></iframe>
            </div>
            <div id="${instanceId}_status" class="status-bar">Status: Idle</div>
        `;
    }

    async function createSparkyHtmlPopupWindow(htmlContent, userRequest) {
        sparkyHtmlPopupCounter++;
        const instanceId = `sparkyHtmlPopup-${sparkyHtmlPopupCounter}`;
        const windowEl = document.createElement('div');
        windowEl.id = instanceId;
        windowEl.className = 'window sparkyHtmlPopupWindow';
        windowEl.dataset.isPopup = "true"; // Mark as popup to exclude from taskbar

        const randomWidth = Math.floor(Math.random() * 200) + 400;
        const randomHeight = Math.floor(Math.random() * 150) + 300;
        windowEl.style.width = `${randomWidth}px`;
        windowEl.style.height = `${randomHeight}px`;

        const desktopWidth = desktopElement.clientWidth;
        const desktopHeight = desktopElement.clientHeight;
        const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;
        windowEl.style.top = `${Math.random() * (desktopHeight - randomHeight - taskbarHeight - 20) + 10}px`;
        windowEl.style.left = `${Math.random() * (desktopWidth - randomWidth - 20) + 10}px`;

        const title = `✨ Sparky: ${userRequest.substring(0, 25)}${userRequest.length > 25 ? '...' : ''}`;
        windowEl.innerHTML = createSparkyHtmlPopupWindowHTML(instanceId, title);
        desktopElement.appendChild(windowEl);
        initializeWindowBehavior(windowEl);

        const iframe = document.getElementById(`${instanceId}_iframeContent`);
        const status = document.getElementById(`${instanceId}_status`);

        if (iframe && status) {
            if (htmlContent && (htmlContent.toLowerCase().includes("<html") || htmlContent.toLowerCase().includes("<body")) ) {
                iframe.srcdoc = htmlContent;
                status.textContent = "Content loaded.";

                // Save to VFS in Sparky's Creations folder
                const sparkyFolderId = ensureSparkyCreationsFolder();
                const filename = `sparky-${userRequest.substring(0,15).replace(/[^a-z0-9]/gi, '_') || 'creation'}-${sparkyHtmlPopupCounter}.html`;
                createVFSEntry({ type: 'file', name: filename, mimeType: 'text/html', content: htmlContent, parentId: sparkyFolderId });

                if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === sparkyFolderId)) {
                    renderVFSFileList(currentFEVfsPathId); // Refresh FE if viewing root or Sparky's folder
                }
                updateAssistantSpeech(`I've also saved "${filename}" to your "${SPARKY_CREATIONS_FOLDER_NAME}" folder!`, true, false, true);

            } else {
                iframe.srcdoc = `<p style="color:red; padding:10px;">Sorry, I couldn't generate valid HTML for that request.<br>Raw AI output: <pre>${(htmlContent || "None").replace(/</g, "&lt;")}</pre></p>`;
                status.textContent = "Error: Invalid HTML generated.";
            }
        }
        openWindow(instanceId, {}, true); // Pass true for isPopup
        return windowEl;
    }

    // Sparky Command: Helper function for parsing arguments from a command string.
    function parseSparkyArgs(command) {
        const args = {};
        const keys = ["Idea", "Player SVG", "Item SVG", "Music"];
        const regex = new RegExp(`\\b(${keys.join('|')}):`, 'ig');
        const commandPrefix = "sparky, create game";
        let content = command.substring(command.toLowerCase().indexOf(commandPrefix) + commandPrefix.length).trim();

        const firstKeyMatch = content.match(regex);
        if (firstKeyMatch) {
            const firstKeyIndex = firstKeyMatch.index;
            if (firstKeyIndex > 0) {
                args.idea = content.substring(0, firstKeyIndex).trim();
                content = content.substring(firstKeyIndex);
            }
        } else {
            if (content) args.idea = content;
            content = "";
        }

        if (content) {
            const parts = content.split(regex);
            for (let i = 1; i < parts.length; i += 2) {
                let key = parts[i].toLowerCase().trim();
                const value = parts[i+1] ? parts[i+1].trim() : '';
                key = key.replace(/ (\w)/g, (match, p1) => p1.toUpperCase());
                if (value) {
                    args[key] = value;
                }
            }
        }
        return args;
    }

    // Sparky Command: Helper function for a specific 'create game' flow.
    async function processAndDisplayGameCode(gameHtml, gameIdea) {
        const sparkyFolderId = ensureSparkyCreationsFolder();
        const filename = `sparky-game-${gameIdea.substring(0,15).replace(/[^a-z0-9]/gi, '_') || 'creation'}-${Date.now().toString(36)}.html`;
        const newFile = createVFSEntry({ type: 'file', name: filename, mimeType: 'text/html', content: gameHtml, parentId: sparkyFolderId });
        
        if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === sparkyFolderId)) {
             renderVFSFileList(currentFEVfsPathId);
        }
        openNewBrowserWindow(null, newFile.id);
    }
    // Sparky Command Handler: Create Game
    async function handleCreateGameCommand(command, context) {
        try {
            const args = parseSparkyArgs(command);
            const gameIdea = args.idea || "a simple game";
            const playerSvgDesc = args.playerSvg || "player object";
            const itemSvgDesc = args.itemSvg || "item object";
            const musicDesc = args.music || "background music";

            updateAssistantSpeech(`Making game: "${gameIdea.substring(0,20)}..."`, false, false, true);

            const playerSvgCode = await internal_generateSingleSvg(playerSvgDesc, false, context.sparkyStatusUpdater);
            if (!playerSvgCode) { updateAssistantSpeech("Player SVG failed. Stopping.", false, false, true); return; }

            const itemSvgCode = await internal_generateSingleSvg(itemSvgDesc, false, context.sparkyStatusUpdater);
            if (!itemSvgCode) { updateAssistantSpeech("Item SVG failed. Stopping.", false, false, true); return; }

            const soundJsCode = await internal_generateSingleSoundJs(musicDesc, context.sparkyStatusUpdater);
            if (!soundJsCode) { updateAssistantSpeech("Music code failed. Stopping.", false, false, true); return; }

            const gamePlan = {
                game_mechanic: gameIdea,
                svg_assets: [ { description: playerSvgDesc, animated: false }, { description: itemSvgDesc, animated: false } ],
                sound_effects: [ musicDesc ]
            };
            const svgAssetsArray = [playerSvgCode, itemSvgCode];
            const soundJsArray = [soundJsCode];

            const gameHtml = await executeGameGenerationFromPlan(gameIdea, gamePlan, svgAssetsArray, soundJsArray, context.sparkyStatusUpdater);

            if (gameHtml) {
                await processAndDisplayGameCode(gameHtml, gameIdea);
                const wittyComment = getWittyComment('create_game');
                updateAssistantSpeech(`Game ready! (And saved to Sparky's Creations). ${wittyComment}`, false, false, true);
            } else {
                updateAssistantSpeech("Game creation failed.", false, false, true);
            }
        } catch (e) {
            console.error("Error in Sparky 'create game' command:", e);
            updateAssistantSpeech("Error creating game: " + e.message.substring(0,100), false, false, true);
        }
    }

    // Sparky Command Helper: Execute File System Creation
    async function executeFileSystemCreation(userRequest, explicitBaseParentId, statusUpdater) {
        if (explicitBaseParentId !== 'root' && !getVFSEntry(explicitBaseParentId)) {
             updateAssistantSpeech(`Error: Specified base parent folder ID '${explicitBaseParentId}' does not exist. Defaulting to Sparky's Creations folder.`, true, false, true);
             explicitBaseParentId = ensureSparkyCreationsFolder();
        }

        const finalSparkyFileSystemPrompt = DEFAULT_SPARKY_FILESYSTEM_GENERATOR_PROMPT
            .replace("{USER_REQUEST}", userRequest)
            .replace(/{BASE_PARENT_ID}/g, explicitBaseParentId);

        let aiPlanResponseText;
        try {
            aiPlanResponseText = await callCurrentAiProviderForText(finalSparkyFileSystemPrompt, 4000, 0.3, statusUpdater);
            let cleanedJsonString = aiPlanResponseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
            const jsonStart = cleanedJsonString.indexOf('['); const jsonEnd = cleanedJsonString.lastIndexOf(']');
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) { cleanedJsonString = cleanedJsonString.substring(jsonStart, jsonEnd + 1); }

            const planActions = JSON.parse(cleanedJsonString);
            if (Array.isArray(planActions)) {
                const tempIdToVfsIdMap = {};
                tempIdToVfsIdMap[explicitBaseParentId] = explicitBaseParentId;
                if (explicitBaseParentId !== 'root') { tempIdToVfsIdMap['root'] = 'root'; }

                let successCount = 0;
                for (const action of planActions) {
                    if (!action.action || !action.name || !action.parentId || !action.id) {
                        updateAssistantSpeech(`Skipping invalid action in plan: ${JSON.stringify(action).substring(0,50)}...`, true, false, true);
                        continue;
                    }
                    let resolvedActionParentId = action.parentId === "{BASE_PARENT_ID}" ? explicitBaseParentId : action.parentId;
                    const actualParentId = tempIdToVfsIdMap[resolvedActionParentId] || resolvedActionParentId;

                    if (!getVFSEntry(actualParentId) && actualParentId !== 'root') {
                         updateAssistantSpeech(`Error: Parent ID '${actualParentId}' (from AI's '${action.parentId}') for '${action.name}' not found. Skipping.`, true, false, true);
                         continue;
                    }

                    let newEntry;
                    if (action.action === "create_folder") {
                        newEntry = createVFSEntry({ type: 'folder', name: action.name, parentId: actualParentId });
                    } else if (action.action === "create_file") {
                        newEntry = createVFSEntry({
                            type: 'file',
                            name: action.name,
                            parentId: actualParentId,
                            content: action.content || "",
                            mimeType: action.mimeType || "text/plain"
                        });
                    }
                    if (newEntry) {
                        tempIdToVfsIdMap[action.id] = newEntry.id;
                        successCount++;
                    }
                }
                renderDesktopVFSIcons();
                if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === explicitBaseParentId || getVFSChildren(explicitBaseParentId).length > 0)) {
                    renderVFSFileList(currentFEVfsPathId);
                }
                const parentFolder = getVFSEntry(explicitBaseParentId);
                const parentFolderName = parentFolder ? parentFolder.name : (explicitBaseParentId === 'root' ? "Files (Root)" : SPARKY_CREATIONS_FOLDER_NAME);
                const wittyComment = getWittyComment('create_files');
                updateAssistantSpeech(`File system created in "${parentFolderName}"! ${successCount} items processed. ${wittyComment}`, true, false, true);
            } else {
                updateAssistantSpeech("Invalid plan format from AI. Expected a JSON array.", true, false, true);
            }
        } catch (e) {
            console.error("Error processing Sparky file system plan:", e, "Raw AI:", aiPlanResponseText);
            updateAssistantSpeech("Error processing file system plan: " + e.message.substring(0,100), true, false, true);
        }
    }

    // Sparky Command Handlers: File System Variations
    async function handleCreateFileSystemFromContent(command, context) {
        updateAssistantSpeech("Processing editor content for file system structure...", false, true, true);
        const explicitBaseParentId = context.baseParentIdOverride || ensureSparkyCreationsFolder();
        await executeFileSystemCreation(command, explicitBaseParentId, context.sparkyStatusUpdater);
    }

    async function handleCreateFileSystemFromPlan(command, context) {
        updateAssistantSpeech("Creating file system from plan...", false, true, true);
        const planContentMatch = command.match(/plan:\s*([\s\S]+)$/i);
        if (planContentMatch && planContentMatch[1]) {
            const userRequestForAISystemPlan = planContentMatch[1].trim();
            const explicitBaseParentId = context.baseParentIdOverride || ensureSparkyCreationsFolder();
            await executeFileSystemCreation(userRequestForAISystemPlan, explicitBaseParentId, context.sparkyStatusUpdater);
        } else {
            updateAssistantSpeech("File system plan not found or invalid.", true, false, true);
        }
    }

    async function handleCreateFileSystemFromRequest(command, context) {
        updateAssistantSpeech("Interpreting file system request...", false, true, true);
        const userRequestForAISystemPlan = command.substring("sparky, create file system.".length).trim();
        const explicitBaseParentId = context.baseParentIdOverride || ensureSparkyCreationsFolder();
        await executeFileSystemCreation(userRequestForAISystemPlan, explicitBaseParentId, context.sparkyStatusUpdater);
    }

    // Sparky Command Handler: Write HTML
    async function handleWriteHtmlCommand(command, context) {
        try {
            const filenameMatch = command.match(/Filename:\s*([\w.-]+)\s*Content:/i);
            const contentMatch = command.match(/Content:\s*([\s\S]+)$/i);

            if (filenameMatch && contentMatch) {
                const filename = filenameMatch[1].trim();
                const htmlContent = contentMatch[1].trim();
                updateAssistantSpeech(`Creating HTML file "${filename}"...`, false, true, true);

                const sparkyFolderId = ensureSparkyCreationsFolder();
                const newFile = createVFSEntry({ type: 'file', name: filename, mimeType: 'text/html', content: htmlContent, parentId: sparkyFolderId });
                if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === sparkyFolderId)) {
                     renderVFSFileList(currentFEVfsPathId);
                }
                const wittyComment = getWittyComment('create_html');
                updateAssistantSpeech(`Done! Saved "${filename}" to your "${SPARKY_CREATIONS_FOLDER_NAME}" folder. ${wittyComment}`, false, false, true);
            } else {
                updateAssistantSpeech("Usage: Sparky, write html. Filename: page.html. Content: <h1>Hello</h1>", false, false, true);
            }
        } catch(e) {
             console.error("Error in Sparky 'write html' command:", e);
             updateAssistantSpeech("Error making HTML file: " + e.message.substring(0,100), false, false, true);
        }
    }

    // Sparky Command Handler: Default HTML Generation
    async function handleDefaultHtmlGeneration(command, context) {
        updateAssistantSpeech("Let me try to make that into HTML...", false, true, true);
        const htmlPrompt = DEFAULT_SPARKY_HTML_GENERATOR_PROMPT.replace("{USER_REQUEST}", command);
        let generatedHtml = "";
        try {
            generatedHtml = await callCurrentAiProviderForText(htmlPrompt, 4000, 0.7, context.sparkyStatusUpdater);
            if (generatedHtml.startsWith("```html")) generatedHtml = generatedHtml.substring(7).trim();
            else if (generatedHtml.startsWith("```")) generatedHtml = generatedHtml.substring(3).trim();
            if (generatedHtml.endsWith("```")) generatedHtml = generatedHtml.substring(0, generatedHtml.length - 3).trim();

            await createSparkyHtmlPopupWindow(generatedHtml, command);
            const wittyComment = getWittyComment('create_html');
            updateAssistantSpeech(`Here's what I came up with! (And saved to "${SPARKY_CREATIONS_FOLDER_NAME}"). ${wittyComment}`, true, false, true);

        } catch (error) {
            console.error("Sparky generic HTML generation error:", error);
            await createSparkyHtmlPopupWindow(`<p style="color:red;">Sorry, I had trouble generating HTML for that: ${error.message}</p>`, command);
            updateAssistantSpeech("Oops, couldn't make HTML for that.", true, false, true);
        }
    }

    const sparkyCommands = [
        {
            name: 'create file system from content',
            match: (lowerCommand) => lowerCommand.startsWith("sparky, create file system based on editor content"),
            handler: handleCreateFileSystemFromContent
        },
        {
            name: 'create file system from plan',
            match: (lowerCommand) => lowerCommand.startsWith("sparky, create file system. plan:"),
            handler: handleCreateFileSystemFromPlan
        },
        {
            name: 'create file system',
            match: (lowerCommand) => lowerCommand.startsWith("sparky, create file system."),
            handler: handleCreateFileSystemFromRequest
        },
        {
            name: 'create game',
            match: (lowerCommand) => lowerCommand.startsWith("sparky, create game"),
            handler: handleCreateGameCommand
        },
        {
            name: 'write html',
            match: (lowerCommand) => lowerCommand.startsWith("sparky, write html"),
            handler: handleWriteHtmlCommand
        }
    ];

    async function processSparkyCommand(command, baseParentIdOverride = null) {
        logK8osActivity("Sparky Command", command);
        assistantIsProcessingCommand = true;
        const sparkyStatusUpdater = (msg) => updateAssistantSpeech(msg, true, true);
        updateAssistantSpeech("Working on it...", false, true);

        if (sparky_lastImageFile) {
            const imageFile = sparky_lastImageFile;
            // Reset state immediately
            sparky_lastImageFile = null;
            if (sparky_imagePreviewContainer) {
                sparky_imagePreviewContainer.style.display = 'none';
                sparky_imagePreviewContainer.innerHTML = '';
            }

            try {
                const base64Data = await getBase64(imageFile);
                const mimeType = imageFile.type;

                const responseText = await callCurrentAiProviderForMultimodal(
                    DEFAULT_SPARKY_MULTIMODAL_PROMPT,
                    command, // The user's text input
                    base64Data,
                    mimeType
                );

                await createSparkyHtmlPopupWindow(responseText, command);
            } catch (error) {
                console.error("Sparky multimodal command error:", error);
                updateAssistantSpeech(`I had trouble with that image. ${error.message}`, false, false, true);
            } finally {
                assistantIsProcessingCommand = false;
            }
            return; // End execution here for multimodal commands
        }

        const lowerCommand = command.toLowerCase();
        const context = {
            sparkyStatusUpdater: sparkyStatusUpdater,
            baseParentIdOverride: baseParentIdOverride
        };

        const matchedCommand = sparkyCommands.find(cmd => cmd.match(lowerCommand));

        if (matchedCommand) {
            await matchedCommand.handler(command, context);
        } else {
            await handleDefaultHtmlGeneration(command, context);
        }

        assistantIsProcessingCommand = false;
    }

    async function executeGameGenerationFromPlan(userGameIdea, gamePlan, svgAssetsArray, soundJsArray, statusUpdater = null) {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (!keyAvailable) {
            if(statusUpdater) statusUpdater("API Key/Model ID/Endpoint URL missing for game gen.");
            else updateAssistantSpeech("API Key/Model ID/Endpoint URL missing for game gen.", false, false, true);
            return null;
        }

        const finalGamePromptInstruction = getAppInstruction('gameGen_final', DEFAULT_GAMEGEN_FINAL_INSTRUCTION);
        const finalGamePrompt = finalGamePromptInstruction
            .replace("{USER_GAME_IDEA}", userGameIdea)
            .replace("{GAME_PLAN_JSON}", JSON.stringify(gamePlan))
            .replace("{SVG_ASSETS_ARRAY_OF_STRINGS}", JSON.stringify(svgAssetsArray))
            .replace("{SOUND_EFFECTS_JS_ARRAY_OF_STRINGS}", JSON.stringify(soundJsArray));

        let gameHtml;
        try {
             if (selectedApiProvider === 'gemini') {
                if (!gameGen_main_model) { initGameGeneratorApp(); if (!gameGen_main_model) throw new Error("Gemini game model not ready.");}
                const gameCodeResult = await gameGen_main_model.generateContent(finalGamePrompt);
                gameHtml = gameCodeResult.response.text().trim();
             } else if (['groq', 'openrouter', 'deepseek', 'huggingface', 'transformersjs', 'custom'].includes(selectedApiProvider)) {
                 if(statusUpdater) statusUpdater(`Generating final game code with ${selectedApiProvider}...`);
                 gameHtml = await callCurrentAiProviderForText(finalGamePrompt, 8192, 0.7, statusUpdater);
             }
            if (gameHtml && gameHtml.startsWith("```html")) gameHtml = gameHtml.substring(7).trim(); else if (gameHtml && gameHtml.startsWith("```")) gameHtml = gameHtml.substring(3).trim(); if (gameHtml && gameHtml.endsWith("```")) gameHtml = gameHtml.substring(0, gameHtml.length - 3).trim();
            return gameHtml;
        } catch (e) {
            console.error(`Game Generation (from plan) Error (${selectedApiProvider}):`, e);
            const errorMsg = `Game code generation failed: ${e.message.substring(0,100)}`;
            if(statusUpdater) statusUpdater(errorMsg);
            else updateAssistantSpeech(errorMsg, false, false, true);
            return null;
        }
    }

    function enableAppButtons() {
        let keyAvailable = false;
        switch (selectedApiProvider) {
            case 'gemini': keyAvailable = !!window.GLOBAL_GEMINI_API_KEY; break;
            case 'groq': keyAvailable = !!window.GLOBAL_GROQ_API_KEY; break;
            case 'openrouter': keyAvailable = !!window.GLOBAL_OPENROUTER_API_KEY; break;
            case 'xai': keyAvailable = !!window.GLOBAL_XAI_API_KEY; break;
            case 'deepseek': keyAvailable = !!window.GLOBAL_DEEPSEEK_API_KEY; break;
            case 'huggingface': keyAvailable = !!window.GLOBAL_HF_TOKEN; break;
            case 'transformersjs': keyAvailable = !!window.GLOBAL_TRANSFORMERSJS_MODEL_ID; break;
            case 'custom': keyAvailable = !!window.GLOBAL_CUSTOM_API_KEY && !!getCurrentCustomEndpointUrl(); break;
        }
        if (vibe_generateButton) vibe_generateButton.disabled = !keyAvailable;
        if (gameGen_generateButton) gameGen_generateButton.disabled = !keyAvailable;
        if (musicStudio_generateButton) musicStudio_generateButton.disabled = !keyAvailable;
        if (gifCreator_generateButton) gifCreator_generateButton.disabled = !keyAvailable;
        if (textEditor_sparkyAssistButton) textEditor_sparkyAssistButton.disabled = !keyAvailable;
    }

    function disableAppButtons() {
        if (vibe_generateButton) vibe_generateButton.disabled = true;
        if (gameGen_generateButton) gameGen_generateButton.disabled = true;
        if (musicStudio_generateButton) musicStudio_generateButton.disabled = true;
        if (gifCreator_generateButton) gifCreator_generateButton.disabled = true;
        if (textEditor_sparkyAssistButton) textEditor_sparkyAssistButton.disabled = true;
    }

    async function callGroqApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_GROQ_API_KEY) { throw new Error("Groq API Key not set."); }
        const GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions";
        const modelToUse = getCurrentGroqModel(); const maxTokensToUse = maxTokensOverride !== null ? maxTokensOverride : getCurrentGroqMaxTokens();
        try {
            const response = await fetch(GROQ_API_URL, { method: 'POST', headers: { 'Authorization': `Bearer ${window.GLOBAL_GROQ_API_KEY}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ messages: messages, model: modelToUse, temperature: temperature, max_tokens: maxTokensToUse, }) });
            if (!response.ok) { const errorData = await response.json().catch(() => ({})); console.error("Groq API Error Response:", errorData); throw new Error(`Groq API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`); }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) { return data.choices[0].message.content; }
            else { console.warn("Groq API response missing expected content:", data); throw new Error("Groq API response format unexpected."); }
        } catch (error) { console.error("Error calling Groq API:", error); throw error; }
    }

    async function callOpenAiApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_OPENAI_API_KEY) { throw new Error("OpenAI API Key not set."); }
        const OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";
        const modelToUse = getCurrentOpenAiModel();
        
        const body = {
            model: modelToUse,
            messages: messages,
            temperature: temperature,
        };
        if (maxTokensOverride !== null) {
            body.max_tokens = maxTokensOverride;
        }

        try {
            const response = await fetch(OPENAI_API_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${window.GLOBAL_OPENAI_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("OpenAI API Error Response:", errorData);
                throw new Error(`OpenAI API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`);
            }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            } else {
                console.warn("OpenAI API response missing expected content:", data);
                throw new Error("OpenAI API response format unexpected.");
            }
        } catch (error) {
            console.error("Error calling OpenAI API:", error);
            throw error;
        }
    }

    async function callXaiApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_XAI_API_KEY) { throw new Error("XAI API Key not set."); }
        const XAI_API_URL = "https://api.x.ai/v1/chat/completions";
        const modelToUse = getCurrentXaiModel();
        try {
            const response = await fetch(XAI_API_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${window.GLOBAL_XAI_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: modelToUse,
                    messages: messages,
                    temperature: temperature,
                    max_tokens: maxTokensOverride,
                })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("XAI API Error Response:", errorData);
                throw new Error(`XAI API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`);
            }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            } else {
                console.warn("XAI API response missing expected content:", data);
                throw new Error("XAI API response format unexpected.");
            }
        } catch (error) {
            console.error("Error calling XAI API:", error);
            throw error;
        }
    }

    async function callOpenRouterApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_OPENROUTER_API_KEY) { throw new Error("OpenRouter API Key not set."); }
        const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";
        const modelToUse = getCurrentOpenRouterModel();
        const httpReferer = getCurrentOpenRouterHttpReferer();
        const headers = {
            'Authorization': `Bearer ${window.GLOBAL_OPENROUTER_API_KEY}`,
            'Content-Type': 'application/json'
        };
        if (httpReferer) {
            headers['HTTP-Referer'] = httpReferer;
        }
        try {
            const body = {
                model: modelToUse,
                messages: messages,
                temperature: temperature,
            };
            if (maxTokensOverride !== null) {
                body.max_tokens = maxTokensOverride;
            }
            const response = await fetch(OPENROUTER_API_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(body)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("OpenRouter API Error Response:", errorData);
                throw new Error(`OpenRouter API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`);
            }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            } else {
                console.warn("OpenRouter API response missing expected content:", data);
                throw new Error("OpenRouter API response format unexpected.");
            }
        } catch (error) {
            console.error("Error calling OpenRouter API:", error);
            throw error;
        }
    }


    async function callDeepSeekApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_DEEPSEEK_API_KEY) { throw new Error("DeepSeek API Key not set."); }
        const DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions";
        const modelToUse = getCurrentDeepSeekModel();
        const maxTokensToUse = maxTokensOverride !== null ? maxTokensOverride : getCurrentDeepSeekMaxTokens();

        try {
            const response = await fetch(DEEPSEEK_API_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${window.GLOBAL_DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    messages: messages,
                    model: modelToUse,
                    temperature: temperature,
                    max_tokens: maxTokensToUse,
                })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("DeepSeek API Error Response:", errorData);
                throw new Error(`DeepSeek API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`);
            }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            } else {
                console.warn("DeepSeek API response missing expected content:", data);
                throw new Error("DeepSeek API response format unexpected.");
            }
        } catch (error) {
            console.error("Error calling DeepSeek API:", error);
            throw error;
        }
    }

    async function callHuggingFaceApi(modelId, payload = {}) {
        if (!window.GLOBAL_HF_TOKEN) { throw new Error("Hugging Face API Token not set."); }
        let effectiveModelId = modelId.trim();
        if (effectiveModelId.endsWith('.')) {
            effectiveModelId = effectiveModelId.substring(0, effectiveModelId.length - 1);
        }
        const HF_API_URL = `https://api-inference.huggingface.co/models/${effectiveModelId}`;
        let requestBody;
        if (typeof payload === 'string') { requestBody = { inputs: payload, parameters: { max_new_tokens: DEFAULT_HF_MAX_NEW_TOKENS, return_full_text: false, temperature: 0.7 }, options: { wait_for_model: true }}; }
        else { requestBody = { inputs: payload.inputs, parameters: { max_new_tokens: DEFAULT_HF_MAX_NEW_TOKENS, return_full_text: false, temperature: 0.7, ...payload.parameters }, options: { wait_for_model: true, ...payload.options }}; }
        try {
            const response = await fetch(HF_API_URL, { method: 'POST', headers: { 'Authorization': `Bearer ${window.GLOBAL_HF_TOKEN}`, 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) { const errorText = await response.text(); console.error("Hugging Face API Error Response Text:", errorText); let errorMessage = `HF API request failed: ${response.status} ${response.statusText}. Model: ${effectiveModelId}.`; try { const errorData = JSON.parse(errorText); errorMessage += ` ${errorData?.error || ''}`; } catch (e) { errorMessage += ` ${errorText}`; } throw new Error(errorMessage); }
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0 && data[0].generated_text) { return data[0].generated_text; }
            else if (typeof data === 'string') { return data; } else if (data.generated_text) { return data.generated_text; }
            else { console.warn("Hugging Face API response format unexpected:", data); return typeof data === 'string' ? data : JSON.stringify(data); }
        } catch (error) { console.error("Error calling Hugging Face API:", error); throw error; }
    }

    // --- Window Management ---
    function openWindow(appId, options = {}, isPopup = false) {
        const windowEl = document.getElementById(appId);
        if (windowEl) {
            windowEl.style.display = 'flex';
            windowEl.classList.remove('minimized'); 

            if(window.innerWidth <= 768 && !windowEl.classList.contains('fullscreen') && !isPopup && appId !== 'setupGuideModal') { // Don't fullscreen the setup guide modal on mobile by default
                windowEl.classList.add('mobile-default-fullscreen');
            } else if (appId !== 'setupGuideModal') { // Don't remove if it is the setup guide
                windowEl.classList.remove('mobile-default-fullscreen');
            }


            const titleTextEl = windowEl.querySelector('.title-bar-text');
            if (options.title && titleTextEl) { titleTextEl.textContent = options.title; }
            else if (options.fileId && appId === 'textEditorWindow' && titleTextEl) { /* handled by openTextEditorWindow */ }
            else if (options.vfsPathId && appId === 'fileExplorerWindow' && titleTextEl) {
                const folder = getVFSEntry(options.vfsPathId);
                titleTextEl.textContent = `📁 ${folder ? folder.name : (options.vfsPathId === 'root' ? 'Files' : 'File Explorer')}`;
            }

            bringToFront(windowEl);
            if (appId === 'fileExplorerWindow' && options.vfsPathId) { initFileExplorerAppForVFS(options); }
            else if (appId === 'textEditorWindow') { openTextEditorWindow(options); }
            else if (appId === 'imageToCodeWindow') { openImageToCodeWindow(); }

            if (!isPopup && !windowEl.dataset.isPopup && appId !== 'setupGuideModal') { 
                 createTaskbarButton(windowEl);
                 updateTaskbarButtonState(windowEl.id, 'active');
            }
            return windowEl;
        }
        return null;
    }

    function closeWindow(windowEl) {
        if (windowEl) {
            const windowId = windowEl.id;
            if (windowId.startsWith('webBrowserWindow-') && browserInstances[windowId]) {
                browserInstances[windowId].iframe.srcdoc = ''; browserInstances[windowId].iframe.src = 'about:blank';
                delete browserInstances[windowId]; windowEl.remove();
            } else if (windowId.startsWith('sparkyAdPopup-') || windowId.startsWith('sparkyHtmlPopup-')) {
                windowEl.remove();
            } else if (windowId === 'setupGuideModal') { // Specific handling for setup guide modal
                windowEl.style.display = 'none';
            }
            else {
                 windowEl.style.display = 'none';
                 windowEl.classList.remove('active', 'fullscreen', 'minimized', 'mobile-default-fullscreen');
                 if (windowId === 'gamePlayerWindow' && gamePlayerWindow_iframe) { gamePlayerWindow_iframe.srcdoc = ''; gamePlayerWindow_iframe.src = 'about:blank'; }
                 if (windowId === 'textEditorWindow') { currentTextEditorFileId = null; if(textEditor_contentArea) textEditor_contentArea.value = ""; if(textEditor_currentFileName) textEditor_currentFileName.textContent = ""; }
            }
            if (windowId !== 'setupGuideModal') {
                removeTaskbarButton(windowId);
            }
            if (activeWindow === windowEl) activeWindow = null;
        }
    }

    function handleMinimizeWindow(windowEl) {
        if (windowEl && !windowEl.classList.contains('minimized')) {
            windowEl.style.display = 'none';
            windowEl.classList.add('minimized');
            windowEl.classList.remove('active');
            updateTaskbarButtonState(windowEl.id, 'minimized');
            if (activeWindow === windowEl) {
                activeWindow = null;
                let maxZ = -1;
                document.querySelectorAll('.window:not(.minimized)').forEach(win => {
                    if (win.id === 'setupGuideModal' && win.style.display === 'flex') return; // Skip setup modal if it's visible but not active focus
                    const z = parseInt(win.style.zIndex || '0');
                    if (z > maxZ && win.style.display !== 'none') {
                        maxZ = z; activeWindow = win;
                    }
                });
                if(activeWindow) activeWindow.classList.add('active');
            }
            updateAllTaskbarButtonStates();
        }
    }

    function bringToFront(windowEl) {
        if (!windowEl || windowEl.classList.contains('minimized')) return;
        if (activeWindow && activeWindow !== windowEl) { activeWindow.classList.remove('active'); updateTaskbarButtonState(activeWindow.id, 'normal'); }
        highestZIndex++; windowEl.style.zIndex = highestZIndex;
        windowEl.classList.add('active');
        windowEl.style.display = 'flex';
        activeWindow = windowEl;
        if (windowEl.id !== 'setupGuideModal') { // Don't create taskbar button for setup guide modal
            updateTaskbarButtonState(windowEl.id, 'active');
        }
        document.querySelectorAll('.taskbar-button').forEach(btn => {
            if (btn.dataset.windowId !== windowEl.id) {
                const linkedWin = document.getElementById(btn.dataset.windowId);
                if(linkedWin && !linkedWin.classList.contains('minimized')) {
                    btn.classList.remove('active');
                }
            }
        });
    }

    initializeDesktopIconBehaviors();

    if(desktopElement) { desktopElement.addEventListener('click', (e) => { if (!e.target.closest('.start-button') && !e.target.closest('.start-menu') && !e.target.closest('.context-menu') && !e.target.closest('#setupGuideModal')) { if(startMenu) startMenu.style.display = 'none'; if(desktopContextMenu) desktopContextMenu.style.display = 'none'; if(setupGuideModal && !e.target.closest('#customSetupLink')) closeSetupGuideModal(); } if (!e.target.closest('.desktop-icon')) { document.querySelectorAll('.desktop-icon.selected').forEach(i => i.classList.remove('selected')); contextMenuTargetVFSId = null; } }); }

    function initializeWindowBehavior(windowEl) {
        const titleBar = windowEl.querySelector('.title-bar');
        const closeButton = windowEl.querySelector('.close-button');
        const fullscreenButton = windowEl.querySelector('.fullscreen-button');
        const minimizeButton = windowEl.querySelector('.minimize-button');

        // Do not attach bringToFront if it's the setup guide modal, it's handled by openSetupGuideModal
        if (windowEl.id !== 'setupGuideModal') {
            windowEl.addEventListener('mousedown', () => bringToFront(windowEl), true);
        }

        if (titleBar && windowEl.id !== 'setupGuideModal') {
            let isDragging = false;
            let initialLeft, initialTop, startX, startY;

            const onDragStart = (clientX, clientY) => {
                isDragging = true;
                bringToFront(windowEl);
                initialLeft = windowEl.offsetLeft;
                initialTop = windowEl.offsetTop;
                startX = clientX;
                startY = clientY;
                titleBar.style.cursor = 'grabbing';
            };

            const onDragMove = (clientX, clientY) => {
                if (!isDragging) return;
                let newX = initialLeft + (clientX - startX);
                let newY = initialTop + (clientY - startY);
                const desktopRect = desktopElement.getBoundingClientRect();
                const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;
                newX = Math.max(0, Math.min(newX, desktopRect.width - windowEl.offsetWidth));
                newY = Math.max(0, Math.min(newY, desktopRect.height - windowEl.offsetHeight - taskbarHeight + 20));
                windowEl.style.left = newX + 'px';
                windowEl.style.top = newY + 'px';
            };

            const onDragEnd = () => {
                isDragging = false;
                titleBar.style.cursor = 'move';
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
            };

            const onMouseDown = (e) => {
                if (e.target.closest('.title-bar-controls button') || windowEl.classList.contains('fullscreen') || windowEl.classList.contains('mobile-default-fullscreen')) return;
                onDragStart(e.clientX, e.clientY);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };
            const onMouseMove = (e) => onDragMove(e.clientX, e.clientY);
            const onMouseUp = () => onDragEnd();

            const onTouchStart = (e) => {
                if (e.target.closest('.title-bar-controls button') || windowEl.classList.contains('fullscreen') || windowEl.classList.contains('mobile-default-fullscreen')) return;
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    onDragStart(touch.clientX, touch.clientY);
                    document.addEventListener('touchmove', onTouchMove, { passive: false });
                    document.addEventListener('touchend', onTouchEnd);
                }
            };
            const onTouchMove = (e) => {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    onDragMove(e.touches[0].clientX, e.touches[0].clientY);
                }
            };
            const onTouchEnd = () => onDragEnd();

            titleBar.addEventListener('mousedown', onMouseDown);
            titleBar.addEventListener('touchstart', onTouchStart, { passive: true });
        }
        // Close button for setupGuideModal is handled separately
        if (closeButton && windowEl.id !== 'setupGuideModal') { closeButton.addEventListener('click', () => closeWindow(windowEl)); }
        if (fullscreenButton) { fullscreenButton.addEventListener('click', () => { windowEl.classList.remove('mobile-default-fullscreen','minimized'); windowEl.classList.toggle('fullscreen'); windowEl.style.display = 'flex'; bringToFront(windowEl); });}
        if (minimizeButton) { minimizeButton.addEventListener('click', () => handleMinimizeWindow(windowEl)); }
    }

    document.querySelectorAll('.window').forEach(windowEl => initializeWindowBehavior(windowEl));

    function updateClock() { if (taskbarClock) taskbarClock.textContent = new Date().toLocaleTimeString(); }
    setInterval(updateClock, 1000); updateClock();

    // --- Taskbar Management ---
    function createTaskbarButton(windowEl) {
        if (!windowEl || !taskbarButtonsContainer || windowEl.dataset.isPopup === "true" || windowEl.id === 'setupGuideModal') return;
        const windowId = windowEl.id;
        const existingBtn = taskbarButtonsContainer.querySelector(`.taskbar-button[data-window-id="${windowId}"]`);
        if (existingBtn) existingBtn.remove();

        const button = document.createElement('button');
        button.className = 'taskbar-button';
        button.dataset.windowId = windowId;

        const titleTextEl = windowEl.querySelector('.title-bar-text');
        button.textContent = titleTextEl ? titleTextEl.textContent.substring(0,20) + (titleTextEl.textContent.length > 20 ? '...' : '') : windowId;
        button.title = titleTextEl ? titleTextEl.textContent : windowId;

        button.addEventListener('click', () => handleTaskbarButtonClick(windowId));

        button.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            hideAllContextMenus();

            const windowEl = document.getElementById(windowId);
            if (!windowEl) return;

            taskbarContextMenu.innerHTML = ''; // Clear previous items
            const closeItem = document.createElement('div');
            closeItem.className = 'context-menu-item';
            closeItem.textContent = 'Close';
            closeItem.addEventListener('click', () => {
                closeWindow(windowEl);
                hideAllContextMenus();
            });
            taskbarContextMenu.appendChild(closeItem);

            const menuWidth = taskbarContextMenu.offsetWidth;
            const menuHeight = taskbarContextMenu.offsetHeight;
            const desktopRect = desktopElement.getBoundingClientRect();

            let x = e.clientX;
            let y = e.clientY - menuHeight; // Position above the cursor

            if (x + menuWidth > desktopRect.right) x = desktopRect.right - menuWidth - 5;
            if (y < 0) y = e.clientY; // If it goes off-screen, show below cursor

            taskbarContextMenu.style.left = `${x}px`;
            taskbarContextMenu.style.top = `${y}px`;
            taskbarContextMenu.style.display = 'block';
        });

        taskbarButtonsContainer.appendChild(button);
    }

    function removeTaskbarButton(windowId) {
        if (!taskbarButtonsContainer || windowId === 'setupGuideModal') return;
        const button = taskbarButtonsContainer.querySelector(`.taskbar-button[data-window-id="${windowId}"]`);
        if (button) button.remove();
    }

    function updateTaskbarButtonState(windowId, state) { 
        if (!taskbarButtonsContainer || windowId === 'setupGuideModal') return;
        const button = taskbarButtonsContainer.querySelector(`.taskbar-button[data-window-id="${windowId}"]`);
        if (button) {
            button.classList.remove('active', 'minimized'); 
            if (state === 'active') button.classList.add('active');
            else if (state === 'minimized') button.classList.add('minimized');
        }
    }
    function updateAllTaskbarButtonStates() {
        document.querySelectorAll('.taskbar-button').forEach(btn => {
            const winId = btn.dataset.windowId;
            if (winId === 'setupGuideModal') return;
            const win = document.getElementById(winId);
            if (win) {
                if (win.classList.contains('minimized')) {
                    updateTaskbarButtonState(winId, 'minimized');
                } else if (win === activeWindow) {
                    updateTaskbarButtonState(winId, 'active');
                } else {
                    updateTaskbarButtonState(winId, 'normal');
                }
            }
        });
    }


    function handleTaskbarButtonClick(windowId) {
        const windowEl = document.getElementById(windowId);
        if (windowEl) {
            if (windowEl.classList.contains('minimized')) {
                windowEl.style.display = 'flex';
                windowEl.classList.remove('minimized');
                bringToFront(windowEl);
            } else if (windowEl === activeWindow) {
                handleMinimizeWindow(windowEl);
            } else { 
                bringToFront(windowEl);
            }
        }
    }

    // --- Context Menu ---
    function handleDesktopContextMenu(event, specificItemId = null) {
        event.preventDefault();
        event.stopPropagation();
        if (!desktopContextMenu || !desktopElement) return;

        hideContextMenu();

        const target = event.target;
        let menuItems = [];
        let parentIdForNewItems = 'root';

        const clickedIcon = target.closest('.desktop-icon');
        const clickedFileExplorerItem = target.closest('#fe_fileList li');
        const isFilesDesktopIcon = clickedIcon && clickedIcon.dataset.appId === 'fileExplorerWindow' && clickedIcon.dataset.vfsPathId === 'root';
        const isTrashBinIcon = clickedIcon && clickedIcon.dataset.appId === 'trashBin';

        if (isTrashBinIcon) {
            menuItems.push({ label: "Open", action: () => { openWindow('fileExplorerWindow', { vfsPathId: TRASH_VFS_ID }); hideContextMenu(); } });
            menuItems.push({ type: 'separator' });
            menuItems.push({ label: "Empty Trash", action: () => { emptyTrash(); hideContextMenu(); } });
        }
        else if (isFilesDesktopIcon) {
             contextMenuTargetVFSId = 'root';
             menuItems.push({ label: "Open Files", action: () => { handleDesktopIconDblClick(clickedIcon); hideContextMenu(); } });
             menuItems.push({ type: 'separator' });
             menuItems.push({ label: "Download All Files as ZIP", action: () => { downloadVFSEntryAsZip('root'); hideContextMenu(); } });
        } else if (specificItemId || (clickedIcon && clickedIcon.dataset.itemId) || (clickedFileExplorerItem && clickedFileExplorerItem.dataset.itemId)) {
            contextMenuTargetVFSId = specificItemId || (clickedIcon ? clickedIcon.dataset.itemId : clickedFileExplorerItem.dataset.itemId);
            const itemEntry = getVFSEntry(contextMenuTargetVFSId);
            if (itemEntry) {
                menuItems.push({ label: "Open", action: () => {
                    const elementToDblClick = clickedIcon || document.querySelector(`.desktop-icon[data-item-id="${contextMenuTargetVFSId}"]`) || clickedFileExplorerItem;
                    if (elementToDblClick) handleDesktopIconDblClick(elementToDblClick);
                    hideContextMenu();
                }});
                menuItems.push({ label: "Rename", action: () => { renameVFSEntry(contextMenuTargetVFSId); hideContextMenu(); } });
                if (itemEntry.type === 'file') {
                    // Add "Open with Editor" for HTML files
                    if (itemEntry.name.endsWith('.html') || itemEntry.name.endsWith('.htm')) {
                        menuItems.push({
                            label: "Open with Editor",
                            action: () => {
                                openWindow('textEditorWindow', { fileId: contextMenuTargetVFSId });
                                hideContextMenu();
                            }
                        });
                    }
                    menuItems.push({ label: "Download File", action: () => { downloadVFSEntry(contextMenuTargetVFSId); hideContextMenu(); } });
                } else if (itemEntry.type === 'folder') {
                    menuItems.push({ label: "Download Folder as ZIP", action: () => { downloadVFSEntryAsZip(contextMenuTargetVFSId); hideContextMenu(); } });
                }
                menuItems.push({ type: 'separator' });
                menuItems.push({ label: "Delete", action: () => { deleteVFSEntryWithConfirmation(contextMenuTargetVFSId); hideContextMenu(); } });
            }
        } else if (target.closest('#fe_fileListContainer')) {
             contextMenuTargetVFSId = null;
             parentIdForNewItems = currentFEVfsPathId;
             menuItems.push({ label: "New Folder", action: () => { createNewVFSEntry('folder', parentIdForNewItems); hideContextMenu(); } });
             menuItems.push({ label: "New Text File", action: () => { createNewVFSEntry('file', parentIdForNewItems); hideContextMenu(); } });
        } else if (target === desktopElement || target.classList.contains('desktop')) {
            contextMenuTargetVFSId = null;
            menuItems.push({ label: "New Folder", action: () => { createNewVFSEntry('folder', 'root'); hideContextMenu(); } });
            menuItems.push({ label: "New Text File", action: () => { createNewVFSEntry('file', 'root'); hideContextMenu(); } });
        } else {
            return;
        }

        if (menuItems.length > 0) {
            populateContextMenu(menuItems);
            const menuWidth = desktopContextMenu.offsetWidth;
            const menuHeight = desktopContextMenu.offsetHeight;
            const desktopRect = desktopElement.getBoundingClientRect();
            let x = event.clientX;
            let y = event.clientY;
            if (x + menuWidth > desktopRect.right) x = desktopRect.right - menuWidth - 5;
            if (y + menuHeight > desktopRect.bottom - (document.querySelector('.taskbar')?.offsetHeight || 0)) y = desktopRect.bottom - menuHeight - 5 - (document.querySelector('.taskbar')?.offsetHeight || 0);
            desktopContextMenu.style.left = `${x}px`;
            desktopContextMenu.style.top = `${y}px`;
            desktopContextMenu.style.display = 'block';
        }
    }

    function hideAllContextMenus() {
        if (desktopContextMenu) desktopContextMenu.style.display = 'none';
        if (taskbarContextMenu) taskbarContextMenu.style.display = 'none';
        contextMenuTargetVFSId = null;
    }

    function hideContextMenu() {
        hideAllContextMenus();
    }

    function populateContextMenu(items) {
        if (!desktopContextMenu) return;
        desktopContextMenu.innerHTML = '';
        items.forEach(item => {
            if (item.type === 'separator') {
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                desktopContextMenu.appendChild(separator);
            } else {
                const menuItemEl = document.createElement('div');
                menuItemEl.className = 'context-menu-item';
                menuItemEl.textContent = item.label;
                menuItemEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    item.action();
                });
                desktopContextMenu.appendChild(menuItemEl);
            }
        });
    }

    function createNewVFSEntry(type, parentId = 'root') {
        const defaultName = type === 'folder' ? "New Folder" : "New Text File.txt";
        const name = prompt(`Enter name for new ${type}:`, defaultName);
        if (name) {
            const entryData = { type: type, name: name, parentId: parentId };
            if (type === 'file') {
                entryData.content = "";
                entryData.mimeType = name.endsWith('.html') || name.endsWith('.htm') ? 'text/html' : 'text/plain';
            }
            const newEntry = createVFSEntry(entryData);
            if (parentId === 'root' && !(newEntry.name === SPARKY_CREATIONS_FOLDER_NAME)) renderDesktopVFSIcons();
            if (fe_fileListElement && parentId === currentFEVfsPathId) renderVFSFileList(parentId);
            logK8osActivity("Context Menu", `Created new ${type}: ${name} in ${parentId === 'root' ? 'Files (Root)' : getVFSEntry(parentId)?.name || 'Unknown'}`);
        }
    }

    function renameVFSEntry(itemId) {
        const item = getVFSEntry(itemId);
        if (item) {
            const newName = prompt(`Enter new name for "${item.name}":`, item.name);
            if (newName && newName !== item.name) {
                updateVFSEntry(itemId, { name: newName });
                if (item.parentId === 'root' && !(item.name === SPARKY_CREATIONS_FOLDER_NAME && newName === SPARKY_CREATIONS_FOLDER_NAME) ) renderDesktopVFSIcons();
                if (fe_fileListElement && (item.parentId === currentFEVfsPathId || itemId === currentFEVfsPathId)) renderVFSFileList(currentFEVfsPathId);
                logK8osActivity("Context Menu", `Renamed "${item.name}" to "${newName}"`);
            }
        }
    }

    function deleteVFSEntryWithConfirmation(itemId) {
        const item = getVFSEntry(itemId);
        if (item) {
            const isPermanentDelete = item.parentId === TRASH_VFS_ID;
            const message = isPermanentDelete
                ? `Are you sure you want to permanently delete "${item.name}"? This cannot be undone.`
                : `Are you sure you want to move "${item.name}" to the Trash?`;

            if (confirm(message)) {
                if (isPermanentDelete) {
                    deleteVFSEntry(itemId); // This is the real recursive delete
                } else {
                    updateVFSEntry(itemId, { parentId: TRASH_VFS_ID });
                }
                // Always refresh the UI
                renderDesktopVFSIcons();
                const fileExplorerWindow = document.getElementById('fileExplorerWindow');
                if (fileExplorerWindow && fileExplorerWindow.style.display === 'flex') {
                    renderVFSFileList(currentFEVfsPathId);
                }
                logK8osActivity("VFS", `${isPermanentDelete ? 'Permanently deleted' : 'Moved to trash'}: ${item.name}`);
            }
        }
    }

    function downloadVFSEntry(itemId) {
        const item = getVFSEntry(itemId);
        if (item && item.type === 'file') {
            downloadFile(item.content || "", item.name, item.mimeType || "application/octet-stream");
            logK8osActivity("Context Menu", `Downloaded file: ${item.name}`);
        } else if (item && item.type === 'folder') {
            downloadVFSEntryAsZip(itemId);
        }
    }

    function emptyTrash() {
        const trashItems = getVFSChildren(TRASH_VFS_ID);
        if (trashItems.length === 0) {
            alert("The Trash is already empty.");
            return;
        }
        if (confirm(`Are you sure you want to permanently delete all ${trashItems.length} items in the Trash? This action cannot be undone.`)) {
            trashItems.forEach(item => deleteVFSEntry(item.id));
            logK8osActivity("VFS", "Emptied the trash.");
            // Refresh file explorer if it's showing the trash
            const fileExplorerWindow = document.getElementById('fileExplorerWindow');
            if (fileExplorerWindow && fileExplorerWindow.style.display === 'flex' && currentFEVfsPathId === TRASH_VFS_ID) {
                renderVFSFileList(TRASH_VFS_ID);
            }
        }
    }
    document.addEventListener('click', (e) => {
        // Hide context menus if click is outside
        if (!e.target.closest('.context-menu')) {
            hideAllContextMenus();
        }
        // Hide calendar if click is outside
        if (calendarPopup && calendarPopup.style.display === 'block' && !e.target.closest('.calendar-popup') && e.target !== taskbarClock && !taskbarClock.contains(e.target)) {
            calendarPopup.style.display = 'none';
        }
        
         if (startMenu && startMenu.style.display === 'flex' && !e.target.closest('.start-button') && !e.target.closest('.start-menu')) {
            startMenu.style.display = 'none';
        }
        // Hide setup guide modal if clicking outside of it, and not on the trigger links
        if (setupGuideModal && setupGuideModal.style.display === 'flex' && !e.target.closest('#setupGuideModal') && !e.target.closest('#customSetupLink')) {
            closeSetupGuideModal();
        }
    });


    let vibe_currentContent = null;
    let vibe_currentContentType = 'svg'; // svg, p5js, threejs, babylonjs
    const vibeStatusUpdater = (msg) => { if(vibe_errorDisplay) vibe_errorDisplay.textContent = `Status: ${msg}`; if(vibe_loadingIndicator && msg.toLowerCase().includes("loading")) vibe_loadingIndicator.style.display = 'block'; else if(vibe_loadingIndicator) vibe_loadingIndicator.style.display = 'none';};
    function initVibeCreatorApp() {
        vibe_genAI_internal_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());


        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    vibe_genAI_internal_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.2, maxOutputTokens: 80000 } });
                    if (vibe_generateButton) vibe_generateButton.disabled = false; vibeStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("Vibe Gen Gemini AI Init Error:", error); vibeStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if (vibe_generateButton) vibe_generateButton.disabled = true; }
            } else { if (vibe_generateButton) vibe_generateButton.disabled = false; vibeStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { vibeStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if (vibe_generateButton) vibe_generateButton.disabled = true; }
    }

    async function internal_generateSingleSvg(svgDescription, isAnimated = false, statusUpdaterFn = null) {
        const instruction = isAnimated 
            ? getAppInstruction('gifCreatorNew', DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION) 
            : getAppInstruction('vibe', DEFAULT_VIBE_SVG_INSTRUCTION);
        
        const fullPrompt = instruction.replace("{USER_PROMPT}", svgDescription);
        
        try {
            const resultText = await callCurrentAiProviderForText(fullPrompt, 80000, isAnimated ? 0.4 : 0.2, statusUpdaterFn);
            
            if (!resultText) {
                console.warn("AI returned no content for SVG generation.");
                return null;
            }

            const svgMatch = resultText.match(/<svg[\s\S]*?<\/svg>/im);
            if (svgMatch && svgMatch[0]) {
                return svgMatch[0];
            }
            
            console.warn("No valid SVG found in AI response for:", svgDescription, "Provider:", selectedApiProvider);
            return null; // Return null if no valid SVG is found
        } catch (error) {
            console.error(`Error in internal_generateSingleSvg with ${selectedApiProvider}:`, error);
            return null;
        }
    }

    async function vibe_handleGenerate() {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (!keyAvailable) {
            vibeStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider.");
            return;
        }
        if (selectedApiProvider === 'gemini' && !vibe_genAI_internal_model) {
            vibeStatusUpdater("Gemini Vibe AI model not initialized.");
            return;
        }

        const userPrompt = vibe_promptInput.value.trim();
        if (!userPrompt) {
            vibeStatusUpdater('Enter description.');
            return;
        }

        const creatorType = vibe_creator_type_select.value;
        vibe_currentContentType = creatorType;

        if (vibe_generateButton) vibe_generateButton.disabled = true;
        if (vibe_downloadButton) vibe_downloadButton.style.display = 'none';
        if (vibe_container) vibe_container.innerHTML = '';
        vibeStatusUpdater(`Generating ${creatorType}...`);
        vibe_currentContent = null;

        let instruction;
        switch (creatorType) {
            case 'p5js':
                instruction = DEFAULT_VIBE_P5JS_INSTRUCTION;
                break;
            case 'threejs':
                instruction = DEFAULT_VIBE_THREEJS_INSTRUCTION;
                break;
            case 'babylonjs':
                instruction = DEFAULT_VIBE_BABYLONJS_INSTRUCTION;
                break;
            case 'svg':
            default:
                instruction = DEFAULT_VIBE_SVG_INSTRUCTION;
                break;
        }

        const fullPrompt = instruction.replace("{USER_PROMPT}", userPrompt);

        try {
            let resultText = await callCurrentAiProviderForText(fullPrompt, 80000, 0.7, vibeStatusUpdater);
            
            if (resultText && resultText.startsWith("```html")) {
                resultText = resultText.substring(7).trim();
            } else if (resultText && resultText.startsWith("```")) {
                resultText = resultText.substring(3).trim();
            }
            if (resultText && resultText.endsWith("```")) {
                resultText = resultText.substring(0, resultText.length - 3).trim();
            }

            vibe_currentContent = resultText;

            if (!vibe_currentContent) {
                throw new Error("AI returned no content.");
            }

            if (creatorType === 'svg') {
                const svgMatch = vibe_currentContent.match(/<svg[\s\S]*?<\/svg>/im);
                if (svgMatch && svgMatch[0]) {
                    vibe_container.innerHTML = svgMatch[0];
                    const svgElement = vibe_container.querySelector('svg');
                    if (svgElement) {
                        if (!svgElement.getAttribute('xmlns')) svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                        if (svgElement.getAttribute('viewBox')) {
                            svgElement.style.width = '100%';
                            svgElement.style.height = 'auto';
                            svgElement.removeAttribute('width');
                            svgElement.removeAttribute('height');
                        }
                    }
                } else {
                    throw new Error("No valid SVG found in AI response.");
                }
            } else {
                // For p5.js, three.js, babylon.js, we expect full HTML
                if (vibe_currentContent.toLowerCase().includes('<html')) {
                    vibe_container.innerHTML = `<iframe srcdoc="${vibe_currentContent.replace(/"/g, '&quot;')}" style="width: 100%; height: 100%; border: none;"></iframe>`;
                } else {
                    throw new Error("No valid HTML found in AI response for JS library.");
                }
            }

            if (vibe_downloadButton) vibe_downloadButton.style.display = 'block';
            vibeStatusUpdater(`${creatorType} Generated.`);

            // --- Auto-save to VFS ---
            try {
                const basePath = `live/vibecreator/${creatorType}`;
                const targetFolderId = ensureVFSPath(basePath);
                
                const fileName = (userPrompt.substring(0, 25).replace(/[^a-z0-9]/gi, '_') || `vibe_${creatorType}`) + `_${Date.now().toString(36)}` + (creatorType === 'svg' ? '.svg' : '.html');

                createVFSEntry({
                    type: 'file',
                    name: fileName,
                    content: vibe_currentContent,
                    mimeType: creatorType === 'svg' ? 'image/svg+xml' : 'text/html',
                    parentId: targetFolderId
                });

                // Update status bar with save location, but don't overwrite the "Generated" message immediately.
                setTimeout(() => {
                    const currentStatus = vibe_errorDisplay.textContent;
                    if(currentStatus.includes("Generated")) {
                         vibeStatusUpdater(`${creatorType} Generated. Saved to ${basePath}/${fileName}`);
                    }
                }, 1000);

                // Refresh file explorer if it's open and showing a relevant directory
                const fileExplorerWindow = document.getElementById('fileExplorerWindow');
                if (fileExplorerWindow && fileExplorerWindow.style.display === 'flex') {
                    const ancestorId = getVFSEntry(targetFolderId)?.parentId; // vibecreator folder
                    const grandAncestorId = ancestorId ? getVFSEntry(ancestorId)?.parentId : null; // live folder
                    if (currentFEVfsPathId === targetFolderId || currentFEVfsPathId === ancestorId || currentFEVfsPathId === grandAncestorId) {
                        renderVFSFileList(currentFEVfsPathId);
                    }
                }

            } catch (vfsError) {
                console.error("VFS auto-save error:", vfsError);
                // Append to status instead of overwriting
                vibe_errorDisplay.textContent += ` | VFS Save Failed: ${vfsError.message}`;
            }
            // --- End Auto-save ---

        } catch (error) {
            console.error("Vibe Generation Error:", error);
            vibeStatusUpdater(`Error generating ${creatorType}: ${error.message}`);
            if (vibe_container) vibe_container.innerHTML = `<p style="color:red;">Generation failed.</p>`;
        } finally {
            enableAppButtons();
            if (vibe_loadingIndicator) vibe_loadingIndicator.style.display = 'none';
        }
    }
    function vibe_handleDownload() {
        if (vibe_currentContent) {
            const fileName = vibe_promptInput.value.trim().toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '_') || "vibe";
            if (vibe_currentContentType === 'svg') {
                downloadFile(vibe_currentContent, `${fileName}.svg`, "image/svg+xml;charset=utf-8");
            } else {
                downloadFile(vibe_currentContent, `${fileName}.html`, "text/html;charset=utf-8");
            }
        } else {
            alert("No content to download.");
        }
    }

   
    const gifCreatorStatusUpdater = (msg) => { if(gifCreator_errorDisplay) gifCreator_errorDisplay.textContent = `Status: ${msg}`; if(gifCreator_loadingIndicator && msg.toLowerCase().includes("loading")) gifCreator_loadingIndicator.style.display = 'block'; else if(gifCreator_loadingIndicator) gifCreator_loadingIndicator.style.display = 'none';};
    function initGifCreatorApp() {
        gifCreator_genAI_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    gifCreator_genAI_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.4, maxOutputTokens: 80000 } });
                    if(gifCreator_generateButton) gifCreator_generateButton.disabled = false; gifCreatorStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("GIF Creator Gemini AI Init Error:", error); gifCreatorStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if(gifCreator_generateButton) gifCreator_generateButton.disabled = true; }
            } else { if(gifCreator_generateButton) gifCreator_generateButton.disabled = false; gifCreatorStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { gifCreatorStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if(gifCreator_generateButton) gifCreator_generateButton.disabled = true; }
    }

    const gameGenStatusUpdater = (msg) => { if(gameGen_apiErrorDisplay) gameGen_apiErrorDisplay.textContent = `Status: ${msg}`; };
    function initGameGeneratorApp() {
        gameGen_main_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    gameGen_main_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.7, topK: 40, topP: 0.95, maxOutputTokens: 120000 } });
                    if (gameGen_generateButton) gameGen_generateButton.disabled = false; gameGenStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("Game Gen Gemini AI Init Error:", error); gameGenStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if (gameGen_generateButton) gameGen_generateButton.disabled = true; }
            } else { if (gameGen_generateButton) gameGen_generateButton.disabled = false; gameGenStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { gameGenStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if (gameGen_generateButton) gameGen_generateButton.disabled = true; }
    }
    function gameGen_showLoading(message = "AI is working...") { if (!gameGen_loadingMessage || !gameGen_generateButton) return; gameGen_loadingMessage.textContent = message; gameGen_loadingMessage.style.display = 'block'; gameGen_generateButton.disabled = true; if(gameGen_downloadZipButton) gameGen_downloadZipButton.style.display = 'none'; gameGen_lastGameAssetPackage = null; if(gameGen_debugSection) gameGen_debugSection.style.display = 'none';}
    function gameGen_hideLoading() { if(gameGen_loadingMessage) gameGen_loadingMessage.style.display = 'none'; enableAppButtons(); }
    function gameGen_displayError(message, isRuntimeError = false) { if (!gameGen_errorMessage) return; gameGen_errorMessage.textContent = "Game Gen Error: " + message + (isRuntimeError ? " Check Browser Console (F12)." : ""); gameGen_errorMessage.style.display = 'block'; gameGenStatusUpdater(`Error: ${message.substring(0,100)}`);}
    function gameGen_clearError() { if (!gameGen_errorMessage) return; gameGen_errorMessage.textContent = ''; gameGen_errorMessage.style.display = 'none'; }

    async function internal_generateSingleSoundJs(soundDescription, statusUpdaterFn = null) {
        const baseInstruction = getAppInstruction('musicStudio', DEFAULT_MUSICSTUDIO_INSTRUCTION);
        const fullPrompt = baseInstruction.replace("{USER_PROMPT}", soundDescription);
        try {
            let jsCode;
            if (selectedApiProvider === 'gemini') {
                let modelToUse = musicStudio_genAI_model;
                if (!modelToUse) {
                    initMusicStudioApp();
                    modelToUse = musicStudio_genAI_model;
                    if (!modelToUse && gameGen_main_model) modelToUse = gameGen_main_model;
                    if (!modelToUse) throw new Error("Gemini model not initialized for sound JS.");
                }
                const result = await modelToUse.generateContent(fullPrompt); jsCode = result.response.text().trim();
            } else if (['groq', 'openrouter', 'deepseek', 'huggingface', 'transformersjs', 'custom'].includes(selectedApiProvider)) {
                 jsCode = await callCurrentAiProviderForText(fullPrompt, 8000, 0.6, statusUpdaterFn);
                 if (selectedApiProvider === 'huggingface' || selectedApiProvider === 'transformersjs' || selectedApiProvider === 'custom') {
                     jsCode = `/* WARNING: JS code generated by ${selectedApiProvider}, may not be valid Web Audio API code. */\n` + jsCode;
                 }
            } else {
                throw new Error(`Provider ${selectedApiProvider} not supported for internal sound JS generation.`);
            }
            if (jsCode && jsCode.startsWith("```javascript")) jsCode = jsCode.substring(13).trim(); else if (jsCode && jsCode.startsWith("```")) jsCode = jsCode.substring(3).trim();
            if (jsCode && jsCode.endsWith("```")) jsCode = jsCode.substring(0, jsCode.length - 3).trim(); return jsCode;
        } catch (error) { console.error(`Error in internal_generateSingleSoundJs with ${selectedApiProvider} for "${soundDescription}":`, error); return `console.warn("Failed to generate sound JS for ${soundDescription.replace(/"/g, '\\"')} in game: ${error.message || String(error)}");`; }
    }

    const musicStudioStatusUpdater = (msg) => { if(musicStudio_errorDisplay) musicStudio_errorDisplay.textContent = `Status: ${msg}`; if(musicStudio_loadingIndicator && msg.toLowerCase().includes("loading")) musicStudio_loadingIndicator.style.display = 'block'; else if(musicStudio_loadingIndicator) musicStudio_loadingIndicator.style.display = 'none';};
    function initMusicStudioApp() {
        musicStudio_genAI_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    musicStudio_genAI_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.6, maxOutputTokens: 80000 } });
                    if(musicStudio_generateButton) musicStudio_generateButton.disabled = false; musicStudioStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("Music Studio Gemini AI Init Error:", error); musicStudioStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if(musicStudio_generateButton) musicStudio_generateButton.disabled = true; }
            } else { if(musicStudio_generateButton) musicStudio_generateButton.disabled = false; musicStudioStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { musicStudioStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if(musicStudio_generateButton) musicStudio_generateButton.disabled = true; }
        if (!musicStudio_promptInput || !musicStudio_generateButton || !musicStudio_generatedCode || !musicStudio_playButton || !musicStudio_stopButton) { console.error("Music Studio UI elements missing!"); musicStudioStatusUpdater("UI Error."); }
    }

    function applyCustomImageBackground(url, size, repeat, updateStatus = true) {
        if (url) {
            document.body.style.backgroundImage = `url("${CSS.escape(url)}")`; document.body.style.backgroundSize = size;
            document.body.style.backgroundRepeat = repeat; document.body.style.backgroundColor = 'transparent';
            localStorage.setItem('k8os_desktopBgImageUrl', url); localStorage.setItem('k8os_desktopBgImageSize', size); localStorage.setItem('k8os_desktopBgImageRepeat', repeat);
            if (systemSettings_status && updateStatus) systemSettings_status.textContent = `Image background applied.`;
        } else { clearCustomImageBackground(false, updateStatus); if (systemSettings_status && updateStatus) systemSettings_status.textContent = `Image URL is empty. Image cleared.`; }
    }

    function clearCustomImageBackground(restoreColor = true, updateStatus = true) {
        document.body.style.backgroundImage = 'none'; document.body.style.backgroundSize = 'auto'; document.body.style.backgroundRepeat = 'repeat';
        localStorage.removeItem('k8os_desktopBgImageUrl'); localStorage.removeItem('k8os_desktopBgImageSize'); localStorage.removeItem('k8os_desktopBgImageRepeat');
        if (restoreColor) { const savedBgColor = localStorage.getItem('k8os_desktopBgColor') || DEFAULT_BG_COLOR; document.body.style.backgroundColor = savedBgColor; }
        if (systemSettings_status && updateStatus) systemSettings_status.textContent = `Image background cleared.`;
        if (systemSettings_appearance_bgImageUrlInput) systemSettings_appearance_bgImageUrlInput.value = '';
    }

    function applyIconScale(scaleFactor) { document.documentElement.style.setProperty('--desktop-icon-scale-factor', scaleFactor); if (systemSettings_iconSizeSliderValue) systemSettings_iconSizeSliderValue.textContent = `${Number(scaleFactor).toFixed(1)}x`; }

    function applyTheme(themeName) {
        document.body.classList.remove('aqua-theme'); // Remove other theme classes here if more are added

        if (themeName === 'aqua') {
            document.body.classList.add('aqua-theme');
        }
        
        localStorage.setItem('k8os_theme', themeName);
        if(systemSettings_status) systemSettings_status.textContent = `Theme changed to ${themeName}.`;
    }

    let calendarCurrentDate = new Date();

    function renderCalendar(year, month) {
        calendarCurrentDate.setFullYear(year, month, 1);
        const today = new Date();
        
        calendarMonthYear.textContent = calendarCurrentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        
        calendarDays.innerHTML = '';

        const firstDayOfMonth = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        let date = 1;
        for (let i = 0; i < 6; i++) { // Max 6 weeks in a month
            const row = document.createElement('tr');

            for (let j = 0; j < 7; j++) {
                const cell = document.createElement('td');
                if (i === 0 && j < firstDayOfMonth) {
                    const prevMonthDays = new Date(year, month, 0).getDate();
                    cell.textContent = prevMonthDays - firstDayOfMonth + j + 1;
                    cell.classList.add('other-month');
                } else if (date > daysInMonth) {
                    cell.textContent = date - daysInMonth;
                    cell.classList.add('other-month');
                    date++;
                } else {
                    cell.textContent = date;
                    if (date === today.getDate() && year === today.getFullYear() && month === today.getMonth()) {
                        cell.classList.add('today');
                    }
                    date++;
                }
                row.appendChild(cell);
            }
            calendarDays.appendChild(row);
            if (date > daysInMonth && i > 3) break; // Stop if we've rendered all days
        }
    }

    function initSystemSettingsApp() {
        if (systemSettings_about_version) systemSettings_about_version.textContent = `Version: ${K8OS_VERSION}`;
        if (systemSettings_transformersJsVersion) systemSettings_transformersJsVersion.textContent = TRANSFORMERS_JS_VERSION;

        const savedBgColor = localStorage.getItem('k8os_desktopBgColor') || DEFAULT_BG_COLOR;
        if (systemSettings_appearance_bgColorPicker) systemSettings_appearance_bgColorPicker.value = savedBgColor;
        if (systemSettings_appearance_colorOptions) {
            systemSettings_appearance_colorOptions.innerHTML = '';
            PRESET_BG_COLORS.forEach(color => { const button = document.createElement('button'); button.style.backgroundColor = color; button.title = color; button.addEventListener('click', () => { setDesktopBackground(color); if (systemSettings_appearance_bgColorPicker) systemSettings_appearance_bgColorPicker.value = color; }); systemSettings_appearance_colorOptions.appendChild(button); });
        }
        if (systemSettings_appearance_bgColorPicker) { systemSettings_appearance_bgColorPicker.addEventListener('input', (e) => { setDesktopBackground(e.target.value); });}
        if (systemSettings_appearance_resetButton) { systemSettings_appearance_resetButton.addEventListener('click', () => { setDesktopBackground(DEFAULT_BG_COLOR); if (systemSettings_appearance_bgColorPicker) systemSettings_appearance_bgColorPicker.value = DEFAULT_BG_COLOR; if (systemSettings_status) systemSettings_status.textContent = "Background color reset."; }); }
        const savedBgImageUrl = localStorage.getItem('k8os_desktopBgImageUrl'); const savedBgImageSize = localStorage.getItem('k8os_desktopBgImageSize') || 'cover'; const savedBgImageRepeat = localStorage.getItem('k8os_desktopBgImageRepeat') || 'no-repeat';
        if (systemSettings_appearance_bgImageUrlInput) systemSettings_appearance_bgImageUrlInput.value = savedBgImageUrl || '';
        if (systemSettings_appearance_bgSizeSelect) systemSettings_appearance_bgSizeSelect.value = savedBgImageSize;
        if (systemSettings_appearance_bgRepeatSelect) systemSettings_appearance_bgRepeatSelect.value = savedBgImageRepeat;
        if (systemSettings_appearance_applyBgImageButton) { systemSettings_appearance_applyBgImageButton.addEventListener('click', () => { const imageUrl = systemSettings_appearance_bgImageUrlInput.value.trim(); const bgSize = systemSettings_appearance_bgSizeSelect.value; const bgRepeat = systemSettings_appearance_bgRepeatSelect.value; if (imageUrl) { applyCustomImageBackground(imageUrl, bgSize, bgRepeat); } else { if (systemSettings_status) systemSettings_status.textContent = "Please enter an image URL."; } }); }
        if (systemSettings_appearance_clearBgImageButton) { systemSettings_appearance_clearBgImageButton.addEventListener('click', () => { clearCustomImageBackground(true); }); }
        const savedIconScale = parseFloat(localStorage.getItem('k8os_desktopIconScaleFactor') || '1.0'); applyIconScale(savedIconScale);
        if(systemSettings_iconSizeSlider) systemSettings_iconSizeSlider.value = savedIconScale;
        if (systemSettings_iconSizeSlider) { systemSettings_iconSizeSlider.addEventListener('input', (e) => { const newScale = e.target.value; applyIconScale(newScale); localStorage.setItem('k8os_desktopIconScaleFactor', newScale); if(systemSettings_status) systemSettings_status.textContent = `Icon scale set to ${newScale}x.`; }); }
        if (systemSettings_iconSizeResetButton) { systemSettings_iconSizeResetButton.addEventListener('click', () => { applyIconScale(1.0); localStorage.setItem('k8os_desktopIconScaleFactor', '1.0'); if(systemSettings_iconSizeSlider) systemSettings_iconSizeSlider.value = 1.0; if(systemSettings_status) systemSettings_status.textContent = "Icon scale reset to 1.0x."; }); }

        if (systemSettings_ai_modelNameInput) systemSettings_ai_modelNameInput.value = getCurrentGeminiModel();
        if (systemSettings_ai_groqModelInput) systemSettings_ai_groqModelInput.value = getCurrentGroqModel();
        if (systemSettings_ai_openaiModelInput) systemSettings_ai_openaiModelInput.value = getCurrentOpenAiModel();
        if (systemSettings_ai_groqMaxTokensInput) systemSettings_ai_groqMaxTokensInput.value = getCurrentGroqMaxTokens();
        if (systemSettings_ai_openrouterModelInput) systemSettings_ai_openrouterModelInput.value = getCurrentOpenRouterModel();
        if (systemSettings_ai_xaiModelInput) systemSettings_ai_xaiModelInput.value = getCurrentXaiModel();
        if (systemSettings_ai_openrouterHttpRefererInput) systemSettings_ai_openrouterHttpRefererInput.value = getCurrentOpenRouterHttpReferer();
        if (systemSettings_ai_deepseekModelInput) systemSettings_ai_deepseekModelInput.value = getCurrentDeepSeekModel();
        if (systemSettings_ai_deepseekMaxTokensInput) systemSettings_ai_deepseekMaxTokensInput.value = getCurrentDeepSeekMaxTokens();
        if (systemSettings_ai_hfModelIdInput) systemSettings_ai_hfModelIdInput.value = getCurrentHfModelId();
        if (systemSettings_ai_transformersjsModelIdInput) systemSettings_ai_transformersjsModelIdInput.value = getCurrentTransformersJsModelId();
        if (systemSettings_ai_customEndpointUrlInput) systemSettings_ai_customEndpointUrlInput.value = getCurrentCustomEndpointUrl();
        if (systemSettings_ai_customModelIdInput) systemSettings_ai_customModelIdInput.value = getCurrentCustomModelId();


        if (systemSettings_ai_vibeInstruction) systemSettings_ai_vibeInstruction.value = getAppInstruction('vibe', DEFAULT_VIBE_SVG_INSTRUCTION);
        if (systemSettings_ai_gameGenFinalInstruction) systemSettings_ai_gameGenFinalInstruction.value = getAppInstruction('gameGen_final', DEFAULT_GAMEGEN_FINAL_INSTRUCTION);
        if (systemSettings_ai_musicStudioInstruction) systemSettings_ai_musicStudioInstruction.value = getAppInstruction('musicStudio', DEFAULT_MUSICSTUDIO_INSTRUCTION);
        if (systemSettings_ai_gifCreatorNewInstruction) systemSettings_ai_gifCreatorNewInstruction.value = getAppInstruction('gifCreatorNew', DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION);
        if (systemSettings_ai_gifCreatorAnimateInstruction) systemSettings_ai_gifCreatorAnimateInstruction.value = getAppInstruction('gifCreatorAnimate', DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION);

        updateApiKeyUI(); // This will show/hide the correct provider settings sections
        if (systemSettings_ai_saveModelButton) { systemSettings_ai_saveModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_modelNameInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalGeminiAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `Gemini Model set: ${newModel}. Re-init AI apps...`; initAllAiApps(); } else { if (systemSettings_status) systemSettings_status.textContent = "Gemini Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveGroqModelButton) { systemSettings_ai_saveGroqModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_groqModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalGroqAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `Groq Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Groq Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveOpenaiModelButton) { systemSettings_ai_saveOpenaiModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_openaiModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalOpenAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `OpenAI Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "OpenAI Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveGroqMaxTokensButton) { systemSettings_ai_saveGroqMaxTokensButton.addEventListener('click', () => { const newMaxTokens = parseInt(systemSettings_ai_groqMaxTokensInput.value, 10); if (!isNaN(newMaxTokens) && newMaxTokens > 0) { localStorage.setItem('k8os_globalGroqMaxTokens', newMaxTokens.toString()); if (systemSettings_status) systemSettings_status.textContent = `Groq Max Tokens set: ${newMaxTokens}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Invalid Groq Max Tokens value."; } }); }
        if (systemSettings_ai_saveOpenrouterModelButton) { systemSettings_ai_saveOpenrouterModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_openrouterModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalOpenRouterAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `OpenRouter Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "OpenRouter Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveXaiModelButton) { systemSettings_ai_saveXaiModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_xaiModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalXaiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `XAI Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "XAI Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveOpenrouterHttpRefererButton) { systemSettings_ai_saveOpenrouterHttpRefererButton.addEventListener('click', () => { const newReferer = systemSettings_ai_openrouterHttpRefererInput.value.trim(); localStorage.setItem('k8os_globalOpenRouterHttpReferer', newReferer); if (systemSettings_status) systemSettings_status.textContent = `OpenRouter Site URL saved.`; }); }
        if (systemSettings_ai_saveDeepseekModelButton) { systemSettings_ai_saveDeepseekModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_deepseekModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalDeepSeekAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `DeepSeek Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "DeepSeek Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveDeepseekMaxTokensButton) { systemSettings_ai_saveDeepseekMaxTokensButton.addEventListener('click', () => { const newMaxTokens = parseInt(systemSettings_ai_deepseekMaxTokensInput.value, 10); if (!isNaN(newMaxTokens) && newMaxTokens > 0) { localStorage.setItem('k8os_globalDeepSeekMaxTokens', newMaxTokens.toString()); if (systemSettings_status) systemSettings_status.textContent = `DeepSeek Max Tokens set: ${newMaxTokens}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Invalid DeepSeek Max Tokens value."; } }); }
        if (systemSettings_ai_saveHfModelButton) { systemSettings_ai_saveHfModelButton.addEventListener('click', () => { let newModelId = systemSettings_ai_hfModelIdInput.value.trim(); if (newModelId.endsWith('.')) { newModelId = newModelId.substring(0, newModelId.length - 1); console.warn("Trimmed trailing period from HF Model ID before saving. New ID:", newModelId); systemSettings_ai_hfModelIdInput.value = newModelId; } if (newModelId) { localStorage.setItem('k8os_globalHfModelId', newModelId); if (systemSettings_status) systemSettings_status.textContent = `Hugging Face Model ID set: ${newModelId}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Hugging Face Model ID cannot be empty."; } }); }
        if (systemSettings_ai_saveTransformersjsModelButton) { systemSettings_ai_saveTransformersjsModelButton.addEventListener('click', async () => {
            const newModelId = systemSettings_ai_transformersjsModelIdInput.value.trim();
            if (newModelId) {
                localStorage.setItem('k8os_globalTransformersJsModelId', newModelId);
                window.GLOBAL_TRANSFORMERSJS_MODEL_ID = newModelId;
                if (systemSettings_status) systemSettings_status.textContent = `Transformers.js Model ID set: ${newModelId}.`;
                enableAppButtons();
                if (systemSettings_transformersjs_status) systemSettings_transformersjs_status.textContent = `Preparing model ${newModelId}...`;
                try {
                    await ensureTransformersJsPipeline(newModelId, (progress) => {
                        if (systemSettings_transformersjs_status) {
                            systemSettings_transformersjs_status.textContent = `Loading ${newModelId}: ${Math.round(progress.progress)}% (${progress.file})`;
                        }
                    });
                    if (systemSettings_transformersjs_status) systemSettings_transformersjs_status.textContent = `Model ${newModelId} is ready.`;
                } catch (e) {
                    if (systemSettings_transformersjs_status) systemSettings_transformersjs_status.textContent = `Error preparing ${newModelId}: ${e.message.substring(0,100)}`;
                    console.error("Error preparing Transformers.js model from settings:", e);
                }
            } else {
                if (systemSettings_status) systemSettings_status.textContent = "Transformers.js Model ID cannot be empty.";
            }
        }); }
        if (systemSettings_ai_saveCustomSettingsButton) { systemSettings_ai_saveCustomSettingsButton.addEventListener('click', () => {
            const url = systemSettings_ai_customEndpointUrlInput.value.trim(); const modelId = systemSettings_ai_customModelIdInput.value.trim();
            if (url) { localStorage.setItem('k8os_globalCustomEndpointUrl', url); } else { localStorage.removeItem('k8os_globalCustomEndpointUrl'); }
            if (modelId) { localStorage.setItem('k8os_globalCustomModelId', modelId); } else { localStorage.removeItem('k8os_globalCustomModelId'); }
            if (systemSettings_status) systemSettings_status.textContent = `Custom Endpoint settings saved. URL: ${url || 'Not set'}. Model: ${modelId || 'Not set'}.`;
            enableAppButtons(); initAllAiApps();
        });}


        if(systemSettings_ai_saveVibeInstructionButton) systemSettings_ai_saveVibeInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_vibe', systemSettings_ai_vibeInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "Vibe instruction saved."; initVibeCreatorApp(); });
        if(systemSettings_ai_saveGameGenFinalInstructionButton) systemSettings_ai_saveGameGenFinalInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_gameGen_final', systemSettings_ai_gameGenFinalInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "Game Gen (Final) instruction saved."; });
        if(systemSettings_ai_saveMusicStudioInstructionButton) systemSettings_ai_saveMusicStudioInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_musicStudio', systemSettings_ai_musicStudioInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "Music Studio instruction saved."; initMusicStudioApp(); });
        if(systemSettings_ai_saveGifCreatorNewInstructionButton) systemSettings_ai_saveGifCreatorNewInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_gifCreatorNew', systemSettings_ai_gifCreatorNewInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "GIF Creator (New) instruction saved."; initGifCreatorApp(); });
        if(systemSettings_ai_saveGifCreatorAnimateInstructionButton) systemSettings_ai_saveGifCreatorAnimateInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_gifCreatorAnimate', systemSettings_ai_gifCreatorAnimateInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "GIF Creator (Animate) instruction saved."; initGifCreatorApp();});
        const tabs = document.querySelectorAll('#systemSettingsWindow .settings-tab'); const tabContents = document.querySelectorAll('#systemSettingsWindow .settings-tab-content');
        tabs.forEach(tab => { tab.addEventListener('click', () => { tabs.forEach(t => t.classList.remove('active')); tab.classList.add('active'); const targetContentId = "settingsContent_" + tab.dataset.tab; tabContents.forEach(content => { content.classList.toggle('active', content.id === targetContentId); }); }); });

        // --- Secret Theme Easter Egg ---
        if (localStorage.getItem('k8os_themes_unlocked') === 'true') {
            const secretSection = document.getElementById('secretThemeSection');
            if (secretSection) secretSection.style.display = 'block';
        }

        const aboutVersionEl = document.getElementById('systemSettings_about_version');
        if (aboutVersionEl) {
            let clickCount = 0;
            let clickTimer = null;
            aboutVersionEl.addEventListener('click', () => {
                clickCount++;
                if (clickTimer) clearTimeout(clickTimer);
                clickTimer = setTimeout(() => { clickCount = 0; }, 1000); // Reset after 1s
                if (clickCount >= 5) {
                    const secretSection = document.getElementById('secretThemeSection');
                    if (secretSection) {
                        secretSection.style.display = 'block';
                        localStorage.setItem('k8os_themes_unlocked', 'true');
                        if(systemSettings_status) systemSettings_status.textContent = "Secret themes unlocked!";
                    }
                    clickCount = 0;
                    clearTimeout(clickTimer);
                }
            });
        }

        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            themeSelect.value = localStorage.getItem('k8os_theme') || 'win95';
            themeSelect.addEventListener('change', (e) => {
                applyTheme(e.target.value);
            });
        }
    }
    function setDesktopBackground(color) {
        clearCustomImageBackground(false, false); document.body.style.backgroundColor = color;
        localStorage.setItem('k8os_desktopBgColor', color);
        if (systemSettings_status) systemSettings_status.textContent = `Background color set to ${color}.`;
    }
    function downloadFile(content, filename, contentType) { const blob = new Blob([content], { type: contentType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }

    if (vibe_generateButton) vibe_generateButton.addEventListener('click', vibe_handleGenerate);
    if (vibe_downloadButton) vibe_downloadButton.addEventListener('click', vibe_handleDownload);
    if(gifCreator_importSvgButton) gifCreator_importSvgButton.addEventListener('click', () => { if (vibe_currentContent && vibe_currentContentType === 'svg' && gifCreator_svgInput) { gifCreator_svgInput.value = vibe_currentContent; gifCreatorStatusUpdater("SVG imported from Vibe Creator."); } else { gifCreatorStatusUpdater("No SVG content in Vibe Creator to import."); } });
    if(gifCreator_generateButton) gifCreator_generateButton.addEventListener('click', async () => {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (!keyAvailable) { gifCreatorStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); return; }
        if (selectedApiProvider === 'gemini' && !gifCreator_genAI_model) { gifCreatorStatusUpdater("GIF Creator Gemini AI model not initialized."); return; }
        const newGifPrompt = gifCreator_promptInput.value.trim(); const existingSvgCode = gifCreator_svgInput.value.trim(); const animationPromptForExisting = gifCreator_animationPromptInput.value.trim();
        if (!newGifPrompt && !existingSvgCode) { gifCreatorStatusUpdater("Please provide a description for a new animation or import/paste SVG and provide animation instructions."); return; }
        if (existingSvgCode && !animationPromptForExisting) { gifCreatorStatusUpdater("Please provide animation instructions for the existing SVG."); return; }

        gifCreatorStatusUpdater("Generating...");
        if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = "<p>Generating animated SVG...</p>"; gifCreator_currentAnimatedSvg = null; if(gifCreator_downloadButton) gifCreator_downloadButton.style.display = 'none';
        let fullPrompt; let baseInstruction;
        if (existingSvgCode) { baseInstruction = getAppInstruction('gifCreatorAnimate', DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION); fullPrompt = baseInstruction.replace("{STATIC_SVG_CODE}", existingSvgCode).replace("{ANIMATION_PROMPT}", animationPromptForExisting); }
        else { baseInstruction = getAppInstruction('gifCreatorNew', DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION); fullPrompt = baseInstruction.replace("{USER_PROMPT}", newGifPrompt); }
        try {
            let animatedSvgText = await callCurrentAiProviderForText(fullPrompt, 80000, 0.4, gifCreatorStatusUpdater);
            if (animatedSvgText && animatedSvgText.startsWith("```svg")) animatedSvgText = animatedSvgText.substring(6).trim(); else if (animatedSvgText && animatedSvgText.startsWith("```")) animatedSvgText = animatedSvgText.substring(3).trim();
            if (animatedSvgText && animatedSvgText.endsWith("```")) animatedSvgText = animatedSvgText.substring(0, animatedSvgText.length - 3).trim();
            const svgMatch = animatedSvgText ? animatedSvgText.match(/<svg[\s\S]*?<\/svg>/im) : null;
            if (svgMatch && svgMatch[0]) { gifCreator_currentAnimatedSvg = svgMatch[0]; if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = gifCreator_currentAnimatedSvg; if(gifCreator_downloadButton) gifCreator_downloadButton.style.display = 'block'; gifCreatorStatusUpdater("Animated SVG Generated.");}
            else { 
    gifCreatorStatusUpdater(`AI (${selectedApiProvider}) did not return valid SVG code for animation. Check console.`); 
    if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = "<p style='color:red'>Failed to generate animated SVG.</p>"; 
    console.warn("Raw output from API for GIF:", animatedSvgText); 
}
} catch (e) { 
    console.error(`GIF Creator AI Error (${selectedApiProvider}):`, e); 
    gifCreatorStatusUpdater(`AI Error: ${e.message || String(e)}`); 
    if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = "<p style='color:red'>Error during generation.</p>"; 
}
finally { 
    enableAppButtons(); 
}
});

if(gifCreator_downloadButton) gifCreator_downloadButton.addEventListener('click', () => { 
    if (gifCreator_currentAnimatedSvg) { 
        let fileName = (gifCreator_promptInput.value.trim() || gifCreator_animationPromptInput.value.trim() || "animated_image").toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '_'); 
        downloadFile(gifCreator_currentAnimatedSvg, `${fileName}.svg`, "image/svg+xml;charset=utf-8"); 
    } else { 
        alert("No animated SVG to download."); 
    } 
});

function prepareGameHTMLWithLogger(htmlContent) { const errorLoggerScript = `<script> window.onerror = function(message, source, lineno, colno, error) { console.error("GameRuntimeError:", { message, source: source.substring(source.lastIndexOf('/') + 1), lineno, colno, error: error ? error.stack : 'N/A' }); return false; }; window.onunhandledrejection = function(event) { console.error("GameRuntimePromiseRejection:", { reason: event.reason ? (event.reason.message || event.reason) : 'Unknown reason', stack: event.reason ? event.reason.stack : 'N/A'}); }; <\/script>`; if (htmlContent.includes("</head>")) { return htmlContent.replace("</head>", errorLoggerScript + "</head>"); } else if (htmlContent.includes("<body>")) { return htmlContent.replace("<body>", errorLoggerScript + "<body>"); } return errorLoggerScript + htmlContent; }

    // REPLACE the old executeGameGeneration function with this one:
async function executeGameGeneration(userGameIdea, isDebugAttempt = false, existingCode = "", errorsAndHints = "") {
    const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                         (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                         (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                         (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                         (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                         (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                         (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
    if (!keyAvailable) { gameGen_displayError("API Key/Model ID/Endpoint URL not set for selected provider!"); return; }
    if (selectedApiProvider === 'gemini' && !gameGen_main_model) { gameGen_displayError("Gemini AI Model not ready!"); return; }
    gameGen_clearError(); const providerName = selectedApiProvider;

    const localGameGenStatusUpdater = (msg) => {
        if(gameGen_assetStatus) gameGen_assetStatus.textContent = msg;
        gameGenStatusUpdater(msg); // This updates the main window status bar
    };

    if (isDebugAttempt) {
        gameGen_showLoading("AI is attempting to fix your game...");
        localGameGenStatusUpdater(`Attempting to debug game code with ${providerName}...`);
        const debugInstruction = getAppInstruction('gameGen_debug', DEFAULT_GAMEGEN_DEBUG_INSTRUCTION).replace("{USER_GAME_IDEA}", gameGen_lastUserIdea || "the previously described game").replace("{ERRORS_AND_HINTS}", errorsAndHints).replace("{PROBLEM_CODE}", existingCode);
        try {
            let fixedHtml = await callCurrentAiProviderForText(debugInstruction, 8192, 0.5, localGameGenStatusUpdater);
            if (fixedHtml && fixedHtml.startsWith("```html")) fixedHtml = fixedHtml.substring(7).trim(); else if (fixedHtml && fixedHtml.startsWith("```")) fixedHtml = fixedHtml.substring(3).trim(); if (fixedHtml && fixedHtml.endsWith("```")) fixedHtml = fixedHtml.substring(0, fixedHtml.length - 3).trim();
            
            const fixedPackage = { html: fixedHtml, assets: gameGen_lastGameAssetPackage?.assets || [] };
             if (fixedPackage.html) {
                await processAndSaveGamePackage(fixedPackage, gameGen_lastUserIdea);
            } else {
                gameGen_displayError(`AI (${providerName}) did not return a valid HTML fix.`, true);
            }
        } catch (e) { console.error(`Game Debugging Error (${providerName}):`, e); let message = `Failed to debug game with ${providerName}. ${e.message || 'Unknown error.'}`; gameGen_displayError(message); }
        finally { gameGen_hideLoading(); }
    } else {
        gameGen_showLoading("AI is generating your game...");
        localGameGenStatusUpdater(`Generating game plan with ${providerName}...`); 
        if(gameGen_planDisplay) gameGen_planDisplay.textContent = "Generating game plan..."; 
        if(gameGen_assetStatus) gameGen_assetStatus.textContent = "";
        let gamePlan; let planResponseText = "";
        try {
            const planPrompt = DEFAULT_GAMEGEN_PLAN_INSTRUCTION.replace("{USER_GAME_IDEA}", userGameIdea);
            planResponseText = await callCurrentAiProviderForText(planPrompt, 2048, 0.3, localGameGenStatusUpdater);
            let cleanedJsonString = planResponseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
            const jsonStart = cleanedJsonString.indexOf('{'); const jsonEnd = cleanedJsonString.lastIndexOf('}');
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) { cleanedJsonString = cleanedJsonString.substring(jsonStart, jsonEnd + 1); }
            gamePlan = JSON.parse(cleanedJsonString);
            if (!gamePlan.game_mechanic || !Array.isArray(gamePlan.svg_assets) || !Array.isArray(gamePlan.sound_effects) ) {
                 throw new Error("The AI's game plan was missing required keys ('game_mechanic', 'svg_assets', 'sound_effects').");
            }
            let planDisplayText = `Game Mechanic: ${gamePlan.game_mechanic || 'N/A'}\nSVGs:\n`;
            (gamePlan.svg_assets || []).forEach(asset => planDisplayText += ` - ${asset.description || '??'} -> ${asset.filename || '??'}\n`);
            planDisplayText += `Sounds:\n`;
            (gamePlan.sound_effects || []).forEach(asset => planDisplayText += ` - ${asset.description || '??'} -> ${asset.filename || '??'}\n`);
            if(gameGen_planDisplay) gameGen_planDisplay.textContent = planDisplayText;
        } catch (e) { console.error("Error parsing game plan JSON:", e, "Raw response:", planResponseText); gameGen_displayError(`Failed to generate/parse game plan from ${providerName}. Check console. AI Response: ${(planResponseText || '').substring(0,200)}...`); gameGen_hideLoading(); return; }

        const assetFilenames = {
            svg: (gamePlan.svg_assets || []).map(a => a.filename).filter(Boolean),
            js: (gamePlan.sound_effects || []).map(a => a.filename).filter(Boolean)
        };

        localGameGenStatusUpdater(`Generating final game code with ${providerName}...`);
        const finalGamePrompt = getAppInstruction('gameGen_final', DEFAULT_GAMEGEN_FINAL_INSTRUCTION)
            .replace("{USER_GAME_IDEA}", userGameIdea)
            .replace("{GAME_PLAN_JSON}", JSON.stringify(gamePlan)) // Pass the whole plan
            .replace("{ASSET_FILENAMES_JSON}", JSON.stringify(assetFilenames));
        
        let gameHtml;
        try {
            gameHtml = await callCurrentAiProviderForText(finalGamePrompt, 8192, 0.7, localGameGenStatusUpdater);
            if (gameHtml && gameHtml.startsWith("```html")) gameHtml = gameHtml.substring(7).trim(); else if (gameHtml && gameHtml.startsWith("```")) gameHtml = gameHtml.substring(3).trim(); if (gameHtml && gameHtml.endsWith("```")) gameHtml = gameHtml.substring(0, gameHtml.length - 3).trim();
            
            if (!gameHtml || !gameHtml.toLowerCase().includes('<html')) {
                 throw new Error(`AI (${providerName}) did not return valid HTML for the game code.`);
            }
        } catch (e) {
            console.error(`Game Generator Final Code Error (${providerName}):`, e);
            gameGen_displayError(`Final code generation failed. ${e.message || 'Unknown error.'}`);
            gameGen_hideLoading();
            return;
        }

        const generatedAssets = [];
        localGameGenStatusUpdater(`Generating SVG assets with ${providerName}...`);
        for (let i = 0; i < gamePlan.svg_assets.length; i++) {
            const assetInfo = gamePlan.svg_assets[i]; if (!assetInfo || !assetInfo.description || !assetInfo.filename) continue;
            localGameGenStatusUpdater(`Generating SVG ${i+1}/${gamePlan.svg_assets.length}: ${assetInfo.description}...`);
            const svgCode = await internal_generateSingleSvg(assetInfo.description, !!assetInfo.animated, localGameGenStatusUpdater);
            if (svgCode) { generatedAssets.push({ filename: assetInfo.filename, content: svgCode, type: 'svg' }); }
            else { generatedAssets.push({ filename: assetInfo.filename, content: `<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="10" height="10" fill="red"/><text x="1" y="8" font-size="5" fill="white">X</text></svg>`, type: 'svg' }); localGameGenStatusUpdater(`SVG ${i+1} [Failed for: ${assetInfo.description}]`); console.warn(`Failed to generate SVG for: ${assetInfo.description}.`); }
        }

        localGameGenStatusUpdater(`Generating sound effect JS with ${providerName}...`);
        for (let i = 0; i < gamePlan.sound_effects.length; i++) {
             const assetInfo = gamePlan.sound_effects[i]; if (!assetInfo || !assetInfo.description || !assetInfo.filename) continue;
             localGameGenStatusUpdater(`Generating Sound JS ${i+1}/${gamePlan.sound_effects.length}: ${assetInfo.description}...`);
             const soundJsCode = await internal_generateSingleSoundJs(assetInfo.description, localGameGenStatusUpdater);
             if (soundJsCode) { generatedAssets.push({ filename: assetInfo.filename, content: soundJsCode, type: 'js' }); }
             else { generatedAssets.push({ filename: assetInfo.filename, content: `console.warn("Failed to generate sound JS for '${assetInfo.description.replace(/"/g, '\\"').replace(/'/g, "\\'")}' in game.");`, type: 'js' }); localGameGenStatusUpdater(`Sound JS ${i+1} [Failed for: ${assetInfo.description}]`); console.warn(`Failed to generate Sound JS for: ${assetInfo.description}.`); }
        }

        localGameGenStatusUpdater("All tasks complete!");
        const gamePackage = { html: gameHtml, assets: generatedAssets };
        await processAndSaveGamePackage(gamePackage, userGameIdea);
        gameGen_hideLoading();
    }
}

async function processAndSaveGamePackage(gamePackage, userGameIdea) {
    if (!gamePackage || !gamePackage.html || !gamePackage.html.toLowerCase().includes("<html")) {
        gameGen_displayError(`AI (${selectedApiProvider}) did not return valid HTML.`, true);
        if(gameGen_debugSection) gameGen_debugSection.style.display = 'none';
        return;
    }

    if (gameGen_generatedCodeTextarea) gameGen_generatedCodeTextarea.value = gamePackage.html;

    const gameName = userGameIdea.substring(0, 25).replace(/[^a-z0-9]/gi, '_') || 'generated-game';
    const gameFolderName = `${gameName}-${Date.now().toString(36)}`;

    const liveFolderId = ensureVFSPath('live/games');
    const gameFolder = createVFSEntry({ type: 'folder', name: gameFolderName, parentId: liveFolderId });
    const assetsFolder = createVFSEntry({ type: 'folder', name: 'assets', parentId: gameFolder.id });

    for (const asset of gamePackage.assets) {
        let mimeType = 'text/plain';
        if (asset.type === 'svg') mimeType = 'image/svg+xml';
        else if (asset.type === 'js') mimeType = 'application/javascript';
        createVFSEntry({ type: 'file', name: asset.filename, content: asset.content, mimeType: mimeType, parentId: assetsFolder.id });
    }
    const mainHtmlFile = createVFSEntry({ type: 'file', name: 'index.html', content: gamePackage.html, mimeType: 'text/html', parentId: gameFolder.id });

    gameGen_lastHtmlCode = gamePackage.html;
    gameGen_lastGameAssetPackage = { gameFolderId: gameFolder.id, assets: gamePackage.assets };
    if(gameGen_downloadZipButton) gameGen_downloadZipButton.style.display = 'block';
    if(gameGen_debugSection) gameGen_debugSection.style.display = 'block';
    
    gameGenStatusUpdater(`Game "${gameFolderName}" created in live/games!`);
    openNewBrowserWindow(null, mainHtmlFile.id); // Automatically open the game to play
    if (fe_fileListElement && (currentFEVfsPathId === liveFolderId || currentFEVfsPathId === gameFolder.id)) {
        renderVFSFileList(currentFEVfsPathId);
    }
}

if (gameGen_generateButton) gameGen_generateButton.addEventListener('click', async () => { gameGen_lastUserIdea = gameGen_promptInput.value.trim(); if (!gameGen_lastUserIdea) { gameGen_displayError("Please describe the game."); return; } const gamePackage = await executeGameGeneration(gameGen_lastUserIdea); if (gamePackage) { await processAndSaveGamePackage(gamePackage, gameGen_lastUserIdea); } });
if (gameGen_debugAttemptButton) gameGen_debugAttemptButton.addEventListener('click', async () => { const currentCode = gameGen_generatedCodeTextarea.value; const errorsAndHints = gameGen_debugCombinedInput.value.trim(); if (!currentCode) { gameGen_displayError("No game code to debug."); return; } if (!errorsAndHints) { gameGen_displayError("Please provide error messages or hints for debugging."); return; } const fixedPackage = await executeGameGeneration(gameGen_lastUserIdea, true, currentCode, errorsAndHints); if (fixedPackage) { await processAndSaveGamePackage(fixedPackage, gameGen_lastUserIdea); } });
if(gameGen_downloadZipButton) { gameGen_downloadZipButton.addEventListener('click', () => { if (gameGen_lastGameAssetPackage && gameGen_lastGameAssetPackage.gameFolderId) { downloadVFSEntryAsZip(gameGen_lastGameAssetPackage.gameFolderId); } else { alert("No game package generated to download."); } }); }

if(musicStudio_generateButton) musicStudio_generateButton.addEventListener('click', async () => {
    const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                         (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                         (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                         (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                         (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                         (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                         (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
    if (!keyAvailable) { musicStudioStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); return; }
    if (selectedApiProvider === 'gemini' && !musicStudio_genAI_model) { musicStudioStatusUpdater("Music Studio Gemini AI model not initialized."); return; }
    const userPrompt = musicStudio_promptInput.value.trim(); if (!userPrompt) { musicStudioStatusUpdater("Please describe the music."); return; }

    musicStudioStatusUpdater("Generating...");
    musicStudio_generatedCode.value = ""; musicStudio_playButton.disabled = true; musicStudio_stopButton.disabled = true; musicStudio_downloadJsButton.style.display = 'none';
    const baseInstruction = getAppInstruction('musicStudio', DEFAULT_MUSICSTUDIO_INSTRUCTION);
    const fullPrompt = baseInstruction.replace("{USER_PROMPT}", userPrompt);

    try {
        let text = await callCurrentAiProviderForText(fullPrompt, 16000, 0.6, musicStudioStatusUpdater);
        if (text && typeof text === 'string') {
            if (text.startsWith("```javascript")) text = text.substring(13).trim();
            else if (text.startsWith("```")) text = text.substring(3).trim();
            if (text.endsWith("```")) text = text.substring(0, text.length - 3).trim();
        } else {
            text = "";
        }
        if (text && text.trim().length > 10) {
            musicStudio_lastJsCode = text;
            musicStudio_generatedCode.value = text;
            musicStudio_playButton.disabled = false;
            musicStudio_downloadJsButton.style.display = 'block';
            musicStudioStatusUpdater("Music Code Generated.");

            // --- Auto-save to VFS ---
            try {
                const basePath = `live/music`;
                const targetFolderId = ensureVFSPath(basePath);
                
                const fileName = (userPrompt.substring(0, 25).replace(/[^a-z0-9]/gi, '_') || `music`) + `_${Date.now().toString(36)}.js`;

                createVFSEntry({
                    type: 'file',
                    name: fileName,
                    content: musicStudio_lastJsCode,
                    mimeType: 'application/javascript',
                    parentId: targetFolderId
                });

                // Update status bar with save location
                setTimeout(() => {
                    const currentStatus = musicStudio_errorDisplay.textContent;
                    if(currentStatus.includes("Generated")) {
                         musicStudioStatusUpdater(`Music Code Generated. Saved to ${basePath}/${fileName}`);
                    }
                }, 1000);

                // Refresh file explorer if it's open and showing a relevant directory
                const fileExplorerWindow = document.getElementById('fileExplorerWindow');
                if (fileExplorerWindow && fileExplorerWindow.style.display === 'flex') {
                    const ancestorId = getVFSEntry(targetFolderId)?.parentId; // live folder
                    if (currentFEVfsPathId === targetFolderId || currentFEVfsPathId === ancestorId) {
                        renderVFSFileList(currentFEVfsPathId);
                    }
                }

            } catch (vfsError) {
                console.error("VFS auto-save error (Music):", vfsError);
                musicStudio_errorDisplay.textContent += ` | VFS Save Failed: ${vfsError.message}`;
            }
            // --- End Auto-save ---
        } else {
            musicStudio_lastJsCode = "";
            musicStudio_generatedCode.value = "";
            musicStudioStatusUpdater("AI returned empty or invalid code. Check console.");
            console.warn("Music Studio: AI returned insufficient code.", text);
        }
    } catch (e) {
        console.error(`Music Studio AI Error (${selectedApiProvider}):`, e);
        musicStudioStatusUpdater(`AI Error: ${e.message || String(e)}`);
        musicStudio_lastJsCode = "";
        musicStudio_generatedCode.value = "";
    }
    finally { enableAppButtons(); }
});

function stopAllMusicStudioSounds() {
    if (musicStudio_currentAudioContext && musicStudio_currentAudioContext.state !== 'closed') {
        musicStudio_currentAudioContext.close().catch(e => console.error("Error closing previous AudioContext:", e));
    }
    musicStudio_currentAudioContext = null;
    musicStudio_activeSources.forEach(source => {
        try {
            if(source && typeof source.stop === 'function') source.stop();
            if(source && typeof source.disconnect === 'function') source.disconnect();
        } catch(e){ console.warn("Error stopping/disconnecting audio source:", e); }
    });
    musicStudio_activeSources = [];
    if(musicStudio_stopButton) musicStudio_stopButton.disabled = true;
    // Re-enable play button only if there is code to be played
    if(musicStudio_playButton && musicStudio_generatedCode.value.trim()) {
        musicStudio_playButton.disabled = false;
    }
}
if(musicStudio_playButton) musicStudio_playButton.addEventListener('click', () => {
    const code = musicStudio_generatedCode.value;
    if (code) {
        stopAllMusicStudioSounds(); // Stop any previous sounds first
        try {
            // IMPORTANT: Create the AudioContext on user interaction (the click)
            musicStudio_currentAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            musicStudio_activeSources = [];
            
            const soundFunction = new Function('audioContext', 'activeSources', code);
            soundFunction(musicStudio_currentAudioContext, musicStudio_activeSources);
            
            logK8osActivity("Music Studio", `Played music: ${musicStudio_promptInput.value.trim().substring(0,50)}...`);
            musicStudioStatusUpdater("Playing...");
            musicStudio_stopButton.disabled = false; // Always enable stop when play is successful
            musicStudio_playButton.disabled = true;
        } catch (e) {
            console.error("Error playing music:", e);
            musicStudioStatusUpdater("Playback Error: " + (e.message || String(e)) );
            stopAllMusicStudioSounds(); // Clean up on error
        }
    }
});
if(musicStudio_stopButton) musicStudio_stopButton.addEventListener('click', stopAllMusicStudioSounds);
if(musicStudio_downloadJsButton) musicStudio_downloadJsButton.addEventListener('click', () => { if (musicStudio_lastJsCode) { let fileName = musicStudio_promptInput.value.trim().toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '_') || "music_script"; downloadFile(musicStudio_lastJsCode, `${fileName}.js`, "application/javascript"); } else { alert("No music code generated yet."); } });

if(gamePlayer_refreshButton) gamePlayer_refreshButton.addEventListener('click', () => { if (gameGen_lastHtmlCode && gamePlayerWindow_iframe) { const htmlWithLogger = prepareGameHTMLWithLogger(gameGen_lastHtmlCode); gamePlayerWindow_iframe.srcdoc = htmlWithLogger; logK8osActivity("Game Player", `Refreshed game: ${gameGen_lastUserIdea.substring(0,50)}...`); } else { alert("No game loaded to refresh."); } });

function createBrowserWindowHTML(instanceId, initialTitle = "🌐 Web Browser") { return ` <div class="title-bar"> <span class="title-bar-text" id="${instanceId}_titleBarText">${initialTitle}</span> <div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div> </div> <div id="${instanceId}_navControls" class="webBrowserWindow_navControls"> <button id="${instanceId}_backButton" title="Back" disabled>3</button> <button id="${instanceId}_forwardButton" title="Forward" disabled>4</button> <button id="${instanceId}_refreshButton" title="Refresh">Q</button> <input type="text" id="${instanceId}_addressBar" class="webBrowserWindow_addressBar" placeholder="Enter URL or VFS path (/file.html)"> <button id="${instanceId}_goButton" style="width:auto;padding-left:5px;padding-right:5px;">Go</button> </div> <div class="window-content"> <iframe id="${instanceId}_iframeContent" class="webBrowserWindow_iframeContent" sandbox="allow-scripts allow-forms allow-popups allow-same-origin"></iframe> </div> <div id="${instanceId}_status" class="status-bar">Status: Idle</div> `; }
function openNewBrowserWindow(initialUrl = null, vfsFileId = null) {
    browserWindowCounter++; const instanceId = `webBrowserWindow-${browserWindowCounter}`;
    const windowEl = document.createElement('div'); windowEl.id = instanceId; windowEl.className = 'window webBrowserWindow';
    const topOffset = 40 + (browserWindowCounter % 10) * 20; const leftOffset = 300 + (browserWindowCounter % 10) * 20;
    windowEl.style.width = '800px'; windowEl.style.height = '600px'; windowEl.style.top = `${topOffset}px`; windowEl.style.left = `${leftOffset}px`;
    windowEl.innerHTML = createBrowserWindowHTML(instanceId); desktopElement.appendChild(windowEl); initializeWindowBehavior(windowEl);
    const instance = { id: instanceId, windowElement: windowEl, iframe: document.getElementById(`${instanceId}_iframeContent`), addressBar: document.getElementById(`${instanceId}_addressBar`), backButton: document.getElementById(`${instanceId}_backButton`), forwardButton: document.getElementById(`${instanceId}_forwardButton`), refreshButton: document.getElementById(`${instanceId}_refreshButton`), goButton: document.getElementById(`${instanceId}_goButton`), status: document.getElementById(`${instanceId}_status`), titleBarTextElement: document.getElementById(`${instanceId}_titleBarText`), history: [], historyIndex: -1 };
    browserInstances[instanceId] = instance;
    instance.goButton.addEventListener('click', () => navigateToUrlInBrowserInstance(instanceId, instance.addressBar.value.trim()));
    instance.addressBar.addEventListener('keypress', (e) => { if (e.key === 'Enter') navigateToUrlInBrowserInstance(instanceId, instance.addressBar.value.trim()); });
    instance.backButton.addEventListener('click', () => webBrowserNavigateInstance(instanceId, -1));
    instance.forwardButton.addEventListener('click', () => webBrowserNavigateInstance(instanceId, 1));
    instance.refreshButton.addEventListener('click', () => { if (instance.historyIndex > -1 && instance.history[instance.historyIndex]) { loadUrlInBrowserInstance(instanceId, instance.history[instance.historyIndex], false); logK8osActivity(`Browser (${instanceId})`, `Refreshed: ${instance.history[instance.historyIndex].substring(0,50)}...`); } });

    let targetUrl = initialUrl;
    if (vfsFileId) {
        const fileEntry = getVFSEntry(vfsFileId);
        if (fileEntry && (fileEntry.mimeType === 'text/html' || fileEntry.name.endsWith('.html') || fileEntry.name.endsWith('.htm'))) {
            targetUrl = `vfs://${vfsFileId}/${fileEntry.name}`;
            if (instance.titleBarTextElement) instance.titleBarTextElement.textContent = `🌐 ${fileEntry.name}`;
        }
    }
    openWindow(instanceId);
    if (targetUrl) { navigateToUrlInBrowserInstance(instanceId, targetUrl); }
    updateWebBrowserNavButtonsInstance(instanceId); return windowEl;
}
async function loadUrlInBrowserInstance(instanceId, url, addToHistory = true) {
    const instance = browserInstances[instanceId];
    if (!instance || !instance.iframe || !instance.status || !instance.addressBar) { console.error(`Browser instance ${instanceId} not found or incomplete.`); return; }
    instance.status.textContent = `Loading: ${url}...`; instance.addressBar.value = url; instance.iframe.srcdoc = '';

    try {
        if (url.startsWith('vfs://')) {
            const parts = url.substring(6).split('/');
            const fileId = parts[0];
            const fileEntry = getVFSEntry(fileId);
            if (fileEntry && (fileEntry.mimeType === 'text/html' || fileEntry.name.endsWith('.html') || fileEntry.name.endsWith('.htm'))) {
                instance.iframe.srcdoc = fileEntry.content;
                instance.status.textContent = `Loaded from VFS: ${fileEntry.name}`;
                if (instance.titleBarTextElement) instance.titleBarTextElement.textContent = `🌐 ${fileEntry.name}`;
                logK8osActivity(`Browser (${instanceId})`, `Navigated (VFS): ${fileEntry.name}`);
            } else {
                throw new Error(`VFS file not found or not HTML: ${url}`);
            }
        } else {
            let fetchUrl = url;
            const isLikelyExternal = url.startsWith('http://') || url.startsWith('https://');
            const isFileProtocol = url.startsWith('file:///'); const isK8osLocal = window.location.protocol === 'file:';
            if (isFileProtocol || (isK8osLocal && !isLikelyExternal)) {
                instance.status.textContent = `Attempting to load (direct): ${url}`; instance.iframe.src = url;
                setTimeout(() => { if (instance.status.textContent.startsWith('Attempting')) { instance.status.textContent = `Attempted direct load: ${url}`; logK8osActivity(`Browser (${instanceId})`, `Navigated (direct): ${url.substring(0,50)}...`); } }, 1000);
            } else {
                let proxyUrl = `https://polished-meadow-feb5.k8o5kebab-3ac.workers.dev/?url=${encodeURIComponent(url)}`;
                if (!isLikelyExternal && !url.startsWith('/')) { 
                    proxyUrl = `https://polished-meadow-feb5.k8o5kebab-3ac.workers.dev/?url=${encodeURIComponent(window.location.origin + '/' + url)}`;
                 }
                const response = await fetch(proxyUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${proxyUrl}`);
                const htmlContent = await response.text(); let finalHtml = htmlContent;
                const pathSegments = url.split('/');
                const hasSubDirs = !isLikelyExternal && pathSegments.length > 1 && !pathSegments[pathSegments.length-1].includes('.');
                if (hasSubDirs && !htmlContent.toLowerCase().includes("<base")) {
                    let basePath = pathSegments.slice(0, pathSegments[pathSegments.length -1] === '' ? -2 : -1).join('/') + '/';
                     if (url.startsWith(window.location.origin)) { basePath = new URL(basePath, window.location.href).pathname; }
                     else if (!url.startsWith('http')) { basePath = '/' + basePath; }
                    if (finalHtml.includes("<head>")) { finalHtml = finalHtml.replace("<head>", `<head>\n<base href="${basePath}">`); }
                    else { finalHtml = `<head><base href="${basePath}"></head>` + finalHtml; }
                }
                instance.iframe.srcdoc = finalHtml; instance.status.textContent = `Loaded: ${url}`;
                logK8osActivity(`Browser (${instanceId})`, `Navigated (fetch): ${url.substring(0,50)}...`);
            }
             if (instance.titleBarTextElement) {
                let pageTitle = url; try { const tempDoc = instance.iframe.contentDocument || instance.iframe.contentWindow.document; if (tempDoc && tempDoc.title) { pageTitle = tempDoc.title; } } catch (e) { /* ignore */ }
                instance.titleBarTextElement.textContent = `🌐 ${pageTitle.substring(0, 50)}${pageTitle.length > 50 ? '...' : ''}`;
            }
        }

        if (addToHistory) {
            if (instance.historyIndex < instance.history.length - 1) { instance.history = instance.history.slice(0, instance.historyIndex + 1); }
            instance.history.push(url); instance.historyIndex = instance.history.length - 1;
        }
    } catch (error) { console.error(`Error loading URL in browser app (${instanceId}):`, error, "URL:", url); instance.iframe.srcdoc = `<p style="color:red;padding:10px;">Error loading page: ${url}<br>${error.message || String(error)}<br><small>Note: Loading local 'file:///' URLs directly has security restrictions. For best results with local files, serve k8OS and your files from a local HTTP server.</small></p>`; instance.status.textContent = `Error: ${error.message || String(error)}`; }
    updateWebBrowserNavButtonsInstance(instanceId);
}
function navigateToUrlInBrowserInstance(instanceId, url) { if (url) loadUrlInBrowserInstance(instanceId, url, true); }
function webBrowserNavigateInstance(instanceId, direction) {
    const instance = browserInstances[instanceId]; if (!instance) return;
    const newIndex = instance.historyIndex + direction;
    if (newIndex >= 0 && newIndex < instance.history.length) { instance.historyIndex = newIndex; loadUrlInBrowserInstance(instanceId, instance.history[instance.historyIndex], false); logK8osActivity(`Browser (${instanceId})`, `Used ${direction > 0 ? 'Forward' : 'Back'} to: ${instance.history[instance.historyIndex].substring(0,50)}...`); }
}
function updateWebBrowserNavButtonsInstance(instanceId) { const instance = browserInstances[instanceId]; if (!instance) return; instance.backButton.disabled = instance.historyIndex <= 0; instance.forwardButton.disabled = instance.historyIndex >= instance.history.length - 1; }

if(startButton) startButton.addEventListener('click', (e) => { e.stopPropagation(); startMenu.style.display = startMenu.style.display === 'flex' ? 'none' : 'flex'; hideContextMenu(); });
if(startMenuUpdate) startMenuUpdate.addEventListener('click', () => { startMenu.style.display = 'none'; if (confirm("Are you sure you want to update? This will fetch the latest version of k8OS and reload the page.")) { location.reload(true); } });
if(startMenuShutdown) startMenuShutdown.addEventListener('click', () => { startMenu.style.display = 'none'; if (confirm("Are you sure you want to shut down k8OS?")) { document.body.innerHTML = '<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:black;color:white;display:flex;justify-content:center;align-items:center;font-size:24px;">k8OS is shutting down...</div>'; setTimeout(() => { window.close(); }, 2000); } });
if(startMenuReboot) startMenuReboot.addEventListener('click', () => { startMenu.style.display = 'none'; if (confirm("Are you sure you want to reboot k8OS?")) { rebootOverlay.style.display = 'flex'; rebootProgressText.textContent = "Closing applications..."; document.querySelectorAll('.window').forEach(w => closeWindow(w)); const rebootSteps = [ { delay: 700, text: "System integrity check..." }, { delay: 1200, text: "Loading kernel modules..." }, { delay: 1000, text: "Initializing desktop..." }, { delay: 800, text: "Mounting file systems..." }, { delay: 600, text: "Starting services..." }, { delay: 500, text: "Finalizing..." }, { delay: 400, text: "System ready." } ]; let currentStepIndex = 0; function processNextStep() { if (currentStepIndex < rebootSteps.length) { rebootProgressText.textContent = rebootSteps[currentStepIndex].text; setTimeout(processNextStep, rebootSteps[currentStepIndex].delay); currentStepIndex++; } else { rebootOverlay.style.display = 'none'; document.querySelectorAll('.desktop-icon.selected').forEach(i => i.classList.remove('selected')); k8osActivityLog = []; loadApiKey(); openWindow('apiKeySettingsWindow'); } } setTimeout(processNextStep, 500); } });
if(startMenuFactoryReset) startMenuFactoryReset.addEventListener('click', () => { startMenu.style.display = 'none'; handleFactoryReset(); });

function handleFactoryReset() {
    if (!confirm("DANGER ZONE!\n\nAre you absolutely sure you want to factory reset k8OS?\n\nALL data (API keys, files, settings, Sparky's memory) will be PERMANENTLY ERASED.\nThis action cannot be undone.")) {
        return;
    }
    console.warn("FACTORY RESET INITIATED!");
    if(assistantIsVisible) updateAssistantSpeech("Resetting... Bye! :(", false, false, true);

    const keysToClear = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('k8os_') ||
            ['GlobalGeminiApiKey', 'GlobalGroqApiKey', 'GlobalOpenRouterApiKey', 'GlobalDeepSeekApiKey', 'GlobalHfToken',
             'GlobalCustomApiKey',
             'desktopBgColor', 'desktopBgImageUrl', 'desktopBgImageSize',
             'desktopBgImageRepeat', 'desktopIconScaleFactor'].includes(key))
           ) {
            keysToClear.push(key);
        }
    }
    keysToClear.forEach(key => {
        console.log("Clearing localStorage key:", key);
        localStorage.removeItem(key);
    });

    sessionStorage.clear();

    if (rebootOverlay && rebootProgressText) {
        rebootOverlay.style.display = 'flex';
        rebootProgressText.textContent = "Factory Resetting System... Wiping data...";
    }

    setTimeout(() => {
        if (rebootProgressText) rebootProgressText.textContent = "Reloading k8OS...";
        setTimeout(() => {
            location.reload(true);
        }, 1500);
    }, 2000);
}

    const textEditorAssistModal = document.getElementById('textEditorAssistModal');
    const textEditorAssist_userInput = document.getElementById('textEditorAssist_userInput');
    const textEditorAssist_getSuggestionsButton = document.getElementById('textEditorAssist_getSuggestionsButton');
    const textEditorAssist_acceptButton = document.getElementById('textEditorAssist_acceptButton');
    const textEditorAssist_rejectButton = document.getElementById('textEditorAssist_rejectButton');
    const textEditorAssist_closeButton = document.getElementById('textEditorAssist_closeButton');
    const textEditorAssist_status = document.getElementById('textEditorAssist_status');
    const textEditorAssist_diffContainer = document.getElementById('textEditorAssist_diffContainer');

    // Sparky Image Attachment Elements
    const sparky_attachFileButton = document.getElementById('sparky_attachFileButton');
    const sparky_fileInput = document.getElementById('sparky_fileInput');
    const sparky_imagePreviewContainer = document.getElementById('sparky_imagePreviewContainer');
    const sparkyAssist_attachFileButton = document.getElementById('sparkyAssist_attachFileButton');
    const sparkyAssist_fileInput = document.getElementById('sparkyAssist_fileInput');
    const sparkyAssist_imagePreviewContainer = document.getElementById('sparkyAssist_imagePreviewContainer');


    function handleImageAttachment(file, previewContainer, fileStateSetter) {
        if (!file || !file.type.startsWith('image/')) {
            console.warn("Invalid file type. Please select an image.");
            // Optionally, update a status bar to inform the user.
            return;
        }

        fileStateSetter(file); // Store the file object

        const reader = new FileReader();
        reader.onload = (e) => {
            previewContainer.innerHTML = ''; // Clear previous preview
            
            const img = document.createElement('img');
            img.src = e.target.result;
            img.className = 'sparky-image-preview-thumbnail';

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '&times;'; // Use a nicer 'X'
            removeBtn.className = 'sparky-remove-image-button';
            removeBtn.title = 'Remove Image';
            removeBtn.onclick = () => {
                previewContainer.style.display = 'none';
                previewContainer.innerHTML = '';
                fileStateSetter(null); // Clear the stored file
            };

            previewContainer.appendChild(img);
            previewContainer.appendChild(removeBtn);
            previewContainer.style.display = 'block';
        };
        reader.readAsDataURL(file);
    }


    function generateDiffHtml(original, modified) {
        const originalLines = original.split('\\n');
        const modifiedLines = modified.split('\\n');
        const lcsMatrix = Array(originalLines.length + 1).fill(null).map(() => Array(modifiedLines.length + 1).fill(0));

        for (let i = 1; i <= originalLines.length; i++) {
            for (let j = 1; j <= modifiedLines.length; j++) {
                if (originalLines[i - 1] === modifiedLines[j - 1]) {
                    lcsMatrix[i][j] = 1 + lcsMatrix[i - 1][j - 1];
                } else {
                    lcsMatrix[i][j] = Math.max(lcsMatrix[i - 1][j], lcsMatrix[i][j - 1]);
                }
            }
        }

        let i = originalLines.length;
        let j = modifiedLines.length;
        const diff = [];

        while (i > 0 || j > 0) {
            if (i > 0 && j > 0 && originalLines[i - 1] === modifiedLines[j - 1]) {
                diff.unshift({ type: 'common', line: originalLines[i - 1] });
                i--;
                j--;
            } else if (j > 0 && (i === 0 || lcsMatrix[i][j - 1] >= lcsMatrix[i - 1][j])) {
                diff.unshift({ type: 'added', line: modifiedLines[j - 1] });
                j--;
            } else if (i > 0 && (j === 0 || lcsMatrix[i][j - 1] < lcsMatrix[i - 1][j])) {
                diff.unshift({ type: 'deleted', line: originalLines[i - 1] });
                i--;
            } else {
                break; 
            }
        }
        
        function escapeHtml(text) {
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        return diff.map(item => {
            const line = escapeHtml(item.line || ' ');
            if (item.type === 'added') return `<ins>+ ${line}</ins>`;
            if (item.type === 'deleted') return `<del>- ${line}</del>`;
            return `<div>  ${line}</div>`;
        }).join('');
    }

    function openTextEditorAssistModal() {
        if (!textEditorAssistModal) return;
        
        // Reset to initial state
        textEditorAssist_userInput.value = '';
        textEditorAssist_status.textContent = "Status: Awaiting instructions.";
        textEditorAssist_diffContainer.innerHTML = '<!-- Diff will be generated here -->';
        
        textEditorAssist_getSuggestionsButton.style.display = 'block';
        textEditorAssist_acceptButton.style.display = 'none';
        textEditorAssist_rejectButton.style.display = 'none';

        textEditorAssistModal.style.display = 'flex';
        bringToFront(textEditorAssistModal);
    }

    function closeTextEditorAssistModal() {
        if (textEditorAssistModal) textEditorAssistModal.style.display = 'none';
        // Reset image state when closing
        if (sparkyAssist_imagePreviewContainer) {
            sparkyAssist_imagePreviewContainer.style.display = 'none';
            sparkyAssist_imagePreviewContainer.innerHTML = '';
        }
        sparkyAssist_lastImageFile = null;
    }

    if (textEditor_sparkyAssistButton) {
        textEditor_sparkyAssistButton.addEventListener('click', () => {
            const editorContent = textEditor_contentArea.value;
            // Removed the check for empty editor content, as user might want to use an image with an empty editor.
            // if (editorContent.trim() === '') {
            //     textEditor_status.textContent = "Sparky Assist: Editor is empty. Please enter some code first.";
            //     return;
            // }
            openTextEditorAssistModal();
        });
    }

    // --- Sparky Image Attachment Event Listeners ---
    if (sparky_attachFileButton) {
        sparky_attachFileButton.addEventListener('click', () => sparky_fileInput.click());
    }
    if (sparky_fileInput) {
        sparky_fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                handleImageAttachment(e.target.files[0], sparky_imagePreviewContainer, (file) => { sparky_lastImageFile = file; });
            }
        });
    }
    const assistantInputContainer = document.getElementById('k8osAssistant_inputContainer');
    if (assistantInputContainer) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            assistantInputContainer.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            assistantInputContainer.addEventListener(eventName, () => {
                assistantInputContainer.style.backgroundColor = 'var(--win95-dark-gray)';
            }, false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            assistantInputContainer.addEventListener(eventName, () => {
                assistantInputContainer.style.backgroundColor = '';
            }, false);
        });
        assistantInputContainer.addEventListener('drop', (e) => {
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleImageAttachment(e.dataTransfer.files[0], sparky_imagePreviewContainer, (file) => { sparky_lastImageFile = file; });
            }
        });
    }

    // --- Sparky Assist Image Attachment Event Listeners ---
    if (sparkyAssist_attachFileButton) {
        sparkyAssist_attachFileButton.addEventListener('click', () => sparkyAssist_fileInput.click());
    }
    if (sparkyAssist_fileInput) {
        sparkyAssist_fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                handleImageAttachment(e.target.files[0], sparkyAssist_imagePreviewContainer, (file) => { sparkyAssist_lastImageFile = file; });
            }
        });
    }
    const textEditorAssistInputSection = document.getElementById('textEditorAssist_inputSection');
    if (textEditorAssistInputSection) {
         ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            textEditorAssistInputSection.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            textEditorAssistInputSection.addEventListener(eventName, () => {
                textEditorAssistInputSection.style.backgroundColor = 'var(--win95-dark-gray)';
            }, false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            textEditorAssistInputSection.addEventListener(eventName, () => {
                textEditorAssistInputSection.style.backgroundColor = '';
            }, false);
        });
        textEditorAssistInputSection.addEventListener('drop', (e) => {
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleImageAttachment(e.dataTransfer.files[0], sparkyAssist_imagePreviewContainer, (file) => { sparkyAssist_lastImageFile = file; });
            }
        });
    }

    let textEditorAssist_originalCode = '';
    let textEditorAssist_suggestedCode = '';
    let textEditorAssist_isSelection = false;
    let textEditorAssist_selectionStart = 0;
    let textEditorAssist_selectionEnd = 0;

    const DEFAULT_SPARKY_REWRITE_CODE_PROMPT = `You are an expert AI programmer. Rewrite the following code block based on the user's instruction.
IMPORTANT: Respond ONLY with the complete, raw, rewritten code block. Do not add explanations, comments, or markdown formatting.

User's instruction: "{USER_INSTRUCTION}"

Code to rewrite:
\`\`\`
{CODE_TO_REWRITE}
\`\`\`

Rewritten code:`;

    if (textEditorAssist_getSuggestionsButton) {
        textEditorAssist_getSuggestionsButton.addEventListener('click', async () => {
            const userInstruction = textEditorAssist_userInput.value.trim();
            if (!userInstruction && !sparkyAssist_lastImageFile) {
                textEditorAssist_status.textContent = "Status: Please provide an instruction or attach an image.";
                return;
            }

            textEditorAssist_selectionStart = textEditor_contentArea.selectionStart;
            textEditorAssist_selectionEnd = textEditor_contentArea.selectionEnd;
            textEditorAssist_isSelection = textEditorAssist_selectionStart !== textEditorAssist_selectionEnd;
            
            const codeToRewrite = textEditorAssist_isSelection 
                ? textEditor_contentArea.value.substring(textEditorAssist_selectionStart, textEditorAssist_selectionEnd)
                : textEditor_contentArea.value;

            textEditorAssist_originalCode = codeToRewrite;

            textEditorAssist_status.textContent = "Status: AI is thinking...";
            textEditorAssist_getSuggestionsButton.disabled = true;
            textEditorAssist_diffContainer.innerHTML = '<i>Sparky is thinking...</i>';

            let aiResponse = '';

            try {
                if (sparkyAssist_lastImageFile) {
                    // Multimodal path
                    const imageFile = sparkyAssist_lastImageFile;
                    const base64Data = await getBase64(imageFile);
                    const mimeType = imageFile.type;

                    const fullPrompt = DEFAULT_SPARKY_ASSIST_MULTIMODAL_PROMPT
                        .replace("{USER_INSTRUCTION}", userInstruction)
                        .replace("{CODE_TO_REWRITE}", codeToRewrite);
                    
                    // We construct the parts array manually for Gemini/OpenRouter
                    const contentParts = [
                        { text: fullPrompt },
                        { inline_data: { data: base64Data, mime_type: mimeType } }
                    ];

                    aiResponse = await callCurrentAiProviderForMultimodal(
                        null, // systemPromptTemplate is not used when contentParts is provided
                        null, // userPromptText is not used
                        null, // imageBase64 is not used
                        null, // imageMimeType is not used
                        contentParts
                    );
                } else {
                    // Text-only path
                    const fullPrompt = DEFAULT_SPARKY_REWRITE_CODE_PROMPT
                        .replace("{USER_INSTRUCTION}", userInstruction)
                        .replace("{CODE_TO_REWRITE}", codeToRewrite);
                    
                    aiResponse = await callCurrentAiProviderForText(fullPrompt, 8000, 0.2, (msg) => { textEditorAssist_status.textContent = `Status: ${msg}`; });
                }

                // Clean up markdown fences if the model adds them
                if (aiResponse.startsWith("```")) {
                    const firstNewLine = aiResponse.indexOf('\n') + 1;
                    const lastFence = aiResponse.lastIndexOf("```");
                    if (lastFence > firstNewLine) {
                         aiResponse = aiResponse.substring(firstNewLine, lastFence).trim();
                    }
                }

                textEditorAssist_suggestedCode = aiResponse;
                const diffHtml = generateDiffHtml(textEditorAssist_originalCode, textEditorAssist_suggestedCode);
                textEditorAssist_diffContainer.innerHTML = diffHtml;

                textEditorAssist_getSuggestionsButton.style.display = 'none';
                textEditorAssist_acceptButton.style.display = 'block';
                textEditorAssist_rejectButton.style.display = 'block';
                textEditorAssist_status.textContent = "Status: Review the suggested changes.";

            } catch (error) {
                console.error("Error during AI code suggestion:", error);
                textEditorAssist_status.textContent = `Error: ${error.message}`;
                textEditorAssist_diffContainer.innerHTML = `<p style="color:red">An error occurred while generating suggestions.</p>`;
            } finally {
                // Clear the image state regardless of success or failure
                if (sparkyAssist_lastImageFile) {
                    sparkyAssist_lastImageFile = null;
                    if(sparkyAssist_imagePreviewContainer) {
                        sparkyAssist_imagePreviewContainer.style.display = 'none';
                        sparkyAssist_imagePreviewContainer.innerHTML = '';
                    }
                }
                textEditorAssist_getSuggestionsButton.disabled = false;
            }
        });
    }

    if (textEditorAssist_acceptButton) {
        textEditorAssist_acceptButton.addEventListener('click', () => {
            if (textEditorAssist_isSelection) {
                const fullText = textEditor_contentArea.value;
                const before = fullText.substring(0, textEditorAssist_selectionStart);
                const after = fullText.substring(textEditorAssist_selectionEnd);
                textEditor_contentArea.value = before + textEditorAssist_suggestedCode + after;
            } else {
                textEditor_contentArea.value = textEditorAssist_suggestedCode;
            }
            textEditor_status.textContent = "Status: Changes applied!";
            logK8osActivity("Text Editor", `Accepted AI suggestion for: ${textEditorAssist_userInput.value.trim().substring(0,50)}...`);
            closeTextEditorAssistModal();
        });
    }
    if (textEditorAssist_rejectButton) textEditorAssist_rejectButton.addEventListener('click', closeTextEditorAssistModal);
    if (textEditorAssist_closeButton) textEditorAssist_closeButton.addEventListener('click', closeTextEditorAssistModal);

    function applyCodeEdits(originalCode, edits) {
        if (!Array.isArray(edits)) {
            throw new Error("Invalid edits format from AI. Expected an array.");
        }

        let lines = originalCode.split('\\n');

        // Sort edits in reverse order of line number to avoid index shifting issues
        edits.sort((a, b) => (b.line_start || b.line_after) - (a.line_start || a.line_after));

        for (const edit of edits) {
            // Adjust for 0-based array indexing
            const start = edit.line_start ? edit.line_start - 1 : undefined;
            const end = edit.line_end ? edit.line_end - 1 : undefined;
            const after = edit.line_after ? edit.line_after -1 : undefined;

            const contentLines = edit.content ? edit.content.split('\\n') : [];

            switch (edit.action) {
                case 'replace':
                    if (start === undefined || end === undefined) throw new Error("Invalid 'replace' op: missing line_start or line_end.");
                    lines.splice(start, end - start + 1, ...contentLines);
                    break;
                case 'delete':
                    if (start === undefined || end === undefined) throw new Error("Invalid 'delete' op: missing line_start or line_end.");
                    lines.splice(start, end - start + 1);
                    break;
                case 'insert':
                    if (after === undefined) throw new Error("Invalid 'insert' op: missing line_after.");
                    lines.splice(after + 1, 0, ...contentLines);
                    break;
                default:
                    console.warn(`Unknown edit action: ${edit.action}`);
            }
        }

        textEditor_contentArea.value = lines.join('\\n');
    }

function initSparkyDynamicBehavior() {
    if (assistantContainer && assistantIsVisible) {
        const desktopWidth = desktopElement.clientWidth;
        const desktopHeight = desktopElement.clientHeight;
        const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;

        if (!assistantContainer.style.left || !assistantContainer.style.top) {
             sparkyPosX = Math.random() * (desktopWidth - SPARKY_CONTAINER_WIDTH);
             sparkyPosY = Math.random() * (desktopHeight - SPARKY_CONTAINER_HEIGHT - taskbarHeight);
             assistantContainer.style.left = sparkyPosX + 'px';
             assistantContainer.style.top = sparkyPosY + 'px';
        } else {
            sparkyPosX = parseFloat(assistantContainer.style.left) || 50;
            sparkyPosY = parseFloat(assistantContainer.style.top) || 50;
        }
        startSparkyMovement();
    }
}

function startSparkyMovement() {
    if (sparkyMoveIntervalId) clearInterval(sparkyMoveIntervalId);
    sparkyMoveIntervalId = setInterval(updateSparkyPosition, 60);
}

function stopSparkyMovement() {
    if (sparkyMoveIntervalId) clearInterval(sparkyMoveIntervalId);
    sparkyMoveIntervalId = null;
}


function updateSparkyPosition() {
    if (!sparkyIsMoving || !assistantIsVisible || !assistantContainer || !desktopElement) return;

    const desktopWidth = desktopElement.clientWidth;
    const desktopHeight = desktopElement.clientHeight;
    const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;

    sparkyPosX += sparkyVelX;
    sparkyPosY += sparkyVelY;

    if (sparkyPosX + SPARKY_CONTAINER_WIDTH >= desktopWidth) { sparkyVelX = -Math.abs(sparkyVelX); sparkyPosX = desktopWidth - SPARKY_CONTAINER_WIDTH; }
    else if (sparkyPosX <= 0) { sparkyVelX = Math.abs(sparkyVelX); sparkyPosX = 0; }
    if (sparkyPosY + SPARKY_CONTAINER_HEIGHT >= desktopHeight - taskbarHeight) { sparkyVelY = -Math.abs(sparkyVelY); sparkyPosY = desktopHeight - taskbarHeight - SPARKY_CONTAINER_HEIGHT; }
    else if (sparkyPosY <= 0) { sparkyVelY = Math.abs(sparkyVelY); sparkyPosY = 0; }

    assistantContainer.style.left = sparkyPosX + 'px';
    assistantContainer.style.top = sparkyPosY + 'px';

    const sparkyBobbingGroup = assistantAvatarSVG ? assistantAvatarSVG.querySelector('#sparkyBobbingGroup') : null;
    if (sparkyBobbingGroup && Math.random() < 0.0008 && !sparkyBobbingGroup.classList.contains('rolling')) {
        sparkyBobbingGroup.classList.add('rolling');
        setTimeout(() => {
            sparkyBobbingGroup.classList.remove('rolling');
            sparkyBobbingGroup.style.transform = '';
        }, 1000);
    }

    if (Math.random() < 0.005) {
        sparkyIsMoving = false;
        setTimeout(() => {
            sparkyIsMoving = true;
        }, Math.random() * 3000 + 2000);
    }
    if (Math.random() < 0.002) {
        sparkyVelX = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 1.5 + 0.5);
        sparkyVelY = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 1.5 + 0.5);
    }
}

function initAllAiApps(){
    initVibeCreatorApp();
    initGameGeneratorApp();
    initMusicStudioApp();
    initGifCreatorApp();
    if (selectedApiProvider !== 'gemini' || !window.GLOBAL_GEMINI_API_KEY) { assistant_gemini_model = null; }
    if (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) {
        ensureTransformersJsPipeline(window.GLOBAL_TRANSFORMERSJS_MODEL_ID, (progress) => {
            const statusTarget = document.getElementById('systemSettingsWindow')?.style.display === 'flex' ? systemSettings_transformersjs_status : apiKeyStatus;
            if (statusTarget) {
                if (progress.status === 'loading') {
                    statusTarget.textContent = `Pre-warming ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID}: ${Math.round(progress.progress)}% (${progress.file})`;
                } else if (progress.status === 'loaded') {
                    statusTarget.textContent = `Model ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID} ready.`;
                } else if (progress.status === 'error') {
                    statusTarget.textContent = `Error pre-warming ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID}: ${(progress.message || String(progress)).substring(0,50)}`;
                } else {
                    statusTarget.textContent = `Pre-warming ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID}: ${Math.round(progress.progress || 0)}% (${progress.file || 'model files'})`;
                }
            }
        }).then(() => {
             const statusTarget = document.getElementById('systemSettingsWindow')?.style.display === 'flex' ? systemSettings_transformersjs_status : apiKeyStatus;
             if (statusTarget) statusTarget.textContent = `Local LLM ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID} ready.`;
        }).catch(e => {
            console.error("Error pre-warming Transformers.js model:", e);
             const statusTarget = document.getElementById('systemSettingsWindow')?.style.display === 'flex' ? systemSettings_transformersjs_status : apiKeyStatus;
             if (statusTarget) statusTarget.textContent = `Error pre-warming: ${(e.message || String(e)).substring(0,50)}`;
        });
    }
    }

    function initCalendar() {
        if (!taskbarClock || !calendarPopup) return;

        taskbarClock.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent the global click listener from hiding it immediately
            const isVisible = calendarPopup.style.display === 'block';
            hideAllContextMenus(); // Hide other menus when opening calendar
            if (isVisible) {
                calendarPopup.style.display = 'none';
            } else {
                const now = new Date();
                renderCalendar(now.getFullYear(), now.getMonth());
                calendarPopup.style.display = 'block';
            }
        });

        calendarPrevMonth.addEventListener('click', () => {
            const newMonth = calendarCurrentDate.getMonth() - 1;
            renderCalendar(calendarCurrentDate.getFullYear(), newMonth);
        });

        calendarNextMonth.addEventListener('click', () => {
            const newMonth = calendarCurrentDate.getMonth() + 1;
            renderCalendar(calendarCurrentDate.getFullYear(), newMonth);
        });
    }

    function initImageToCodeAppEventListeners() {
        const imageToCodeWindow = document.getElementById('imageToCodeWindow');
        if (!imageToCodeWindow) return;

        // Using a single paste listener on the document and checking the active window
        // is more robust than attaching it to the window, which might lose focus.
        document.addEventListener('paste', handlePaste, false);

        function handlePaste(e) {
            if (activeWindow !== imageToCodeWindow) return;

            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let imageFile = null;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf("image") !== -1) {
                    imageFile = items[i].getAsFile();
                    break;
                }
            }
            if (imageFile) {
                handleImageFile(imageFile);
            }
        }

        function handleImageFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                if (imageToCode_status) imageToCode_status.textContent = 'Status: Pasted item is not a valid image.';
                return;
            }
            imageToCode_lastPastedFile = file;

            const reader = new FileReader();
            reader.onload = (e) => {
                if(imageToCode_preview) {
                    imageToCode_preview.src = e.target.result;
                    imageToCode_preview.style.display = 'block';
                }
                if(imageToCode_pasteInstructions) imageToCode_pasteInstructions.style.display = 'none';
                if(imageToCode_generateButton) imageToCode_generateButton.disabled = false;
                if(imageToCode_status) imageToCode_status.textContent = `Status: Image preview loaded. Ready to generate code.`;
            };
            reader.readAsDataURL(file);
        }

        if (imageToCode_generateButton) {
            imageToCode_generateButton.addEventListener('click', handleGenerateCode);
        }

        async function handleGenerateCode() {
            if (!imageToCode_lastPastedFile) {
                if(imageToCode_status) imageToCode_status.textContent = 'Status: Please paste an image first.';
                return;
            }

            const userPrompt = imageToCode_prompt.value.trim();
            if(imageToCode_status) imageToCode_status.textContent = 'Status: Generating code with AI...';
            if(imageToCode_generateButton) imageToCode_generateButton.disabled = true;
            if(imageToCode_generatedCode) imageToCode_generatedCode.value = 'AI is thinking...';

            try {
                const base64Data = await getBase64(imageToCode_lastPastedFile);
                const mimeType = imageToCode_lastPastedFile.type;

                const generatedCode = await callCurrentAiProviderForMultimodal(DEFAULT_PIC_TO_CODE_PROMPT, userPrompt, base64Data, mimeType);
                
                if(imageToCode_generatedCode) imageToCode_generatedCode.value = generatedCode;
                if(imageToCode_status) imageToCode_status.textContent = 'Status: Code generation complete! Opening in browser...';
                logK8osActivity("Pic to Code", `Generated code from image with prompt: ${(userPrompt || "none").substring(0,50)}...`);

                if (generatedCode && generatedCode.toLowerCase().includes('<html')) {
                    const basePath = 'live/pic-to-code';
                    const targetFolderId = ensureVFSPath(basePath);
                    
                    const fileName = (userPrompt.substring(0, 25).replace(/[^a-z0-9]/gi, '_') || `pic-to-code`) + `_${Date.now().toString(36)}.html`;

                    const newFile = createVFSEntry({
                        type: 'file',
                        name: fileName,
                        mimeType: 'text/html',
                        content: generatedCode,
                        parentId: targetFolderId,
                    });
                    
                    if(imageToCode_status) imageToCode_status.textContent += ` Saved to ${basePath}/${fileName}`;
                    openNewBrowserWindow(null, newFile.id);
                }

            } catch (error) {
                console.error('Error generating code from image:', error);
                if(imageToCode_status) imageToCode_status.textContent = `Status: Error - ${error.message}`;
                if(imageToCode_generatedCode) imageToCode_generatedCode.value = `// Error during generation:\n// ${error.message}`;
            } finally {
                if(imageToCode_generateButton) imageToCode_generateButton.disabled = false;
            }
        }

        function getBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    const base64String = reader.result.replace(/^data:.+;base64,/, '');
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
            });
        }
    }

    initializeTerminal();
    loadApiKey();
    initCalendar();
    initImageToCodeAppEventListeners();
    initSparkyAssistEventListeners();
    initSparkyEventListeners();
    openWindow('apiKeySettingsWindow');

</script>


</body></html>
