<!--
    k8OS - Web-based Desktop Environment
    Created by: k8o5
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Allow user scaling for zoom on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>k8OS</title>
    <link id="favicon" rel="shortcut icon" href="data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3ClinearGradient id='irisGradient' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:rgb(0,150,255);stop-opacity:1' /%3E%3Cstop offset='100%25' style='stop-color:rgb(0,80,180);stop-opacity:1' /%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' fill='white'/%3E %3C!-- Optional: if you want a white background for the favicon itself --%3E%3Ccircle cx='50' cy='50' r='20' fill='url(%23irisGradient)'/%3E%3Ccircle cx='50' cy='50' r='10' fill='black'/%3E%3Cellipse cx='58' cy='42' rx='5' ry='7' fill='white' opacity='0.8'/%3E%3Cpath fill='white' stroke='black' stroke-width='1.5' stroke-linecap='round'%3E%3Canimate attributeName='d' dur='4s' repeatCount='indefinite' keyTimes='0; 0.05; 0.15; 0.25; 1' values='M 10 50 Q 50 15 90 50 L 90 0 L 10 0 Z; M 10 50 Q 50 45 90 50 L 90 0 L 10 0 Z; M 10 50 Q 50 50 90 50 L 90 0 L 10 0 Z; M 10 50 Q 50 45 90 50 L 90 0 L 10 0 Z; M 10 50 Q 50 15 90 50 L 90 0 L 10 0 Z' /%3E%3C/path%3E%3Cpath fill='white' stroke='black' stroke-width='1.5' stroke-linecap='round'%3E%3Canimate attributeName='d' dur='4s' repeatCount='indefinite' keyTimes='0; 0.05; 0.15; 0.25; 1' values='M 10 50 Q 50 85 90 50 L 90 100 L 10 100 Z; M 10 50 Q 50 55 90 50 L 90 100 L 10 100 Z; M 10 50 Q 50 50 90 50 L 90 100 L 10 100 Z; M 10 50 Q 50 55 90 50 L 90 100 L 10 100 Z; M 10 50 Q 50 85 90 50 L 90 100 L 10 100 Z' /%3E%3C/path%3E%3C/svg%3E">
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.8.3/dist/es-module-shims.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai",
        "marked": "https://esm.run/marked@4.0.12"
      }
    }
    </script>
    <style>
        :root {
            --win95-bg: #008080;
            --win95-light-gray: #C0C0C0;
            --win95-dark-gray: #808080;
            --win95-white: #FFFFFF;
            --win95-black: #000000;
            --win95-button-face: #DFDFDF;
            --win95-title-blue: #000080;
            --win95-title-text: #FFFFFF;
            --win95-font: 'MS Sans Serif', 'Tahoma', 'Geneva', sans-serif;
            --desktop-icon-base-size: 48px;
            --desktop-icon-scale-factor: 1.0;
        }
        body {
            font-family: var(--win95-font);
            background-color: var(--win95-bg); /* Fallback color */
            background-image: none; /* Default no image */
            background-size: cover; /* Default size */
            background-repeat: no-repeat; /* Default repeat */
            background-position: center center; /* Default position */
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            /* touch-action: none; Removed to allow pinch-zoom on mobile */
        }
        .desktop {
            flex-grow: 1;
            position: relative;
            padding: 5px;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: flex-start;
            align-content: flex-start;
            overflow: hidden; /* Important for Sparky's movement boundaries */
        }
        .desktop-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: calc( (var(--desktop-icon-base-size) * var(--desktop-icon-scale-factor)) + 32px);
            margin: calc(5px * var(--desktop-icon-scale-factor));
            padding: calc(5px * var(--desktop-icon-scale-factor));
            cursor: pointer;
            color: var(--win95-white);
            flex-shrink: 0;
            touch-action: manipulation; /* Prevents page scroll when dragging icons on touch */
        }
        .desktop-icon:hover, .desktop-icon.selected {
            background-color: rgba(0, 0, 128, 0.5);
            outline: 1px dotted var(--win95-white);
        }
        .desktop-icon img, .desktop-icon .icon-placeholder {
            width: calc(var(--desktop-icon-base-size) * var(--desktop-icon-scale-factor));
            height: calc(var(--desktop-icon-base-size) * var(--desktop-icon-scale-factor));
            margin-bottom: calc(5px * var(--desktop-icon-scale-factor));
            background-color: var(--win95-light-gray);
            border: 1px solid var(--win95-dark-gray);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(20px * var(--desktop-icon-scale-factor));
            color: var(--win95-black);
        }
        .desktop-icon span {
            font-size: calc(11px * var(--desktop-icon-scale-factor));
            word-break: break-word;
            line-height: 1.2;
        }
        .window {
            position: absolute;
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            min-width: 280px;
            min-height: 180px;
            display: none; /* Initially hidden, shown by JS */
            flex-direction: column;
            resize: both;
            overflow: hidden;
        }
        /* Web Browser specific styling for its dynamic parts */
        .webBrowserWindow .window-content, .sparkyHtmlPopupWindow .window-content { padding: 0; overflow: hidden; }
        .webBrowserWindow_navControls { display:flex; align-items: center; padding: 5px; border-bottom: 1px solid var(--win95-dark-gray); background-color: var(--win95-button-face); flex-shrink: 0;}
        .webBrowserWindow_navControls button { font-family: "Marlett", "Webdings"; font-size: 14px; width: 24px; height: 22px; line-height: 20px; margin-right: 3px;}
        .webBrowserWindow_addressBar { flex-grow: 1; margin-left:5px; margin-right: 5px; height: 22px; padding: 2px 4px;}
        .webBrowserWindow_iframeContent, .sparkyHtmlPopupWindow_iframeContent { width: 100%; height: 100%; flex-grow: 1; border: none; background-color: var(--win95-white); }
        .webBrowserWindow_status { /* Already covered by .window-content .status-bar if added there */ }


        .window.fullscreen {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: calc(100vh - 31px) !important; /* Adjusted for taskbar */
            resize: none !important;
            border-radius: 0;
            box-shadow: none;
            z-index: 1500 !important;
        }
        .window.minimized { /* This class might not be needed if display:none is used directly */
            display: none !important;
        }
        .window.mobile-default-fullscreen {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important; /* Full height on mobile */
            resize: none !important;
            border-radius: 0;
            box-shadow: none;
            z-index: 1500 !important;
        }
        .window.active { z-index: 1000; } /* Default active window z-index */

        .title-bar {
            background-color: var(--win95-title-blue);
            color: var(--win95-title-text);
            padding: 3px 5px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            height: 20px;
            flex-shrink: 0;
            touch-action: none; /* Prevent page scroll when dragging title bar on touch */
        }
        .window.mobile-default-fullscreen .title-bar { cursor: default; }

        .title-bar-text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .title-bar-controls button {
            background-color: var(--win95-light-gray);
            border: 1px outset var(--win95-light-gray);
            color: var(--win95-black);
            font-family: "Marlett", "Webdings";
            font-size: 12px;
            padding: 0;
            width: 16px;
            height: 14px;
            line-height: 14px;
            margin-left: 2px;
            cursor: pointer;
        }
        .title-bar-controls button:active { border-style: inset; }
        .window-content {
            padding: 10px;
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            background-color: var(--win95-button-face);
            display: flex;
            flex-direction: column;
        }
        .window-content label { display: block; margin-bottom: 5px; font-size: 12px; }
        .window-content input[type="text"],
        .window-content input[type="password"],
        .window-content input[type="number"],
        .window-content textarea,
        .window-content select,
        .window-content input[type="color"],
        .window-content input[type="range"] {
            width: calc(100% - 10px);
            padding: 3px;
            margin-bottom: 8px;
            border: 1px inset var(--win95-dark-gray);
            font-family: var(--win95-font);
            font-size: 12px;
            box-sizing: border-box;
        }
        .window-content input[type="color"] { height: 30px; padding: 1px; }
        .window-content input[type="range"] { padding: 0; }
        .window-content textarea { min-height: 60px; resize: vertical; flex-grow: 1; }
        #gameGen_generatedCode, #musicStudio_generatedCode, #gifCreator_svgInput, #textEditor_contentArea { min-height: 100px; font-family: "Courier New", monospace; font-size:11px; white-space: pre-wrap; }
        #gameGen_debugCombinedInput, #gameErrorLog_errorsDisplay { min-height: 80px; background-color: var(--win95-white); font-family: "Courier New", monospace; font-size:11px; white-space: pre-wrap;}
        .window-content button {
            padding: 5px 10px;
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            cursor: pointer;
            font-family: var(--win95-font);
            font-size: 12px;
        }
        .window-content button:active { border-style: inset; }
        .window-content button:disabled { color: var(--win95-dark-gray); cursor: default; }
        .window-content .status-bar {
            border-top: 1px solid var(--win95-dark-gray);
            border-bottom: 1px solid var(--win95-white);
            padding: 2px 5px;
            font-size: 11px;
            margin-top: auto;
            flex-shrink: 0;
        }
        .taskbar {
            background-color: var(--win95-light-gray);
            border-top: 1px solid var(--win95-white);
            padding: 3px;
            height: 28px;
            display: flex;
            align-items: center;
            box-sizing: border-box;
            flex-shrink: 0;
            position: relative;
            z-index: 19000; /* Below start menu, above most windows */
        }
        .start-button {
            padding: 2px 8px;
            margin-right: 5px;
            border: 2px outset var(--win95-light-gray);
            font-weight: bold;
            cursor: pointer;
            position: relative;
        }
        .start-button:active { border-style: inset; }
        .taskbar-buttons-container {
            display: flex;
            flex-grow: 1;
            overflow-x: auto; /* For many buttons */
            align-items: center;
            padding-left: 5px;
            gap: 3px;
            height: 100%;
        }
        .taskbar-button {
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            padding: 0px 8px; /* Adjusted padding */
            font-size: 11px;
            font-family: var(--win95-font);
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            height: 22px; /* Standard taskbar button height */
            line-height: 18px; /* Vertically center text */
            display: flex;
            align-items: center;
            flex-shrink: 0;
        }
        .taskbar-button:active, .taskbar-button.active {
            border-style: inset;
            background-color: var(--win95-button-face); /* Slightly different look when active */
        }
        .taskbar-button.minimized {
            /* Optional: Style for minimized buttons, e.g., slightly darker or different border */
        }
        .clock {
            margin-left: auto;
            padding: 2px 5px;
            border: 1px inset var(--win95-dark-gray);
            font-size: 11px;
        }
        .start-menu {
            position: absolute;
            bottom: 28px; /* Height of taskbar */
            left: 3px;
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            box-shadow: 2px -2px 5px rgba(0,0,0,0.3);
            padding: 2px;
            display: none;
            flex-direction: column;
            width: 150px;
            z-index: 20000; /* Above taskbar */
        }
        .start-menu-item { padding: 5px 10px; cursor: pointer; font-size: 12px; }
        .start-menu-item:hover { background-color: var(--win95-title-blue); color: var(--win95-white); }
        .start-menu-separator { height: 1px; background-color: var(--win95-dark-gray); border-bottom: 1px solid var(--win95-white); margin: 2px 0; }

        .context-menu {
            background-color: var(--win95-light-gray);
            border: 2px outset var(--win95-light-gray);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            padding: 2px;
            min-width: 120px;
            display: none; /* Initially hidden */
            position: absolute; /* Positioned by JS */
            z-index: 30000; /* High z-index */
            font-family: var(--win95-font);
        }
        .context-menu-item {
            padding: 4px 12px; /* Increased padding for better clickability */
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
        }
        .context-menu-item:hover {
            background-color: var(--win95-title-blue);
            color: var(--win95-white);
        }
        .context-menu-separator {
            height: 1px;
            background-color: var(--win95-dark-gray);
            border-bottom: 1px solid var(--win95-white);
            margin: 2px 0;
        }

        #svg_svgContainer, #gifCreator_previewContainer { width: 100%; min-height: 200px; flex-grow: 1; border: 1px inset var(--win95-dark-gray); background-color: var(--win95-white); margin-top: 10px; display: flex; justify-content: center; align-items: center; overflow: auto; }
        #svg_svgContainer svg, #gifCreator_previewContainer svg { max-width: 100%; max-height: 100%; }
        #svg_loadingIndicator, #gifCreator_loadingIndicator { font-style: italic; }

        #gameGen_planDisplay { font-family: "Courier New", Courier, monospace; font-size: 11px; min-height: 60px; background-color: var(--win95-white); border: 1px inset var(--win95-dark-gray); padding: 5px; white-space: pre-wrap; margin-top: 5px; overflow-y: auto;}
        #gameGen_assetStatus { font-size: 11px; margin-top: 5px; }
        #gamePlayerWindow_iframe { width: 100%; height: 100%; flex-grow: 1; border: none; background-color: var(--win95-white); }
        #gamePlayerWindow .window-content { padding: 0; overflow: hidden; }


        #gameGen_loadingMessage, #gameGen_errorMessage { padding: 8px; margin-top: 8px; border: 1px solid var(--win95-dark-gray); text-align: center; }
        #gameGen_errorMessage { background-color: #FFCCCC; color: red; }
        .api-key-warning { font-size: 11px; background-color: #FFFFE0; border: 1px solid #F0E68C; padding: 5px; margin-bottom: 10px; }
        .get-api-key-link { font-size: 11px; color: var(--win95-title-blue); margin-right: 10px; }
        #fileExplorerWindow .window-content { overflow: hidden; }
        #fe_fileListContainer { flex-grow: 1; overflow-y: auto; border: 1px inset var(--win95-dark-gray); background-color: var(--win95-white); padding: 5px; margin-top: 5px; }
        #fe_fileList { list-style: none; padding: 0; margin: 0; }
        #fe_fileList li { padding: 3px 5px; cursor: pointer; border-bottom: 1px dotted var(--win95-dark-gray); display: flex; align-items: center;}
        #fe_fileList li:last-child { border-bottom: none; }
        #fe_fileList li:hover { background-color: #E0E0E0; }
        #fe_fileList li .fe-item-icon { margin-right: 5px; font-family: "Segoe UI Symbol", "Apple Color Emoji", "Segoe UI Emoji";}
        #fe_fileList a { text-decoration: none; color: var(--win95-black); display: block; flex-grow: 1;}
        #fe_fileSearchInput { margin-bottom: 5px; }
        #fe_folderNameDisplay { font-weight: bold; margin-bottom: 5px; padding-bottom: 3px; border-bottom: 1px solid var(--win95-dark-gray); }

        .settings-tabs { display: flex; border-bottom: 1px solid var(--win95-dark-gray); margin-bottom: 10px; }
        .settings-tab { padding: 5px 10px; cursor: pointer; border: 1px solid transparent; border-bottom: none; margin-right: 2px; font-size: 12px; background-color: var(--win95-dark-gray); color: var(--win95-light-gray); }
        .settings-tab.active { background-color: var(--win95-light-gray); border-color: var(--win95-dark-gray); border-bottom-color: var(--win95-light-gray); color: var(--win95-black); position: relative; top: 1px; }
        .settings-tab-content { display: none; }
        .settings-tab-content.active { display: block; }
        .settings-tab-content h3 { font-size: 13px; margin-top: 0; margin-bottom: 8px; border-bottom: 1px solid var(--win95-dark-gray); padding-bottom: 3px;}
        .settings-tab-content textarea { min-height: 60px; }

        #systemSettings_appearance_colorOptions button { width: 30px; height: 30px; margin: 5px; border: 2px outset var(--win95-light-gray); }
        #systemSettings_appearance_colorOptions button:active { border-style: inset; }
        #systemSettings_appearance_colorOptions { display: flex; flex-wrap: wrap; margin-bottom:10px; }
        #systemSettings_iconSizeSliderValue { margin-left: 10px; font-size: 12px; }

        .reboot-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #000; color: #FFF; display: none; justify-content: center; align-items: center; font-family: 'Consolas', 'Courier New', monospace; font-size: 18px; z-index: 100000; text-align: center; line-height: 1.5; }
        .reboot-overlay p { margin: 5px; }
        .reboot-overlay .k8os-logo { font-size: 32px; font-weight: bold; color: #00FF00; margin-bottom: 20px; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
        .debug-section { border: 1px dotted var(--win95-dark-gray); padding: 8px; margin-top: 10px; }
        .debug-section h4 { font-size: 12px; margin-top:0; margin-bottom:5px; }

        .provider-caveat {
            font-size: 10px;
            color: var(--win95-dark-gray);
            margin-top: 2px;
            font-style: italic;
        }

        /* Assistant Styles */
        #k8osAssistant {
            position: fixed;
            z-index: 26000;
            display: none;
            flex-direction: column;
            user-select: none;
            transition: left 0.05s linear, top 0.05s linear;
        }

        #k8osAssistant_avatarContainer {
            width: 70px;
            height: 70px;
            cursor: pointer;
        }
        #k8osAssistant_inputContainer {
            display: none;
            margin-bottom: 8px;
            padding: 5px;
            background-color: var(--win95-button-face);
            border: 1px solid var(--win95-dark-gray);
            border-radius: 5px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.15);
        }
        #k8osAssistant_commandInput {
            width: 150px;
            height: 20px;
            border: 1px inset var(--win95-dark-gray);
            font-family: var(--win95-font);
            font-size: 11px;
            padding: 2px 4px;
            margin-right: 5px;
        }
        #k8osAssistant_sendCommandButton {
            font-size: 10px;
            padding: 2px 5px;
            background-color: var(--win95-light-gray);
            border: 1px outset var(--win95-light-gray);
        }
         #k8osAssistant_sendCommandButton:active { border-style: inset; }


        #k8osAssistant_speechBubble {
            background-color: #FFFFE1;
            border: 1px solid #F4E79A;
            border-radius: 8px;
            padding: 8px 12px;
            font-family: var(--win95-font);
            font-size: 12px;
            color: var(--win95-black);
            max-width: 220px;
            min-width: 80px;
            text-align: left;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.15);
            position: relative;
            margin-bottom: 8px;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            white-space: normal;
        }

        #k8osAssistant_speechBubble.visible {
            opacity: 1;
            transform: translateY(0px) scale(1);
        }

        #k8osAssistant_speechBubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            right: 18px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #FFFFE1;
        }
         /* End Assistant Styles */

        @media (max-width: 768px) {
            .window.mobile-default-fullscreen {
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                resize: none !important;
                border-radius: 0;
                box-shadow: none;
                z-index: 1500 !important;
            }
            .window.mobile-default-fullscreen .title-bar { cursor: default; }
            .window.mobile-default-fullscreen .title-bar-controls .fullscreen-button { display: none; }
            .window.mobile-default-fullscreen .title-bar-controls .minimize-button { display: none; }

            #k8osAssistant_avatarContainer {
                width: 60px;
                height: 60px;
            }
            #k8osAssistant_speechBubble {
                max-width: 180px;
                font-size: 11px;
            }
        }

    </style>
</head>
<body>
    <div class="desktop" id="desktop">
        <!-- Static App Icons -->
        <div class="desktop-icon" data-item-type="app" data-app-id="apiKeySettingsWindow"><div class="icon-placeholder">🔑</div><span>API Key</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="fileExplorerWindow" data-vfs-path-id="root"><div class="icon-placeholder">📁</div><span>Files</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="webBrowserLauncher"><div class="icon-placeholder">🌐</div><span>Browser</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="svgGeneratorWindow"><div class="icon-placeholder">🎨</div><span>SVG Creator</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="gifCreatorWindow"><div class="icon-placeholder">🎞️</div><span>GIF Creator</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="gameGeneratorWindow"><div class="icon-placeholder">🕹️</div><span>Game Gen</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="musicStudioWindow"><div class="icon-placeholder">🎶</div><span>Music Studio</span></div>
        <div class="desktop-icon" data-item-type="app" data-app-id="systemSettingsWindow"><div class="icon-placeholder">⚙️</div><span>Settings</span></div>
        <!-- VFS Icons will be dynamically added here by JS -->
    </div>

    <!-- App Windows -->
    <div id="apiKeySettingsWindow" class="window" style="width: 420px; height: 320px; top: 20px; left: 20px;">
        <div class="title-bar"><span class="title-bar-text">🔑 API Key Settings</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <div class="api-key-warning"><strong>Important:</strong> API Keys are stored in local storage.</div>
            <label for="apiProviderSelect">Select API Provider:</label>
            <select id="apiProviderSelect" style="margin-bottom: 10px;">
                <option value="gemini">Google Gemini</option>
                <option value="groq">Groq</option>
                <option value="openrouter">OpenRouter</option>
                <option value="deepseek">DeepSeek</option>
                <option value="huggingface">Hugging Face</option>
                <option value="transformersjs">Transformers.js (Local LLM)</option>
                <option value="custom">Custom Endpoint (User-hosted)</option>
            </select>
            <label id="apiKeyInputLabel" for="apiKeyInput">API Key/Token:</label>
            <input type="password" id="apiKeyInput" placeholder="Enter API Key/Token for selected provider">
            <p id="apiKeyInfoText" style="font-size:11px; margin-top: 5px; display:none;">No API Key needed for Transformers.js. Configure Model ID in System Settings. For Custom Endpoint, enter your endpoint's API Key here, and configure URL in System Settings.</p>
            <button id="saveApiKeyButton">Save Key/Token</button>
            <p id="apiKeyLinksContainer" style="margin-top:10px; font-size: 11px;">
                <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="geminiApiKeyLink">Get a Gemini API Key</a>
                <a href="https://console.groq.com/keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="groqApiKeyLink" style="display:none;">Get a Groq API Key</a>
                <a href="https://openrouter.ai/keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="openrouterApiKeyLink" style="display:none;">Get an OpenRouter API Key</a>
                <a href="https://platform.deepseek.com/api_keys" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="deepseekApiKeyLink" style="display:none;">Get a DeepSeek API Key</a>
                <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener noreferrer" class="get-api-key-link" id="hfApiKeyLink" style="display:none;">Get a Hugging Face Token</a>
                <a href="#" class="get-api-key-link" id="customSetupLink" style="display:none;">Setup Custom Endpoint Guide</a>
            </p>
            <div id="apiKeyStatus" class="status-bar">Status: Select provider and enter key/token.</div>
        </div>
    </div>

    <div id="fileExplorerWindow" class="window" style="width: 450px; height: 400px; top: 30px; left: 350px;">
        <div class="title-bar"><span class="title-bar-text">📁 File Explorer</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <div id="fe_folderNameDisplay">Loading folder...</div>
            <input type="text" id="fe_fileSearchInput" placeholder="Search files...">
            <div id="fe_fileListContainer"><ul id="fe_fileList"></ul></div>
            <div id="fe_status" class="status-bar">Status: Idle</div>
        </div>
    </div>

    <div id="svgGeneratorWindow" class="window" style="width: 500px; height: 450px; top: 50px; left: 50px;">
        <div class="title-bar"><span class="title-bar-text">🎨 SVG Creator</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="svg_promptInput">Describe SVG image:</label>
            <textarea id="svg_promptInput" rows="3" placeholder="e.g., a smiling sun (Results vary by provider)"></textarea>
            <button id="svg_generateButton" disabled>Generate SVG</button>
            <button id="svg_downloadButton" style="display: none; margin-top: 5px;">Download SVG</button>
            <div id="svg_loadingIndicator" style="display: none;">Generating...</div>
            <div id="svg_svgContainer"><p>SVG appears here.</p></div>
            <div id="svg_errorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle</div>
        </div>
    </div>

    <div id="gifCreatorWindow" class="window" style="width: 600px; height: 550px; top: 60px; left: 100px;">
        <div class="title-bar"><span class="title-bar-text">🎞️ GIF Creator (Animated SVG)</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="gifCreator_promptInput">Describe animation or animated SVG:</label>
            <textarea id="gifCreator_promptInput" rows="3" placeholder="e.g., 'a blinking eye' (Animation quality varies greatly by provider)"></textarea>
            <div class="import-section" style="margin-top:10px; margin-bottom:10px; padding:5px; border:1px dashed var(--win95-dark-gray);">
                <label for="gifCreator_svgInput">Optional: Existing SVG code (from SVG Creator or pasted):</label>
                <textarea id="gifCreator_svgInput" rows="4" placeholder="Paste static SVG code here to animate it..."></textarea>
                <button id="gifCreator_importSvgButton" style="margin-top:5px; font-size:10px; padding:2px 5px;">Import from SVG Creator</button>
                <label for="gifCreator_animationPromptInput" style="margin-top:5px;">Animation instructions for existing SVG:</label>
                <textarea id="gifCreator_animationPromptInput" rows="2" placeholder="e.g., 'make the sun rotate'"></textarea>
            </div>
            <button id="gifCreator_generateButton" disabled>Generate Animated SVG</button>
            <button id="gifCreator_downloadButton" style="display: none; margin-top: 5px;">Download Animated SVG</button>
            <div id="gifCreator_loadingIndicator" style="display: none; margin-top:5px;">Generating...</div>
            <div id="gifCreator_previewContainer" style="margin-top:10px;"><p>Animated SVG preview appears here.</p></div>
            <div id="gifCreator_errorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle</div>
        </div>
    </div>

    <div id="gameGeneratorWindow" class="window" style="width: 700px; height: 680px; top: 110px; left: 110px;">
        <div class="title-bar"><span class="title-bar-text">🕹️ Game Generator</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="gameGen_prompt">Describe game idea:</label>
            <textarea id="gameGen_prompt" rows="2" placeholder="e.g., 'breakout-style game with 3 lives' (Complex generation works best with Gemini/Groq/DeepSeek)"></textarea>
            <button id="gameGen_generateButton" disabled>Generate Game</button>
            <button id="gameGen_downloadZipButton" style="display: none; margin-top: 5px;">Download Game as ZIP</button>
            <div id="gameGen_loadingMessage" style="display: none;">AI working...</div>
            <div id="gameGen_errorMessage" style="display: none;"></div>
            <div style="margin-top:10px;">
                <label for="gameGen_planDisplay">Game Plan & Asset Status:</label>
                <div id="gameGen_planDisplay" readonly>Awaiting game plan...</div>
            </div>
            <div id="gameGen_assetStatus"></div>
            <div class="output-section" style="margin-top:10px;">
                <label for="gameGen_generatedCode">Generated Game Code (HTML):</label>
                <textarea id="gameGen_generatedCode" readonly placeholder="Generated HTML/JS code..."></textarea>
            </div>
            <div id="gameGen_apiErrorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle</div>
            <div class="debug-section" id="gameGen_debugSection" style="display:none;">
                <h4>Assisted Debugging</h4>
                <label for="gameGen_debugCombinedInput">Observed Errors & Debugging Hints:</label>
                <textarea id="gameGen_debugCombinedInput" rows="4" placeholder="Paste error messages and/or provide hints for AI..."></textarea>
                <button id="gameGen_debugAttemptButton">Attempt to Fix Error with AI</button>
            </div>
        </div>
    </div>

    <div id="musicStudioWindow" class="window" style="width: 500px; height: 480px; top: 140px; left: 500px;">
        <div class="title-bar"><span class="title-bar-text">🎶 Music Studio</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <label for="musicStudio_promptInput">Describe music or theme:</label>
            <textarea id="musicStudio_promptInput" rows="3" placeholder="e.g., 'upbeat 8-bit space theme loop' (JS code generation works best with Gemini/Groq/DeepSeek)"></textarea>
            <button id="musicStudio_generateButton" disabled>Generate Music Code</button>
            <button id="musicStudio_modifyButton" style="margin-left: 5px;" disabled>Modify Music</button> <!-- ADDED THIS BUTTON -->
            <div id="musicStudio_loadingIndicator" style="display: none; margin-top: 5px;">Generating music code...</div>
            <label for="musicStudio_generatedCode" style="margin-top:10px;">Generated JavaScript (Web Audio API):</label>
            <textarea id="musicStudio_generatedCode" rows="8" readonly></textarea>
            <div style="margin-top:5px;">
                <button id="musicStudio_playButton" disabled>Play Music</button>
                <button id="musicStudio_stopButton" disabled>Stop Music</button>
                <button id="musicStudio_downloadJsButton" style="display: none;">Download JS</button>
            </div>
            <div id="musicStudio_errorDisplay" class="status-bar" style="color:red; font-size:11px; margin-top:5px; border-top: 1px solid var(--win95-dark-gray); padding-top: 3px;">Status: Idle</div>
        </div>
    </div>

    <div id="gamePlayerWindow" class="window" style="width: 800px; height: 600px; top: 150px; left: 150px;">
        <div class="title-bar">
            <span class="title-bar-text" id="gamePlayerWindow_title">Game Player</span>
            <div class="title-bar-controls">
                <button id="gamePlayer_refreshButton" title="Refresh Game">Q</button>
                <button class="minimize-button" title="Minimize">0</button>
                <button class="fullscreen-button" title="Toggle Fullscreen">1</button>
                <button class="close-button" title="Close">r</button>
            </div>
        </div>
        <div class="window-content"><iframe id="gamePlayerWindow_iframe" sandbox="allow-scripts allow-same-origin allow-popups"></iframe></div>
    </div>

    <div id="textEditorWindow" class="window" style="width: 500px; height: 400px; top: 70px; left: 70px;">
        <div class="title-bar"><span class="title-bar-text">🗒️ Text Editor</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content">
            <div style="display: flex; margin-bottom: 5px; flex-shrink: 0; align-items:center;">
                <button id="textEditor_saveButton">Save</button>
                <button id="textEditor_sparkyAssistButton" style="margin-left: 5px;" title="Use Sparky to help create files/folders based on editor content">✨ Assist</button>
                <span id="textEditor_currentFileName" style="margin-left: 10px; font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1;"></span>
            </div>
            <textarea id="textEditor_contentArea" style="flex-grow: 1; width: calc(100% - 6px);" placeholder="File content... or describe a file/folder structure for Sparky Assist."></textarea>
            <div id="textEditor_status" class="status-bar">Status: Idle.</div>
        </div>
    </div>

    <div id="systemSettingsWindow" class="window" style="width: 550px; height: 720px; top: 60px; left: 200px; overflow-y: auto;">
        <div class="title-bar"><span class="title-bar-text">⚙️ System Settings</span><div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div></div>
        <div class="window-content" style="height: calc(100% - 22px); overflow-y: auto;">
            <div class="settings-tabs">
                <div class="settings-tab active" data-tab="appearance">Appearance</div>
                <div class="settings-tab" data-tab="aiConfig">AI Config</div>
                <div class="settings-tab" data-tab="about">About</div>
            </div>
            <div id="settingsContent_appearance" class="settings-tab-content active">
                <h3>Desktop Background</h3>
                <label for="systemSettings_appearance_bgColorPicker">Custom Background Color:</label>
                <input type="color" id="systemSettings_appearance_bgColorPicker" value="#008080">
                <label>Preset Colors:</label>
                <div id="systemSettings_appearance_colorOptions"></div>
                <button id="systemSettings_appearance_resetButton">Reset to Default Color</button>
                <h3 style="margin-top: 15px;">Image Background (URL)</h3>
                <p style="font-size:10px; margin-bottom:5px; color:var(--win95-dark-gray);"><em>Note: Direct access to your computer's wallpaper is not possible for security reasons. You can provide a URL to an image instead.</em></p>
                <label for="systemSettings_appearance_bgImageUrlInput">Image URL:</label>
                <input type="text" id="systemSettings_appearance_bgImageUrlInput" placeholder="https://example.com/image.png">
                <label for="systemSettings_appearance_bgSizeSelect">Background Size:</label>
                <select id="systemSettings_appearance_bgSizeSelect">
                    <option value="cover">Cover</option>
                    <option value="contain">Contain</option>
                    <option value="auto">Auto (Original Size)</option>
                    <option value="100% 100%">Stretch to Fit</option>
                </select>
                <label for="systemSettings_appearance_bgRepeatSelect">Background Repeat:</label>
                <select id="systemSettings_appearance_bgRepeatSelect">
                    <option value="no-repeat">No Repeat</option>
                    <option value="repeat">Repeat</option>
                    <option value="repeat-x">Repeat Horizontally</option>
                    <option value="repeat-y">Repeat Vertically</option>
                </select>
                <button id="systemSettings_appearance_applyBgImageButton" style="margin-top: 5px;">Apply Image URL</button>
                <button id="systemSettings_appearance_clearBgImageButton" style="margin-top: 5px;">Clear Image Background</button>
                <h3 style="margin-top: 15px;">Icon Size</h3>
                <label for="systemSettings_iconSizeSlider">Icon Scale: <span id="systemSettings_iconSizeSliderValue">1.0x</span></label>
                <input type="range" id="systemSettings_iconSizeSlider" min="0.5" max="1.5" step="0.1" value="1.0">
                <button id="systemSettings_iconSizeResetButton" style="margin-top: 5px;">Reset Icon Size</button>
            </div>
            <div id="settingsContent_aiConfig" class="settings-tab-content">
                <div id="geminiModelSettings">
                    <h3>Global AI Model (Gemini)</h3>
                    <label for="systemSettings_ai_modelNameInput">Current Gemini Model Name:</label>
                    <input type="text" id="systemSettings_ai_modelNameInput" placeholder="e.g., gemini-1.5-flash">
                    <button id="systemSettings_ai_saveModelButton">Save & Apply Gemini Model</button>
                </div>
                <div id="groqModelSettings" style="display:none;">
                    <h3>Global AI Model (Groq)</h3>
                    <label for="systemSettings_ai_groqModelInput">Enter Groq Model Name:</label>
                    <input type="text" id="systemSettings_ai_groqModelInput" placeholder="e.g., llama3-8b-8192 or meta-llama/Llama-3-8b-chat-hf">
                    <button id="systemSettings_ai_saveGroqModelButton">Save Groq Model</button>
                    <p class="provider-caveat">Enter the exact model identifier from Groq.</p>
                    <h3 style="margin-top:15px;">Groq API Settings</h3>
                    <label for="systemSettings_ai_groqMaxTokensInput">Max Tokens per Request:</label>
                    <input type="number" id="systemSettings_ai_groqMaxTokensInput" min="1" step="1" placeholder="e.g., 2048">
                    <button id="systemSettings_ai_saveGroqMaxTokensButton">Save Max Tokens</button>
                    <p class="provider-caveat">Lower values use less quota per request but might cut off long responses.</p>
                </div>
                <div id="openrouterModelSettings" style="display:none;">
                    <h3>Global AI Model (OpenRouter)</h3>
                    <label for="systemSettings_ai_openrouterModelInput">Enter OpenRouter Model String:</label>
                    <input type="text" id="systemSettings_ai_openrouterModelInput" placeholder="e.g., google/gemini-flash-1.5 or mistralai/mistral-7b-instruct">
                    <button id="systemSettings_ai_saveOpenrouterModelButton">Save OpenRouter Model</button>
                    <p class="provider-caveat">Find model strings on the OpenRouter <a href="https://openrouter.ai/models" target="_blank" rel="noopener noreferrer">Models page</a>.</p>
                    <h3 style="margin-top:15px;">OpenRouter API Settings</h3>
                    <label for="systemSettings_ai_openrouterHttpRefererInput">Site URL / HTTP-Referer (Optional):</label>
                    <input type="text" id="systemSettings_ai_openrouterHttpRefererInput" placeholder="e.g., https://your-site.com">
                    <button id="systemSettings_ai_saveOpenrouterHttpRefererButton">Save Site URL</button>
                    <p class="provider-caveat">Set your site URL to identify your app to OpenRouter. See their docs.</p>
                </div>
                <div id="deepseekModelSettings" style="display:none;">
                    <h3>Global AI Model (DeepSeek)</h3>
                    <label for="systemSettings_ai_deepseekModelInput">Enter DeepSeek Model Name:</label>
                    <input type="text" id="systemSettings_ai_deepseekModelInput" placeholder="e.g., deepseek-chat or deepseek-coder">
                    <button id="systemSettings_ai_saveDeepseekModelButton">Save DeepSeek Model</button>
                    <p class="provider-caveat">Enter the model identifier from DeepSeek (e.g., deepseek-chat, deepseek-coder).</p>
                    <h3 style="margin-top:15px;">DeepSeek API Settings</h3>
                    <label for="systemSettings_ai_deepseekMaxTokensInput">Max Tokens per Request:</label>
                    <input type="number" id="systemSettings_ai_deepseekMaxTokensInput" min="1" step="1" placeholder="e.g., 2048">
                    <button id="systemSettings_ai_saveDeepseekMaxTokensButton">Save Max Tokens</button>
                    <p class="provider-caveat">Lower values use less quota per request but might cut off long responses.</p>
                </div>
                <div id="hfModelSettings" style="display:none;">
                    <h3>Global AI Model (Hugging Face)</h3>
                    <label for="systemSettings_ai_hfModelIdInput">Enter HF Model ID:</label>
                    <input type="text" id="systemSettings_ai_hfModelIdInput" placeholder="e.g., mistralai/Mistral-7B-Instruct-v0.1">
                    <button id="systemSettings_ai_saveHfModelButton">Save HF Model ID</button>
                    <p class="provider-caveat">Uses the Inference API (text-generation assumed). Ensure the model is loaded or available. Results vary.</p>
                </div>
                <div id="transformersjsModelSettings" style="display:none;">
                    <h3>Global AI Model (Transformers.js - Local LLM)</h3>
                    <label for="systemSettings_ai_transformersjsModelIdInput">Hugging Face Model ID (Text Generation):</label>
                    <input type="text" id="systemSettings_ai_transformersjsModelIdInput" placeholder="e.g., Xenova/distilgpt2">
                    <button id="systemSettings_ai_saveTransformersjsModelButton">Save & Prepare Model</button>
                    <p class="provider-caveat">Model from Xenova's collection recommended (e.g., Xenova/distilgpt2). Model will be downloaded and run in your browser. Ensure it's a text-generation model.</p>
                    <p class="provider-caveat">Using Transformers.js version: <span id="systemSettings_transformersJsVersion"></span>.</p>
                    <div id="systemSettings_transformersjs_status" class="status-bar" style="margin-top: 5px; border-top: 1px solid var(--win95-dark-gray); padding-top:3px;">Status: Idle.</div>
                </div>
                <div id="customProviderSettings" style="display:none;">
                    <h3>Custom Endpoint Settings (User-hosted)</h3>
                    <label for="systemSettings_ai_customEndpointUrlInput">Custom Endpoint URL:</label>
                    <input type="text" id="systemSettings_ai_customEndpointUrlInput" placeholder="e.g., https://xxxx.ngrok.io/generate">
                    <label for="systemSettings_ai_customModelIdInput">Custom Model Identifier (optional):</label>
                    <input type="text" id="systemSettings_ai_customModelIdInput" placeholder="e.g., my-custom-model-v1">
                    <button id="systemSettings_ai_saveCustomSettingsButton">Save Custom Endpoint Settings</button>
                    <p class="provider-caveat">Ensure your backend is running and accessible. The API Key for this endpoint is set in the 'API Key Settings' window.</p>
                </div>

                <h3 style="margin-top:15px;">SVG Creator Instruction</h3>
                <label for="systemSettings_ai_svgInstruction">Base prompt for SVG generation:</label>
                <textarea id="systemSettings_ai_svgInstruction" rows="3"></textarea>
                <button id="systemSettings_ai_saveSvgInstructionButton">Save SVG Instruction</button>
                <h3 style="margin-top:15px;">Game Generator Final Code Instruction</h3>
                <label for="systemSettings_ai_gameGenFinalInstruction">Base prompt for Game Generator (Final Code Step):</label>
                <textarea id="systemSettings_ai_gameGenFinalInstruction" rows="4"></textarea>
                <button id="systemSettings_ai_saveGameGenFinalInstructionButton">Save Game Gen Final Instruction</button>
                <h3 style="margin-top:15px;">Music Studio Instruction</h3>
                <label for="systemSettings_ai_musicStudioInstruction">Base prompt for Music Studio JS generation:</label>
                <textarea id="systemSettings_ai_musicStudioInstruction" rows="4"></textarea>
                <button id="systemSettings_ai_saveMusicStudioInstructionButton">Save Music Studio Instruction</button>
                <h3 style="margin-top:15px;">GIF Creator (Animated SVG from Prompt) Instruction</h3>
                <label for="systemSettings_ai_gifCreatorNewInstruction">Base prompt for new animated SVG:</label>
                <textarea id="systemSettings_ai_gifCreatorNewInstruction" rows="3"></textarea>
                <button id="systemSettings_ai_saveGifCreatorNewInstructionButton">Save GIF (New) Instruction</button>
                <h3 style="margin-top:15px;">GIF Creator (Animate Existing SVG) Instruction</h3>
                <label for="systemSettings_ai_gifCreatorAnimateInstruction">Base prompt for animating existing SVG:</label>
                <textarea id="systemSettings_ai_gifCreatorAnimateInstruction" rows="4"></textarea>
                <button id="systemSettings_ai_saveGifCreatorAnimateInstructionButton">Save GIF (Animate) Instruction</button>
            </div>
            <div id="settingsContent_about" class="settings-tab-content">
                <h3>About k8OS</h3>
                <p id="systemSettings_about_version">Version: 0.1.6</p>
                <p>Created by: k8o5</p>
                <p>© 2025 k8o5.</p>
                <p style="font-size:11px; margin-top:15px;">Uses Google Generative AI, Groq API, OpenRouter, DeepSeek API, Hugging Face Inference API, Transformers.js, MarkedJS, ES Module Shims, JSZip.</p>
            </div>
            <div id="systemSettings_status" class="status-bar">Settings panel.</div>
        </div>
    </div>


    <div class="taskbar">
        <div class="start-button" id="startButton">Start</div>
        <div id="taskbarButtonsContainer" class="taskbar-buttons-container">
            <!-- Taskbar buttons will be added here by JS -->
        </div>
        <div class="start-menu" id="startMenu">
            <!-- <div class="start-menu-item" id="startMenuNewFolder">New Folder</div> Removed -->
            <!-- <div class="start-menu-separator"></div> Removed -->
            <div class="start-menu-item" id="startMenuReboot">Reboot</div>
            <div class="start-menu-separator"></div>
            <div class="start-menu-item" id="startMenuFactoryReset" style="color: #c00; font-weight:bold;">Factory Reset</div>
            <div class="start-menu-separator"></div>
            <div class="start-menu-item" id="startMenuShutdown">Shutdown</div>
        </div>
        <div class="clock" id="taskbarClock">00:00:00</div>
    </div>
    <div class="reboot-overlay" id="rebootOverlay">
        <div id="rebootMessageContainer">
            <p class="k8os-logo">k8OS</p>
            <p id="rebootProgressText">Initializing...</p>
        </div>
    </div>

    <!-- Desktop Context Menu -->
    <div id="desktopContextMenu" class="context-menu">
        <!-- Items will be added here by JS -->
    </div>

    <!-- k8OS Assistant (Sparky) -->
    <div id="k8osAssistant">
        <div id="k8osAssistant_inputContainer">
            <input type="text" id="k8osAssistant_commandInput" placeholder="Talk to Sparky..."/>
            <button id="k8osAssistant_sendCommandButton">Send</button>
        </div>
        <div id="k8osAssistant_speechBubble"><span id="k8osAssistant_speechText">Hi there!</span></div>
        <div id="k8osAssistant_avatarContainer">
            <svg id="assistantAvatarSVG" viewBox="0 0 100 100" width="100%" height="100%">
                <style>
                    /* Default animation for sparkyBobbingGroup */
                    #sparkyBobbingGroup {
                        transform-origin: 50% 50%;
                        animation-name: sparkyWander;
                        animation-duration: 10s;
                        animation-timing-function: ease-in-out;
                        animation-iteration-count: infinite;
                    }
                    /* When .rolling class is added to sparkyBobbingGroup */
                    #sparkyBobbingGroup.rolling {
                        animation-name: sparkyRoll, sparkyWander;
                        animation-duration: 1s, 10s;
                        animation-timing-function: ease-in-out, ease-in-out;
                        animation-iteration-count: 1, infinite;
                        animation-delay: 0s, 1.05s; /* Roll first, then wander starts after 1.05s */
                    }

                    @keyframes sparkyWander {
                        0%   { transform: translate(0px, 0px) rotate(0deg); }
                        15%  { transform: translate(4px, -3px) rotate(3deg); }
                        30%  { transform: translate(-2px, 1px) rotate(-2deg); }
                        45%  { transform: translate(5px, -2px) rotate(2deg); }
                        60%  { transform: translate(0px, 2px) rotate(0deg); }
                        75%  { transform: translate(-4px, -3px) rotate(-3deg); }
                        90%  { transform: translate(2px, 0px) rotate(1deg); }
                        100% { transform: translate(0px, 0px) rotate(0deg); }
                    }
                     @keyframes sparkyRoll {
                        0%   { transform: translate(0px, 0px) rotate(0deg) scale(1); }
                        50%  { transform: translate(0px, 0px) rotate(180deg) scale(1.1); }
                        100% { transform: translate(0px, 0px) rotate(360deg) scale(1); }
                    }

                    #sparkyEyelid { animation: sparkyBlink 4.5s ease-in-out infinite; transform-origin: 50% 35%; /* Blink from top of eye */ }
                    @keyframes sparkyBlink {
                        0%, 90%, 100% { opacity: 0; transform: scaleY(0.1)}
                        93% { opacity: 1; transform: scaleY(1)}
                        96% { opacity: 0; transform: scaleY(0.1)}
                    }
                    #sparkyMouth.talking { animation: sparkyTalk 0.25s infinite steps(2, end); }
                    @keyframes sparkyTalk {
                        0% { d: path("M 40 60 Q 50 63 60 60"); }
                        50% { d: path("M 40 60 Q 50 68 60 60"); }
                    }
                </style>
                <defs>
                    <radialGradient id="sparkyBodyGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                        <stop offset="0%" style="stop-color:#87CEFA;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#4682B4;stop-opacity:1" />
                    </radialGradient>
                    <filter id="sparkyGlow"><feGaussianBlur stdDeviation="1.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
                </defs>
                <g id="sparkyBobbingGroup">
                    <circle cx="50" cy="50" r="32" fill="url(#sparkyBodyGradient)" filter="url(#sparkyGlow)"/>
                    <ellipse cx="50" cy="45" rx="14" ry="9" fill="white"/>
                    <ellipse id="sparkyEyelid" cx="50" cy="45" rx="14.5" ry="9.5" fill="url(#sparkyBodyGradient)" opacity="0"/>
                    <circle id="sparkyPupil" cx="50" cy="45" r="4.5" fill="#222"/>
                    <path id="sparkyMouth" d="M 40 60 Q 50 63 60 60" stroke="#333" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                </g>
            </svg>
        </div>
    </div>

    <!-- Setup Guide Modal -->
    <div id="setupGuideModal" class="window" style="width: 650px; height: 550px; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 40000; display: none; resize: none; box-shadow: 0 0 15px rgba(0,0,0,0.5);">
        <div class="title-bar">
            <span id="setupGuideModalTitle" class="title-bar-text">Setup Guide</span>
            <div class="title-bar-controls">
                <button id="setupGuideModalCloseButton" title="Close">r</button>
            </div>
        </div>
        <div class="window-content" style="display: flex; flex-direction: column;">
            <p id="setupGuideModalInstructions" style="font-size: 12px; margin-bottom: 10px; flex-shrink: 0; max-height: 150px; overflow-y: auto;">Instructions will appear here.</p>
            <label for="setupGuideModalCode" style="font-size:12px; margin-bottom:3px; flex-shrink:0;">Boilerplate Code:</label>
            <textarea id="setupGuideModalCode" readonly style="width: calc(100% - 6px); flex-grow: 1; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre; margin-bottom: 10px;"></textarea>
            <button id="setupGuideModalCopyButton" style="flex-shrink: 0;">Copy Code</button>
            <div id="setupGuideModalStatus" class="status-bar" style="margin-top: auto; flex-shrink:0;">Click "Copy Code" then paste into your environment.</div>
        </div>
    </div>


<script type="module">
    import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
    import { marked, Renderer as MarkedRenderer } from 'marked';
    import { pipeline as transformersPipeline, env as transformersEnv } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1';

    // Transformers.js specific setup
    transformersEnv.allowLocalModels = false; // Only fetch from HF Hub
    transformersEnv.useBrowserCache = true;   // Cache models in browser

    const K8OS_VERSION = "0.1.15"; // Version bump for OpenRouter and GameGen overhaul
    const DEFAULT_GEMINI_AI_MODEL = "gemini-1.5-flash";
    const DEFAULT_GROQ_AI_MODEL = "llama3-8b-8192";
    const DEFAULT_OPENROUTER_AI_MODEL = "google/gemini-flash-1.5";
    const DEFAULT_DEEPSEEK_CHAT_MODEL = "deepseek-chat";
    const DEFAULT_DEEPSEEK_CODER_MODEL = "deepseek-coder";
    const DEFAULT_HF_MODEL_ID = "mistralai/Mistral-7B-Instruct-v0.1";
    const DEFAULT_TRANSFORMERSJS_MODEL_ID = "Xenova/distilgpt2";
    const TRANSFORMERS_JS_VERSION = "3.5.1";

    const DEFAULT_GROQ_MAX_TOKENS = 2048;
    const DEFAULT_DEEPSEEK_MAX_TOKENS = 2048;
    const DEFAULT_HF_MAX_NEW_TOKENS = 1024;
    const DEFAULT_TRANSFORMERSJS_MAX_NEW_TOKENS = 150;
    const DEFAULT_CUSTOM_MAX_TOKENS = 1024; // Default for custom endpoint


    const DEFAULT_SVG_INSTRUCTION = `Generate ONLY raw SVG code for: "{USER_PROMPT}". The SVG should be simple, iconic, and scalable. Start with "<svg" and end with "</svg>". Include 'viewBox'. No explanations, comments, or markdown.`;
    const DEFAULT_GAMEGEN_PLAN_INSTRUCTION = `Based on the user's game idea: "{USER_GAME_IDEA}", create a concise game plan. The plan must include: 1. A brief (1-2 sentences) description of the core game mechanic. 2. A list of 3 to 5 essential SVG assets. For each, provide a short, clear description for an SVG generator. If an asset should be animated (e.g., player walking, enemy pulsing), include that in its description (e.g., "player character with simple walking animation", "pulsating alien SVG"). 3. A list of 2 to 3 essential sound effects required (short, one-shot sounds). For each, provide a short, clear description for a sound generator (e.g., "laser shoot sound", "explosion sound", "item collect sound"). Format the output as a JSON object with three keys: "game_mechanic" (string), "svg_assets" (array of objects, each with "description" and "animated": boolean), and "sound_effects" (array of strings for sound descriptions). Example JSON: { "game_mechanic": "Top-down shooter...", "svg_assets": [{"description": "player ship, blue", "animated": false}, {"description": "enemy UFO, rotates slowly", "animated": true}], "sound_effects": ["shoot sound", "explosion fx"] }. Output ONLY the JSON object.`;
    const DEFAULT_GAMEGEN_FINAL_INSTRUCTION = `Generate a COMPLETE, SINGLE-FILE, RUNNABLE HTML/JavaScript game. User's idea: "{USER_GAME_IDEA}". Game Plan: {GAME_PLAN_JSON}. All assets will be provided in a relative './assets/' directory. You MUST load them from there. The asset filenames are: {ASSET_FILENAMES_JSON}. IMPORTANT: For SVGs, use an asynchronous loading mechanism. 1. Create Image objects for each SVG asset using its path (e.g., 'assets/player.svg'). 2. Use onload/onerror handlers. 3. Only start the game loop AFTER all images are loaded. 4. For sound effects, the assets are JavaScript files. You must fetch each JS file (e.g., fetch('assets/shoot.js')), get its text content, and then use 'new Function('audioContext', 'activeSources', THE_FETCHED_CODE)' to create the playable sound function. Manage loading these sound functions asynchronously as well. The game should not start until all assets (SVGs and sounds) are loaded. Output ONLY the single HTML file string. Use pure JS/Canvas or CDN libraries. Include game loop, rendering, input. Self-contained. No markdown/explanations outside HTML. Make game playable, fit description/plan, using all provided assets and triggering sound effects.`;
    const DEFAULT_GAMEGEN_DEBUG_INSTRUCTION = `The HTML/JS game code (original idea: "{USER_GAME_IDEA}") produced error(s) and/or the user has provided hints: "{ERRORS_AND_HINTS}". Analyze the code, errors, and hints. Provide a corrected version of the full HTML/JS game code. Focus on fixing specified issues while preserving the game's original intent. Pay close attention to asynchronous asset loading from the './assets/' folder. Output ONLY the corrected, complete HTML/JS code, starting with <!DOCTYPE html> or <html> and ending with </html>. No explanations or markdown. Problematic code:\n\`\`\`html\n{PROBLEM_CODE}\n\`\`\``;
    const DEFAULT_MUSICSTUDIO_INSTRUCTION = `Generate JavaScript code using the Web Audio API to create music based on the description: "{USER_PROMPT}". The code should be a self-contained function body. It will be executed within a function that receives 'audioContext' and 'activeSources' (an array to push created source nodes to for later stopping) as arguments, like so: new Function('audioContext', 'activeSources', YOUR_CODE_HERE)(audioContextInstance, activeSourcesArray); Your code should use the provided 'audioContext'. It should create and start all necessary audio nodes and push main/looping source nodes to the 'activeSources' array if they are intended to be stopped later. If the description implies a loop or continuous music, structure your code to create and start the loop. If it's a one-shot piece, it should play through once. Generate ONLY the JavaScript function body. No explanations or markdown.`;
    const DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION = `Generate ONLY raw SVG code for an animated image based on: "{USER_PROMPT}". The SVG MUST include SMIL animation (<animate>, <animateTransform>, <animateMotion>, etc.) to create a looping, GIF-like effect. Ensure the animation is self-contained within the SVG. Start with "<svg" and end with "</svg>". Include 'viewBox'. No explanations, comments, or markdown outside the SVG code itself.`;
    const DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION = `Take the following static SVG code:\n\`\`\`svg\n{STATIC_SVG_CODE}\n\`\`\`\nNow, add SMIL animation elements to this SVG to achieve the following animation described by the user: "{ANIMATION_PROMPT}". Modify the provided SVG code directly. The output should be the complete, modified SVG code with the SMIL animations included. Ensure the animation is looping and self-contained. Start with "<svg" and end with "</svg>". No explanations, comments, or markdown outside the SVG code itself.`;
    const DEFAULT_SPARKY_AD_PROMPT = `You are Sparky, the k8OS assistant. Generate a short, witty, and slightly boastful advertisement about your capabilities or how helpful you are. Make it fun and friendly! Max 2-3 concise sentences. Output ONLY the ad text.`;
    const DEFAULT_SPARKY_HTML_GENERATOR_PROMPT = `You are Sparky, an AI assistant. The user wants to create something described as: "{USER_REQUEST}". Generate a complete, self-contained HTML page that fulfills this request. The HTML should be suitable to be displayed in an iframe. Output ONLY the raw HTML code, starting with <!DOCTYPE html> or <html> and ending with </html>. Do not include any explanations, markdown, or comments outside the HTML itself. If the request is for an interactive element, try to include basic JavaScript within <script> tags in the HTML. Be creative but keep it simple and functional.`;
    const DEFAULT_SPARKY_FILESYSTEM_GENERATOR_PROMPT = `You are Sparky, a k8OS AI assistant. The user wants to create a directory structure with files. User request: "{USER_REQUEST}".
The base location for these creations should be relative to a parent ID: "{BASE_PARENT_ID}". If "{BASE_PARENT_ID}" is "root", then top-level items in the plan should have "parentId": "root". Otherwise, top-level items in the plan should have "parentId": "{BASE_PARENT_ID}".
Analyze the request and generate a JSON array of actions to create the file system.
Each action object in the array should have:
- "action": "create_folder" or "create_file"
- "name": string (name of the file or folder)
- "parentId": string (ID of the parent folder. Use the value provided in "{BASE_PARENT_ID}" for top-level items of this request if "{BASE_PARENT_ID}" is not "root". Use "root" for top-level items if "{BASE_PARENT_ID}" is "root". For nested items, use the "id" you assign to the parent folder in a previous action).
- "id": string (a unique temporary ID for this item, e.g., "item1", "folderA", so it can be referenced as a parentId later by other actions in THIS SAME JSON response).
- "content": string (for "create_file" only, the content of the file. Can be empty string.)
- "mimeType": string (for "create_file" only, e.g., "text/plain", "text/html", "text/css", "application/javascript". Default to "text/plain" if unsure.)

Example (assuming {BASE_PARENT_ID} is "folderXYZ"): User wants "a subfolder 'WebApp' with 'index.html'".
Output JSON:
[
  { "action": "create_folder", "name": "WebApp", "parentId": "folderXYZ", "id": "webappFolder" },
  { "action": "create_file", "name": "index.html", "parentId": "webappFolder", "id": "indexFile", "content": "<h1>Hi</h1>", "mimeType": "text/html" }
]
Output ONLY the JSON array. No explanations, comments, or markdown outside the JSON. Ensure parentId references are correct within the generated sequence of actions, respecting the "{BASE_PARENT_ID}" context for the top-level items of this request.
`;


    const apiProviderSelect = document.getElementById('apiProviderSelect');
    const apiKeyInputLabel = document.getElementById('apiKeyInputLabel');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeyInfoText = document.getElementById('apiKeyInfoText');
    const saveApiKeyButton = document.getElementById('saveApiKeyButton');
    const apiKeyStatus = document.getElementById('apiKeyStatus');
    const apiKeyLinksContainer = document.getElementById('apiKeyLinksContainer');
    const geminiApiKeyLink = document.getElementById('geminiApiKeyLink');
    const groqApiKeyLink = document.getElementById('groqApiKeyLink');
    const openrouterApiKeyLink = document.getElementById('openrouterApiKeyLink');
    const deepseekApiKeyLink = document.getElementById('deepseekApiKeyLink');
    const hfApiKeyLink = document.getElementById('hfApiKeyLink');
    const customSetupLink = document.getElementById('customSetupLink');


    const taskbarClock = document.getElementById('taskbarClock');
    const taskbarButtonsContainer = document.getElementById('taskbarButtonsContainer');
    const svg_promptInput = document.getElementById('svg_promptInput');
    const svg_generateButton = document.getElementById('svg_generateButton');
    const svg_svgContainer = document.getElementById('svg_svgContainer');
    const svg_downloadButton = document.getElementById('svg_downloadButton');
    const svg_loadingIndicator = document.getElementById('svg_loadingIndicator');
    const svg_errorDisplay = document.getElementById('svg_errorDisplay');
    const gifCreator_promptInput = document.getElementById('gifCreator_promptInput');
    const gifCreator_svgInput = document.getElementById('gifCreator_svgInput');
    const gifCreator_importSvgButton = document.getElementById('gifCreator_importSvgButton');
    const gifCreator_animationPromptInput = document.getElementById('gifCreator_animationPromptInput');
    const gifCreator_generateButton = document.getElementById('gifCreator_generateButton');
    const gifCreator_downloadButton = document.getElementById('gifCreator_downloadButton');
    const gifCreator_loadingIndicator = document.getElementById('gifCreator_loadingIndicator');
    const gifCreator_previewContainer = document.getElementById('gifCreator_previewContainer');
    const gifCreator_errorDisplay = document.getElementById('gifCreator_errorDisplay');
    const gameGen_promptInput = document.getElementById('gameGen_prompt');
    const gameGen_generateButton = document.getElementById('gameGen_generateButton');
    const gameGen_downloadZipButton = document.getElementById('gameGen_downloadZipButton');
    const gameGen_generatedCodeTextarea = document.getElementById('gameGen_generatedCode');
    const gameGen_loadingMessage = document.getElementById('gameGen_loadingMessage');
    const gameGen_errorMessage = document.getElementById('gameGen_errorMessage');
    const gameGen_apiErrorDisplay = document.getElementById('gameGen_apiErrorDisplay');
    const gameGen_planDisplay = document.getElementById('gameGen_planDisplay');
    const gameGen_assetStatus = document.getElementById('gameGen_assetStatus');
    const gameGen_debugSection = document.getElementById('gameGen_debugSection');
    const gameGen_debugCombinedInput = document.getElementById('gameGen_debugCombinedInput');
    const gameGen_debugAttemptButton = document.getElementById('gameGen_debugAttemptButton');
    const gamePlayerWindow_iframe = document.getElementById('gamePlayerWindow_iframe');
    const gamePlayer_refreshButton = document.getElementById('gamePlayer_refreshButton');
    const musicStudio_promptInput = document.getElementById('musicStudio_promptInput');
    const musicStudio_generateButton = document.getElementById('musicStudio_generateButton');
    const musicStudio_loadingIndicator = document.getElementById('musicStudio_loadingIndicator');
    const musicStudio_generatedCode = document.getElementById('musicStudio_generatedCode');
    const musicStudio_playButton = document.getElementById('musicStudio_playButton');
    const musicStudio_stopButton = document.getElementById('musicStudio_stopButton');
    const musicStudio_downloadJsButton = document.getElementById('musicStudio_downloadJsButton');
    const musicStudio_errorDisplay = document.getElementById('musicStudio_errorDisplay');
    const fe_fileListElement = document.getElementById('fe_fileList');
    const fe_statusElement = document.getElementById('fe_status');
    const fe_folderNameDisplayElement = document.getElementById('fe_folderNameDisplay');
    const fe_searchInput = document.getElementById('fe_fileSearchInput');
    const textEditor_saveButton = document.getElementById('textEditor_saveButton');
    const textEditor_sparkyAssistButton = document.getElementById('textEditor_sparkyAssistButton');
    const textEditor_contentArea = document.getElementById('textEditor_contentArea');
    const textEditor_status = document.getElementById('textEditor_status');
    const textEditor_currentFileName = document.getElementById('textEditor_currentFileName');
    let currentTextEditorFileId = null;

    const desktopElement = document.getElementById('desktop');
    const desktopContextMenu = document.getElementById('desktopContextMenu');
    const startButton = document.getElementById('startButton');
    const startMenu = document.getElementById('startMenu');
    const startMenuReboot = document.getElementById('startMenuReboot');
    const startMenuFactoryReset = document.getElementById('startMenuFactoryReset');
    const startMenuShutdown = document.getElementById('startMenuShutdown');
    const rebootOverlay = document.getElementById('rebootOverlay');
    const rebootProgressText = document.getElementById('rebootProgressText');
    const systemSettings_appearance_bgColorPicker = document.getElementById('systemSettings_appearance_bgColorPicker');
    const systemSettings_appearance_colorOptions = document.getElementById('systemSettings_appearance_colorOptions');
    const systemSettings_appearance_resetButton = document.getElementById('systemSettings_appearance_resetButton');
    const systemSettings_appearance_bgImageUrlInput = document.getElementById('systemSettings_appearance_bgImageUrlInput');
    const systemSettings_appearance_bgSizeSelect = document.getElementById('systemSettings_appearance_bgSizeSelect');
    const systemSettings_appearance_bgRepeatSelect = document.getElementById('systemSettings_appearance_bgRepeatSelect');
    const systemSettings_appearance_applyBgImageButton = document.getElementById('systemSettings_appearance_applyBgImageButton');
    const systemSettings_appearance_clearBgImageButton = document.getElementById('systemSettings_appearance_clearBgImageButton');
    const systemSettings_iconSizeSlider = document.getElementById('systemSettings_iconSizeSlider');
    const systemSettings_iconSizeSliderValue = document.getElementById('systemSettings_iconSizeSliderValue');
    const systemSettings_iconSizeResetButton = document.getElementById('systemSettings_iconSizeResetButton');
    const systemSettings_status = document.getElementById('systemSettings_status');
    const systemSettings_ai_modelNameInput = document.getElementById('systemSettings_ai_modelNameInput');
    const systemSettings_ai_saveModelButton = document.getElementById('systemSettings_ai_saveModelButton');
    const systemSettings_ai_groqModelInput = document.getElementById('systemSettings_ai_groqModelInput');
    const systemSettings_ai_saveGroqModelButton = document.getElementById('systemSettings_ai_saveGroqModelButton');
    const systemSettings_ai_groqMaxTokensInput = document.getElementById('systemSettings_ai_groqMaxTokensInput');
    const systemSettings_ai_saveGroqMaxTokensButton = document.getElementById('systemSettings_ai_saveGroqMaxTokensButton');
    const systemSettings_ai_openrouterModelInput = document.getElementById('systemSettings_ai_openrouterModelInput');
    const systemSettings_ai_saveOpenrouterModelButton = document.getElementById('systemSettings_ai_saveOpenrouterModelButton');
    const systemSettings_ai_openrouterHttpRefererInput = document.getElementById('systemSettings_ai_openrouterHttpRefererInput');
    const systemSettings_ai_saveOpenrouterHttpRefererButton = document.getElementById('systemSettings_ai_saveOpenrouterHttpRefererButton');
    const systemSettings_ai_deepseekModelInput = document.getElementById('systemSettings_ai_deepseekModelInput');
    const systemSettings_ai_saveDeepseekModelButton = document.getElementById('systemSettings_ai_saveDeepseekModelButton');
    const systemSettings_ai_deepseekMaxTokensInput = document.getElementById('systemSettings_ai_deepseekMaxTokensInput');
    const systemSettings_ai_saveDeepseekMaxTokensButton = document.getElementById('systemSettings_ai_saveDeepseekMaxTokensButton');
    const systemSettings_ai_hfModelIdInput = document.getElementById('systemSettings_ai_hfModelIdInput');
    const systemSettings_ai_saveHfModelButton = document.getElementById('systemSettings_ai_saveHfModelButton');
    const systemSettings_ai_transformersjsModelIdInput = document.getElementById('systemSettings_ai_transformersjsModelIdInput');
    const systemSettings_ai_saveTransformersjsModelButton = document.getElementById('systemSettings_ai_saveTransformersjsModelButton');
    const systemSettings_transformersJsVersion = document.getElementById('systemSettings_transformersJsVersion');
    const systemSettings_transformersjs_status = document.getElementById('systemSettings_transformersjs_status');
    const systemSettings_ai_customEndpointUrlInput = document.getElementById('systemSettings_ai_customEndpointUrlInput');
    const systemSettings_ai_customModelIdInput = document.getElementById('systemSettings_ai_customModelIdInput');
    const systemSettings_ai_saveCustomSettingsButton = document.getElementById('systemSettings_ai_saveCustomSettingsButton');


    const systemSettings_ai_svgInstruction = document.getElementById('systemSettings_ai_svgInstruction');
    const systemSettings_ai_saveSvgInstructionButton = document.getElementById('systemSettings_ai_saveSvgInstructionButton');
    const systemSettings_ai_gameGenFinalInstruction = document.getElementById('systemSettings_ai_gameGenFinalInstruction');
    const systemSettings_ai_saveGameGenFinalInstructionButton = document.getElementById('systemSettings_ai_saveGameGenFinalInstructionButton');
    const systemSettings_ai_musicStudioInstruction = document.getElementById('systemSettings_ai_musicStudioInstruction');
    const systemSettings_ai_saveMusicStudioInstructionButton = document.getElementById('systemSettings_ai_saveMusicStudioInstructionButton');
    const systemSettings_ai_gifCreatorNewInstruction = document.getElementById('systemSettings_ai_gifCreatorNewInstruction');
    const systemSettings_ai_saveGifCreatorNewInstructionButton = document.getElementById('systemSettings_ai_saveGifCreatorNewInstructionButton');
    const systemSettings_ai_gifCreatorAnimateInstruction = document.getElementById('systemSettings_ai_gifCreatorAnimateInstruction');
    const systemSettings_ai_saveGifCreatorAnimateInstructionButton = document.getElementById('systemSettings_ai_saveGifCreatorAnimateInstructionButton');
    const systemSettings_about_version = document.getElementById('systemSettings_about_version');
    const geminiModelSettingsDiv = document.getElementById('geminiModelSettings');
    const groqModelSettingsDiv = document.getElementById('groqModelSettings');
    const openrouterModelSettingsDiv = document.getElementById('openrouterModelSettings');
    const deepseekModelSettingsDiv = document.getElementById('deepseekModelSettings');
    const hfModelSettingsDiv = document.getElementById('hfModelSettings');
    const transformersjsModelSettingsDiv = document.getElementById('transformersjsModelSettings');
    const customProviderSettingsDiv = document.getElementById('customProviderSettings');

    // Setup Guide Modal Elements
    const setupGuideModal = document.getElementById('setupGuideModal');
    const setupGuideModalTitle = document.getElementById('setupGuideModalTitle');
    const setupGuideModalInstructions = document.getElementById('setupGuideModalInstructions');
    const setupGuideModalCode = document.getElementById('setupGuideModalCode');
    const setupGuideModalCopyButton = document.getElementById('setupGuideModalCopyButton');
    const setupGuideModalCloseButton = document.getElementById('setupGuideModalCloseButton');
    const setupGuideModalStatus = document.getElementById('setupGuideModalStatus');


    window.GLOBAL_GEMINI_API_KEY = null;
    window.GLOBAL_GROQ_API_KEY = null;
    window.GLOBAL_OPENROUTER_API_KEY = null;
    window.GLOBAL_DEEPSEEK_API_KEY = null;
    window.GLOBAL_HF_TOKEN = null;
    window.GLOBAL_TRANSFORMERSJS_MODEL_ID = null;
    window.GLOBAL_CUSTOM_API_KEY = null;

    let selectedApiProvider = 'gemini';

    // Transformers.js specific state
    let transformersJsPipelineInstance = null;
    let currentLoadedTransformersJsModel = null;
    let isTransformersJsModelLoading = false;


    let activeWindow = null;
    let highestZIndex = 100;
    let VFS = { items: {} };
    let gameGen_lastHtmlCode = null;
    let gameGen_lastGameAssetPackage = null;
    let gameGen_lastUserIdea = "";
    let musicStudio_lastJsCode = "";
    let musicStudio_currentAudioContext = null;
    let musicStudio_activeSources = [];
    let browserInstances = {};
    let browserWindowCounter = 0;
    let sparkyHtmlPopupCounter = 0;
    let contextMenuTargetVFSId = null;


    let gifCreator_currentAnimatedSvg = null;
    let gifCreator_genAI_model;
    let svg_genAI_internal_model;
    let gameGen_main_model;
    let musicStudio_genAI_model;
    let assistant_gemini_model;

    const DEFAULT_BG_COLOR = '#008080';
    const PRESET_BG_COLORS = ['#008080', '#000000', '#808080', '#0000A0', '#3A6EA5', '#D3D3D3'];

    let assistantContainer = null;
    let assistantSpeechBubble = null;
    let assistantSpeechText = null;
    let assistantAvatarSVG = null;
    let assistantSparkyMouth = null;
    let assistantIsVisible = false;
    let assistantSpeechTimeout;
    let assistantIsThinking = false;
    let assistantIsProcessingCommand = false;
    let k8osActivityLog = [];
    const ACTIVITY_LOG_MAX_AGE = 5 * 60 * 1000;
    const ASSISTANT_SUMMARY_INTERVAL = 3 * 60 * 1000;
    let assistantSummaryIntervalId = null;

    // Sparky Movement Variables
    let sparkyPosX = 50, sparkyPosY = 50;
    let sparkyVelX = 1, sparkyVelY = 1; // Pixels per update tick
    let sparkyIsMoving = true;
    let sparkyMoveIntervalId = null;
    const SPARKY_CONTAINER_WIDTH = 70; // Approx width of #k8osAssistant_avatarContainer
    const SPARKY_CONTAINER_HEIGHT = 120; // Approx height including potential bubble

    // Sparky Creations Folder
    let SPARKY_CREATIONS_VFS_ID = null;
    const SPARKY_CREATIONS_FOLDER_NAME = "Sparky's Creations";


    // --- Setup Guide Modal Functions ---
    function openSetupGuideModal(title, instructions, codeSnippet) {
        if (!setupGuideModal || !setupGuideModalTitle || !setupGuideModalInstructions || !setupGuideModalCode || !setupGuideModalStatus) return;

        setupGuideModalTitle.textContent = title;
        setupGuideModalInstructions.innerHTML = instructions; // Use innerHTML if instructions include <strong> etc.
        setupGuideModalCode.value = codeSnippet;
        setupGuideModalStatus.textContent = "Click 'Copy Code' then paste into your environment.";
        setupGuideModal.style.display = 'flex';
        bringToFront(setupGuideModal); // Make sure it's on top
    }

    function closeSetupGuideModal() {
        if (setupGuideModal) {
            setupGuideModal.style.display = 'none';
        }
    }

    if (setupGuideModalCloseButton) {
        setupGuideModalCloseButton.addEventListener('click', closeSetupGuideModal);
    }

    if (setupGuideModalCopyButton) {
        setupGuideModalCopyButton.addEventListener('click', () => {
            if (setupGuideModalCode && setupGuideModalStatus) {
                navigator.clipboard.writeText(setupGuideModalCode.value).then(() => {
                    setupGuideModalStatus.textContent = "Code copied to clipboard!";
                    setTimeout(() => {
                         if (setupGuideModal.style.display === 'flex') { // Only reset if modal is still open
                            setupGuideModalStatus.textContent = "Click 'Copy Code' then paste into your environment.";
                         }
                    }, 2000);
                }).catch(err => {
                    setupGuideModalStatus.textContent = "Failed to copy. Please copy manually.";
                    console.error('Failed to copy text: ', err);
                });
            }
        });
    }

    function getCustomSetupGuideContent() {
        const title = "⚙️ Custom Endpoint Setup Guide (Python/Flask)";
        const instructions = `
            <p>This guide provides a basic Python Flask server to act as a custom LLM endpoint for k8OS.</p>
            <ol style="margin-left: 20px; font-size:11px;">
                <li>Save the code below as a Python file (e.g., <code>server.py</code>).</li>
                <li>Install dependencies: <code>pip install Flask flask-cors</code>. You will also need a library for your chosen LLM (e.g., <code>transformers</code>, <code>openai</code>).</li>
                <li><strong>Important:</strong> Replace <code>'YOUR_VERY_SECRET_API_KEY'</code> with a strong, unique API key you create.</li>
                <li><strong>LLM Integration:</strong> Implement your actual LLM call logic in the <code># TODO: LLM LOGIC</code> section. The example shows where to use the incoming prompt.</li>
                <li>Run the server: <code>python server.py</code>.</li>
                <li>Expose the server to the internet using a tool like <a href="https://ngrok.com/docs/getting-started" target="_blank" rel="noopener noreferrer">ngrok</a> (e.g., <code>ngrok http 5000</code>). This will give you a public URL.</li>
                <li>The generation endpoint will be that URL + <code>/generate</code> (e.g., <code>https://xxxx...ngrok.io/generate</code>).</li>
                <li>In k8OS API Key Settings, select "Custom Endpoint", enter the API key you created.</li>
                <li>In k8OS System Settings, enter the full <code>.../generate</code> URL for "Custom Endpoint URL".</li>
            </ol>
        `;
        const codeSnippet = `
from flask import Flask, request, jsonify
from flask_cors import CORS
import os

# --- Configuration ---
# IMPORTANT: Use an environment variable in production for the API key
ENDPOINT_API_KEY = 'YOUR_VERY_SECRET_API_KEY' # Replace with your chosen API key
# --- End Configuration ---

app = Flask(__name__)
# IMPORTANT: Restrict the origin in a production environment for security
CORS(app) # Enable CORS for all routes

@app.route('/generate', methods=['POST'])
def generate_text():
    # 1. API Key Authentication
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Unauthorized: Missing or malformed Bearer token"}), 401
    
    token = auth_header.split(' ')[1]
    if token != ENDPOINT_API_KEY:
        return jsonify({"error": "Unauthorized: Invalid API Key"}), 401

    # 2. Get data from the request
    try:
        data = request.get_json()
        if not data or 'prompt' not in data:
            return jsonify({"error": "Bad Request: Missing 'prompt' in JSON payload"}), 400
        
        prompt = data.get('prompt')
        # Optional parameters you can use from k8OS
        model_id = data.get('model', 'default_custom_model') 
        max_tokens = data.get('max_tokens', 150)
        temperature = data.get('temperature', 0.7)

        # 3. LLM LOGIC - Replace this with your actual LLM call
        # This is where you would integrate with your LLM (e.g., using Hugging Face Transformers,
        # making a call to another API like OpenAI, etc.)
        #
        # Example:
        # from my_llm_library import generate
        # llm_response = generate(prompt, model=model_id, max_length=max_tokens, temp=temperature)
        #
        # For now, we'll just echo the input
        llm_response = f"Custom endpoint received prompt: '{prompt[:80]}...'. Model: {model_id}."
        # --- End LLM LOGIC ---

        # 4. Send the response back in the expected format
        return jsonify({"response": llm_response})

    except Exception as e:
        print(f"Error during generation: {e}")
        return jsonify({"error": "Internal Server Error", "details": str(e)}), 500

if __name__ == '__main__':
    if not ENDPOINT_API_KEY or ENDPOINT_API_KEY == 'YOUR_VERY_SECRET_API_KEY':
        print("ERROR: Please set your ENDPOINT_API_KEY in the script.")
    else:
        # Port can be configured via environment variable or default to 5000
        port = int(os.environ.get('PORT', 5000))
        print(f"Starting custom endpoint server on port {port}...")
        app.run(host='0.0.0.0', port=port)
`;
        return { title, instructions, codeSnippet };
    }


    // --- VFS Functions ---
    function generateUniqueId() { return Date.now().toString(36) + Math.random().toString(36).substring(2, 7); }
    function loadVFS() {
        const storedVFSItems = localStorage.getItem('k8os_vfs_items');
        if (storedVFSItems) { try { VFS.items = JSON.parse(storedVFSItems); } catch (e) { console.error("Error parsing VFS from localStorage:", e); VFS.items = {}; } }
        else { VFS.items = {}; }
        ensureSparkyCreationsFolder(); // Ensure "Sparky's Creations" folder exists or is created
        renderDesktopVFSIcons();
    }
    function saveVFS() { try { localStorage.setItem('k8os_vfs_items', JSON.stringify(VFS.items)); } catch (e) { console.error("Error saving VFS to localStorage:", e); alert("Error saving file system state. LocalStorage might be full."); } }
    function createVFSEntry(entryData) {
        if (!entryData.id) entryData.id = generateUniqueId();
        if (!entryData.parentId) entryData.parentId = 'root';
        if (!entryData.modified) entryData.modified = Date.now();
        VFS.items[entryData.id] = entryData; saveVFS(); return VFS.items[entryData.id];
    }
    function getVFSEntry(id) { return VFS.items[id]; }
    function updateVFSEntry(id, updates) { if (VFS.items[id]) { VFS.items[id] = { ...VFS.items[id], ...updates, modified: Date.now() }; saveVFS(); return VFS.items[id]; } return null; }
    function deleteVFSEntry(id) {
        if (VFS.items[id]) {
            const entryType = VFS.items[id].type; delete VFS.items[id];
            if (entryType === 'folder') { const children = Object.values(VFS.items).filter(item => item.parentId === id); children.forEach(child => deleteVFSEntry(child.id)); }
            saveVFS(); renderDesktopVFSIcons(); if(fe_fileListElement && currentFEVfsPathId) renderVFSFileList(currentFEVfsPathId); return true; // Refresh File Explorer if open
        } return false;
    }
    function getVFSChildren(parentId) { return Object.values(VFS.items).filter(item => item.parentId === parentId).sort((a,b) => a.name.localeCompare(b.name)); }
    function getVFSPathString(itemId) {
        let path = ''; let currentItem = getVFSEntry(itemId); const pathParts = [];
        while(currentItem && currentItem.parentId !== 'root') { pathParts.unshift(currentItem.name); currentItem = getVFSEntry(currentItem.parentId); if (!currentItem || pathParts.length > 10) break;  }
        if (currentItem && currentItem.id !== 'root' && currentItem.parentId === 'root') { pathParts.unshift(currentItem.name); }
        path = (currentItem && currentItem.id === 'root' ? 'Root' : '') + (pathParts.length > 0 ? '/' + pathParts.join('/') : (currentItem && currentItem.name && currentItem.id !== 'root' ? currentItem.name : 'Root'));
        if (itemId === 'root') return 'Root'; const entry = getVFSEntry(itemId); return entry ? entry.name : 'Unknown Path';
    }

    function ensureSparkyCreationsFolder() {
        if (SPARKY_CREATIONS_VFS_ID) {
            const existing = getVFSEntry(SPARKY_CREATIONS_VFS_ID);
            if (existing && existing.name === SPARKY_CREATIONS_FOLDER_NAME && existing.parentId === 'root') {
                return SPARKY_CREATIONS_VFS_ID;
            }
        }
        const rootChildren = getVFSChildren('root');
        const existingFolder = rootChildren.find(item => item.type === 'folder' && item.name === SPARKY_CREATIONS_FOLDER_NAME);
        if (existingFolder) {
            SPARKY_CREATIONS_VFS_ID = existingFolder.id;
            return existingFolder.id;
        } else {
            const newFolder = createVFSEntry({ type: 'folder', name: SPARKY_CREATIONS_FOLDER_NAME, parentId: 'root' });
            SPARKY_CREATIONS_VFS_ID = newFolder.id;
            return newFolder.id;
        }
    }

    function renderDesktopVFSIcons() {
        document.querySelectorAll('.desktop-icon[data-item-type="file"], .desktop-icon[data-item-type="folder"]').forEach(icon => icon.remove());
        const desktopItems = getVFSChildren('root');
        desktopItems.forEach(item => {
            if (item.name === SPARKY_CREATIONS_FOLDER_NAME && item.parentId === 'root') {
                 if (!SPARKY_CREATIONS_VFS_ID) SPARKY_CREATIONS_VFS_ID = item.id;
                 return;
            }

            const iconEl = document.createElement('div'); iconEl.className = 'desktop-icon';
            iconEl.dataset.itemId = item.id; iconEl.dataset.itemType = item.type;
            const placeholder = document.createElement('div'); placeholder.className = 'icon-placeholder';
            placeholder.textContent = item.type === 'file' ? (item.name.endsWith('.html') || item.name.endsWith('.htm') ? '🌐' : '📄') : '📁';
            const span = document.createElement('span'); span.textContent = item.name;
            iconEl.appendChild(placeholder); iconEl.appendChild(span); desktopElement.appendChild(iconEl);
        });
        initializeDesktopIconBehaviors();
    }
    function initializeDesktopIconBehaviors() {
        document.querySelectorAll('.desktop-icon').forEach(icon => {
            const newIcon = icon.cloneNode(true); icon.parentNode.replaceChild(newIcon, icon);
            newIcon.addEventListener('dblclick', (e) => handleDesktopIconDblClick(e.currentTarget));
            newIcon.addEventListener('click', (e) => {
                document.querySelectorAll('.desktop-icon.selected').forEach(i => i.classList.remove('selected'));
                e.currentTarget.classList.add('selected');
                contextMenuTargetVFSId = e.currentTarget.dataset.itemId || null;
                if(startMenu) startMenu.style.display = 'none';
                if(desktopContextMenu) desktopContextMenu.style.display = 'none';
            });
            newIcon.addEventListener('contextmenu', (e) => handleDesktopContextMenu(e));
        });
    }
    function handleDesktopIconDblClick(iconElement) {
        const itemType = iconElement.dataset.itemType; const appId = iconElement.dataset.appId;
        const itemId = iconElement.dataset.itemId; const vfsPathId = iconElement.dataset.vfsPathId;
        if (itemType === 'app') {
            if (appId === 'webBrowserLauncher') { openNewBrowserWindow(); }
            else if (appId === 'fileExplorerWindow') { openWindow(appId, { vfsPathId: vfsPathId || 'root' }); }
            else { openWindow(appId); }
        } else if (itemType === 'file') {
            const fileEntry = getVFSEntry(itemId);
            if (fileEntry) {
                if (fileEntry.mimeType === 'text/html' || fileEntry.name.endsWith('.html') || fileEntry.name.endsWith('.htm')) {
                    openNewBrowserWindow(null, fileEntry.id);
                } else {
                    openWindow('textEditorWindow', { fileId: fileEntry.id });
                }
            }
        } else if (itemType === 'folder') { openWindow('fileExplorerWindow', { vfsPathId: itemId }); }
    }
    function openTextEditorWindow(options = {}) {
        const windowEl = document.getElementById('textEditorWindow');
        if (!windowEl || !textEditor_contentArea || !textEditor_status || !textEditor_currentFileName) return;
        currentTextEditorFileId = null; textEditor_contentArea.value = '';
        textEditor_status.textContent = "Status: Idle."; textEditor_currentFileName.textContent = "Untitled";
        const titleBarText = windowEl.querySelector('.title-bar-text');
        if (options.fileId) {
            const fileEntry = getVFSEntry(options.fileId);
            if (fileEntry && fileEntry.type === 'file') {
                currentTextEditorFileId = fileEntry.id; textEditor_contentArea.value = fileEntry.content || '';
                textEditor_status.textContent = `Status: Opened ${fileEntry.name}.`; textEditor_currentFileName.textContent = fileEntry.name;
                if (titleBarText) titleBarText.textContent = `🗒️ ${fileEntry.name} - Text Editor`;
            } else { textEditor_status.textContent = "Error: File not found or invalid."; if (titleBarText) titleBarText.textContent = `🗒️ Text Editor`; }
        } else { if (titleBarText) titleBarText.textContent = `🗒️ Text Editor`; }
    }
    if (textEditor_saveButton) {
        textEditor_saveButton.addEventListener('click', () => {
            if (!textEditor_contentArea || !textEditor_status) return; const content = textEditor_contentArea.value;
            if (currentTextEditorFileId) {
                const updatedFile = updateVFSEntry(currentTextEditorFileId, { content: content });
                if (updatedFile) { textEditor_status.textContent = `Status: File '${updatedFile.name}' saved.`; logK8osActivity("Text Editor", `Saved file: ${updatedFile.name}`); }
                else { textEditor_status.textContent = "Error: Could not save file."; }
            } else {
                let fileName = prompt("Enter file name (e.g., mydoc.txt):", "untitled.txt");
                if (fileName) {
                    const defaultParentId = currentFEVfsPathId && currentFEVfsPathId !== 'root' ? currentFEVfsPathId : (SPARKY_CREATIONS_VFS_ID || 'root');
                    const newFile = createVFSEntry({ type: 'file', name: fileName, mimeType: (fileName.endsWith('.html') || fileName.endsWith('.htm')) ? 'text/html' : 'text/plain', content: content, parentId: defaultParentId });
                    currentTextEditorFileId = newFile.id; textEditor_currentFileName.textContent = newFile.name;
                    const titleBarText = document.getElementById('textEditorWindow').querySelector('.title-bar-text');
                    if (titleBarText) titleBarText.textContent = `🗒️ ${newFile.name} - Text Editor`;
                    const parentFolder = getVFSEntry(newFile.parentId);
                    textEditor_status.textContent = `Status: File '${newFile.name}' saved to "${parentFolder ? parentFolder.name : 'Files (Root)'}".`;

                    if(newFile.parentId === 'root' && newFile.name !== SPARKY_CREATIONS_FOLDER_NAME) renderDesktopVFSIcons();
                    if(fe_fileListElement && newFile.parentId === currentFEVfsPathId) renderVFSFileList(currentFEVfsPathId);
                    logK8osActivity("Text Editor", `Saved new file: ${newFile.name}`);
                }
            }
        });
    }
    if (desktopElement) {
        desktopElement.addEventListener('dragover', (event) => { event.preventDefault(); event.dataTransfer.dropEffect = 'copy'; });
        desktopElement.addEventListener('drop', (event) => {
            event.preventDefault(); const files = event.dataTransfer.files;
            if (files.length > 0) {
                for (const file of files) {
                    if (file.type.startsWith('text/') || file.type === '' || file.type === 'application/octet-stream' || file.type.endsWith('json') || file.type.endsWith('javascript') || file.type.endsWith('xml') || file.type.endsWith('csv') || file.type.startsWith('image/svg+xml') || file.type.endsWith('html') || file.type.endsWith('htm')) {
                        const reader = new FileReader();
                        reader.onload = (e) => { createVFSEntry({ type: 'file', name: file.name, mimeType: file.type || 'text/plain', content: e.target.result, parentId: 'root' }); renderDesktopVFSIcons(); logK8osActivity("Desktop", `Dropped file: ${file.name}`); };
                        reader.onerror = (e) => { console.error("Error reading dropped file:", file.name, e); alert(`Error reading file: ${file.name}`); };
                        reader.readAsText(file);
                    } else { alert(`File type '${file.type}' not supported for Text Editor/Browser via drop. Only text-based and HTML/SVG files can be dropped for now.`); logK8osActivity("Desktop", `Dropped unsupported file: ${file.name} (${file.type})`); }
                }
            }
        });
        desktopElement.addEventListener('contextmenu', handleDesktopContextMenu);
    }
    let currentFEVfsPathId = 'root';
    function initFileExplorerAppForVFS(options = {}) {
        currentFEVfsPathId = options.vfsPathId || 'root';
        if (!fe_folderNameDisplayElement || !fe_searchInput || !fe_statusElement) { console.error("File Explorer UI missing for VFS!"); return; }
        const currentFolder = getVFSEntry(currentFEVfsPathId);
        fe_folderNameDisplayElement.textContent = `Folder: ${currentFolder ? currentFolder.name : (currentFEVfsPathId === 'root' ? 'Files (Root)' : 'Unknown')}`;
        fe_searchInput.value = ''; fe_searchInput.oninput = () => renderVFSFileList(currentFEVfsPathId, fe_searchInput.value.toLowerCase().trim());
        renderVFSFileList(currentFEVfsPathId);
    }
    function renderVFSFileList(parentId, searchTerm = '') {
        if (!fe_fileListElement || !fe_statusElement) return;
        let items = getVFSChildren(parentId); if (searchTerm) { items = items.filter(item => item.name.toLowerCase().includes(searchTerm)); }
        fe_fileListElement.innerHTML = '';
        if (parentId !== 'root') {
            const parentItem = getVFSEntry(parentId);
            if (parentItem && parentItem.parentId) {
                 const upListItem = document.createElement('li');
                 upListItem.dataset.itemId = parentItem.parentId;
                 upListItem.dataset.itemType = 'folder';
                 const iconSpan = document.createElement('span'); iconSpan.className = 'fe-item-icon'; iconSpan.textContent = '⤴️';
                 const link = document.createElement('a'); link.href = `#`; link.textContent = '.. (Up)';
                 upListItem.appendChild(iconSpan); upListItem.appendChild(link);
                 upListItem.addEventListener('dblclick', () => { initFileExplorerAppForVFS({ vfsPathId: parentItem.parentId }); });
                 fe_fileListElement.appendChild(upListItem);
            }
        }

        if (parentId === 'root' && !items.find(item => item.id === SPARKY_CREATIONS_VFS_ID) && SPARKY_CREATIONS_VFS_ID) {
            const sparkyFolderEntry = getVFSEntry(SPARKY_CREATIONS_VFS_ID);
            if (sparkyFolderEntry && (!searchTerm || sparkyFolderEntry.name.toLowerCase().includes(searchTerm))) {
                 items.unshift(sparkyFolderEntry);
            }
        }


        if (items.length === 0 && !fe_fileListElement.querySelector('li')) {
            fe_fileListElement.innerHTML = `<li>${searchTerm ? 'No matches.' : 'This folder is empty.'}</li>`;
        }


        items.forEach(item => {
            const listItem = document.createElement('li'); listItem.dataset.itemId = item.id; listItem.dataset.itemType = item.type;
            const iconSpan = document.createElement('span'); iconSpan.className = 'fe-item-icon';
            iconSpan.textContent = item.type === 'file' ? (item.name.endsWith('.html') || item.name.endsWith('.htm') ? '🌐' : '📄') : '📁';
            const link = document.createElement('a'); link.href = `#`; link.textContent = item.name;
            listItem.appendChild(iconSpan); listItem.appendChild(link);
            listItem.addEventListener('dblclick', () => {
                if (item.type === 'folder') { initFileExplorerAppForVFS({ vfsPathId: item.id }); }
                else if (item.type === 'file') {
                    if (item.mimeType === 'text/html' || item.name.endsWith('.html') || item.name.endsWith('.htm')) {
                        openNewBrowserWindow(null, item.id);
                    } else {
                        openWindow('textEditorWindow', { fileId: item.id });
                    }
                }
            });
            listItem.addEventListener('contextmenu', (e) => handleDesktopContextMenu(e, item.id));
            fe_fileListElement.appendChild(listItem);
        });
        fe_statusElement.textContent = `Status: ${fe_fileListElement.querySelectorAll('li[data-item-id]').length} item(s).`;
    }

    async function downloadVFSEntryAsZip(itemId) {
        if (typeof JSZip === 'undefined') {
            alert("JSZip library not loaded. Cannot create ZIP.");
            console.error("JSZip not found.");
            return;
        }

        const itemToZip = getVFSEntry(itemId);
        const zip = new JSZip();
        let zipFileName = "download.zip";

        const feStatusOriginal = fe_statusElement ? fe_statusElement.textContent : "";
        const updateFEStatus = (msg) => { if (fe_statusElement) fe_statusElement.textContent = `Status: ${msg}`; }

        updateFEStatus("Preparing ZIP...");

        try {
            if (itemId === 'root' || (itemToZip && itemToZip.type === 'folder')) {
                zipFileName = (itemToZip && itemId !== 'root' ? itemToZip.name : 'k8os_All_Files') + '.zip';
                updateFEStatus(`Zipping ${zipFileName}...`);

                async function addFolderToZip(folderId, currentZipFolder) {
                    const children = getVFSChildren(folderId);
                    for (const child of children) {
                        if (child.type === 'file') {
                            currentZipFolder.file(child.name, child.content || "", {
                                date: new Date(child.modified || Date.now())
                            });
                        } else if (child.type === 'folder') {
                           await addFolderToZip(child.id, currentZipFolder.folder(child.name));
                        }
                    }
                }
                 if (itemId === 'root') {
                    const rootChildren = getVFSChildren('root');
                    for (const child of rootChildren) {
                        if (child.id === SPARKY_CREATIONS_VFS_ID) {
                            const sparkyBaseFolder = zip.folder(SPARKY_CREATIONS_FOLDER_NAME);
                            await addFolderToZip(SPARKY_CREATIONS_VFS_ID, sparkyBaseFolder);
                        } else if (child.type === 'file') {
                            zip.file(child.name, child.content || "", { date: new Date(child.modified || Date.now()) });
                        } else if (child.type === 'folder') {
                            if (child.id !== SPARKY_CREATIONS_VFS_ID) {
                                await addFolderToZip(child.id, zip.folder(child.name));
                            }
                        }
                    }
                    if (!rootChildren.find(c => c.id === SPARKY_CREATIONS_VFS_ID) && SPARKY_CREATIONS_VFS_ID && getVFSEntry(SPARKY_CREATIONS_VFS_ID)) {
                         const sparkyBaseFolder = zip.folder(SPARKY_CREATIONS_FOLDER_NAME);
                         await addFolderToZip(SPARKY_CREATIONS_VFS_ID, sparkyBaseFolder);
                    }

                } else {
                    await addFolderToZip(itemId, zip);
                }


            } else if (itemToZip && itemToZip.type === 'file') {
                downloadVFSEntry(itemId);
                updateFEStatus(feStatusOriginal);
                return;
            } else {
                alert("Cannot ZIP this item type or item not found.");
                updateFEStatus(feStatusOriginal);
                return;
            }

            if (Object.keys(zip.files).length === 0) {
                alert("No files to add to ZIP (folder might be empty).");
                updateFEStatus(feStatusOriginal);
                return;
            }

            updateFEStatus("Generating ZIP file...");
            const content = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
            downloadFile(content, zipFileName, "application/zip");
            logK8osActivity("File System", `Downloaded ZIP: ${zipFileName}`);
            updateFEStatus("ZIP downloaded.");

        } catch (error) {
            console.error("Error creating ZIP:", error);
            alert(`Error creating ZIP: ${error.message}`);
            updateFEStatus(`ZIP Error: ${error.message.substring(0, 50)}`);
        } finally {
             setTimeout(() => { if (fe_statusElement && fe_statusElement.textContent.startsWith("Status: ZIP")) updateFEStatus(feStatusOriginal); }, 3000);
        }
    }

    function getStoredOrDefault(key, defaultValue) { return localStorage.getItem(key) || defaultValue; }
    function getCurrentGeminiModel() { return getStoredOrDefault('k8os_globalGeminiAiModel', DEFAULT_GEMINI_AI_MODEL); }
    function getCurrentGroqModel() { return getStoredOrDefault('k8os_globalGroqAiModel', DEFAULT_GROQ_AI_MODEL); }
    function getCurrentGroqMaxTokens() { return parseInt(getStoredOrDefault('k8os_globalGroqMaxTokens', DEFAULT_GROQ_MAX_TOKENS.toString()), 10); }
    function getCurrentOpenRouterModel() { return getStoredOrDefault('k8os_globalOpenRouterAiModel', DEFAULT_OPENROUTER_AI_MODEL); }
    function getCurrentOpenRouterHttpReferer() { return getStoredOrDefault('k8os_globalOpenRouterHttpReferer', ''); }
    function getCurrentDeepSeekModel() { return getStoredOrDefault('k8os_globalDeepSeekAiModel', DEFAULT_DEEPSEEK_CHAT_MODEL); }
    function getCurrentDeepSeekMaxTokens() { return parseInt(getStoredOrDefault('k8os_globalDeepSeekMaxTokens', DEFAULT_DEEPSEEK_MAX_TOKENS.toString()), 10); }
    function getCurrentHfModelId() { return getStoredOrDefault('k8os_globalHfModelId', DEFAULT_HF_MODEL_ID); }
    function getCurrentTransformersJsModelId() { return getStoredOrDefault('k8os_globalTransformersJsModelId', DEFAULT_TRANSFORMERSJS_MODEL_ID); }
    function getCurrentCustomEndpointUrl() { return getStoredOrDefault('k8os_globalCustomEndpointUrl', ''); }
    function getCurrentCustomModelId() { return getStoredOrDefault('k8os_globalCustomModelId', ''); }

    function getAppInstruction(appKey, defaultInstruction) { return getStoredOrDefault(`k8os_instr_${appKey}`, defaultInstruction); }

    function loadApiKey() {
        selectedApiProvider = getStoredOrDefault('k8os_apiProvider', 'gemini');
        window.GLOBAL_GEMINI_API_KEY = localStorage.getItem('k8os_GlobalGeminiApiKey');
        window.GLOBAL_GROQ_API_KEY = localStorage.getItem('k8os_GlobalGroqApiKey');
        window.GLOBAL_OPENROUTER_API_KEY = localStorage.getItem('k8os_GlobalOpenRouterApiKey');
        window.GLOBAL_DEEPSEEK_API_KEY = localStorage.getItem('k8os_GlobalDeepSeekApiKey');
        window.GLOBAL_HF_TOKEN = localStorage.getItem('k8os_GlobalHfToken');
        window.GLOBAL_TRANSFORMERSJS_MODEL_ID = getCurrentTransformersJsModelId();
        window.GLOBAL_CUSTOM_API_KEY = localStorage.getItem('k8os_GlobalCustomApiKey');


        const initialBgColor = localStorage.getItem('k8os_desktopBgColor') || DEFAULT_BG_COLOR;
        document.body.style.backgroundColor = initialBgColor;
        const initialBgImageUrl = localStorage.getItem('k8os_desktopBgImageUrl');
        const initialBgImageSize = localStorage.getItem('k8os_desktopBgImageSize') || 'cover';
        const initialBgImageRepeat = localStorage.getItem('k8os_desktopBgImageRepeat') || 'no-repeat';
        if (initialBgImageUrl) { applyCustomImageBackground(initialBgImageUrl, initialBgImageSize, initialBgImageRepeat, false);  }
        if (apiProviderSelect) apiProviderSelect.value = selectedApiProvider;
        updateApiKeyUI(); enableAppButtons(); initAllAiApps(); initSystemSettingsApp();
        loadVFS();
        if (localStorage.getItem('k8os_assistant_enabled') === 'true' &&
            (window.GLOBAL_GEMINI_API_KEY || window.GLOBAL_GROQ_API_KEY || window.GLOBAL_OPENROUTER_API_KEY || window.GLOBAL_DEEPSEEK_API_KEY ||
             window.GLOBAL_HF_TOKEN || window.GLOBAL_TRANSFORMERSJS_MODEL_ID ||
             (window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl())
            )
        ) {
            initAndShowAssistant();
            initSparkyDynamicBehavior();
        }

        if (customSetupLink) {
            customSetupLink.addEventListener('click', (e) => {
                e.preventDefault();
                const content = getCustomSetupGuideContent();
                openSetupGuideModal(content.title, content.instructions, content.codeSnippet);
            });
        }
    }
    function updateApiKeyUI() {
        if (!apiKeyInputLabel || !apiKeyInput || !apiKeyStatus || !geminiApiKeyLink || !groqApiKeyLink || !openrouterApiKeyLink || !deepseekApiKeyLink || !hfApiKeyLink || !customSetupLink || !apiKeyInfoText || !apiKeyLinksContainer) return;
        let currentKey = null; let providerName = ''; let keyLabel = 'API Key/Token:';
        apiKeyInput.style.display = 'block'; apiKeyInputLabel.style.display = 'block';
        apiKeyInfoText.style.display = 'none'; apiKeyLinksContainer.style.display = 'block';

        geminiApiKeyLink.style.display = 'none'; groqApiKeyLink.style.display = 'none'; openrouterApiKeyLink.style.display = 'none'; deepseekApiKeyLink.style.display = 'none'; hfApiKeyLink.style.display = 'none'; customSetupLink.style.display = 'none';
        if (geminiModelSettingsDiv) geminiModelSettingsDiv.style.display = 'none';
        if (groqModelSettingsDiv) groqModelSettingsDiv.style.display = 'none';
        if (openrouterModelSettingsDiv) openrouterModelSettingsDiv.style.display = 'none';
        if (deepseekModelSettingsDiv) deepseekModelSettingsDiv.style.display = 'none';
        if (hfModelSettingsDiv) hfModelSettingsDiv.style.display = 'none';
        if (transformersjsModelSettingsDiv) transformersjsModelSettingsDiv.style.display = 'none';
        if (customProviderSettingsDiv) customProviderSettingsDiv.style.display = 'none';


        switch (selectedApiProvider) {
            case 'gemini': currentKey = window.GLOBAL_GEMINI_API_KEY; providerName = 'Gemini'; keyLabel = 'Gemini API Key:'; geminiApiKeyLink.style.display = 'inline'; if (geminiModelSettingsDiv) geminiModelSettingsDiv.style.display = 'block'; break;
            case 'groq': currentKey = window.GLOBAL_GROQ_API_KEY; providerName = 'Groq'; keyLabel = 'Groq API Key:'; groqApiKeyLink.style.display = 'inline'; if (groqModelSettingsDiv) groqModelSettingsDiv.style.display = 'block'; break;
            case 'openrouter': currentKey = window.GLOBAL_OPENROUTER_API_KEY; providerName = 'OpenRouter'; keyLabel = 'OpenRouter API Key:'; openrouterApiKeyLink.style.display = 'inline'; if (openrouterModelSettingsDiv) openrouterModelSettingsDiv.style.display = 'block'; break;
            case 'deepseek': currentKey = window.GLOBAL_DEEPSEEK_API_KEY; providerName = 'DeepSeek'; keyLabel = 'DeepSeek API Key:'; deepseekApiKeyLink.style.display = 'inline'; if (deepseekModelSettingsDiv) deepseekModelSettingsDiv.style.display = 'block'; break;
            case 'huggingface': currentKey = window.GLOBAL_HF_TOKEN; providerName = 'Hugging Face'; keyLabel = 'HF API Token:'; hfApiKeyLink.style.display = 'inline'; if (hfModelSettingsDiv) hfModelSettingsDiv.style.display = 'block'; break;
            case 'transformersjs':
                providerName = 'Transformers.js (Local LLM)';
                keyLabel = 'Model ID (Local):';
                apiKeyInput.style.display = 'none';
                apiKeyInputLabel.style.display = 'none';
                apiKeyInfoText.textContent = 'No API Key needed for Transformers.js. Configure Model ID in System Settings.';
                apiKeyInfoText.style.display = 'block';
                apiKeyLinksContainer.style.display = 'none';
                if (transformersjsModelSettingsDiv) transformersjsModelSettingsDiv.style.display = 'block';
                break;
            case 'custom':
                currentKey = window.GLOBAL_CUSTOM_API_KEY; providerName = 'Custom Endpoint'; keyLabel = 'Custom Endpoint API Key:'; customSetupLink.style.display = 'inline';
                apiKeyInfoText.textContent = "Enter your Custom Endpoint's specific API key here. Configure URL in System Settings.";
                apiKeyInfoText.style.display = 'block';
                if (customProviderSettingsDiv) customProviderSettingsDiv.style.display = 'block';
                break;
        }
        apiKeyInputLabel.textContent = keyLabel; apiKeyInput.value = currentKey || '';
        if (selectedApiProvider === 'transformersjs') {
            apiKeyStatus.textContent = `Status: ${providerName} selected. Configure Model ID in System Settings.`;
        } else if (currentKey) {
            apiKeyStatus.textContent = `Status: ${providerName} Key/Token Loaded.`;
        } else {
            apiKeyStatus.textContent = `Status: No ${providerName} key/token set.`;
        }
    }
    if (apiProviderSelect) { apiProviderSelect.addEventListener('change', (e) => { selectedApiProvider = e.target.value; localStorage.setItem('k8os_apiProvider', selectedApiProvider); updateApiKeyUI(); enableAppButtons(); initAllAiApps(); initSystemSettingsApp(); if (assistantIsVisible) { if (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) { } else if (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) { } else { assistant_gemini_model = null; } } }); }
    if (saveApiKeyButton) {
        saveApiKeyButton.addEventListener('click', () => {
            if (selectedApiProvider === 'transformersjs') {
                 apiKeyStatus.textContent = `Status: Transformers.js selected. Configure Model ID in System Settings.`;
                 enableAppButtons(); initAllAiApps();
                 if (window.GLOBAL_TRANSFORMERSJS_MODEL_ID) {
                     localStorage.setItem('k8os_assistant_enabled', 'true');
                     initAndShowAssistant(); initSparkyDynamicBehavior();
                     updateAssistantSpeech(`Sparky ready with local LLM!`);
                 }
                 return;
            }

            const key = apiKeyInput.value.trim(); let storageKey = ''; let providerName = ''; let globalVarSetter = () => {};
            switch (selectedApiProvider) {
                case 'gemini': storageKey = 'k8os_GlobalGeminiApiKey'; providerName = 'Gemini'; globalVarSetter = (k) => window.GLOBAL_GEMINI_API_KEY = k; break;
                case 'groq': storageKey = 'k8os_GlobalGroqApiKey'; providerName = 'Groq'; globalVarSetter = (k) => window.GLOBAL_GROQ_API_KEY = k; break;
                case 'openrouter': storageKey = 'k8os_GlobalOpenRouterApiKey'; providerName = 'OpenRouter'; globalVarSetter = (k) => window.GLOBAL_OPENROUTER_API_KEY = k; break;
                case 'deepseek': storageKey = 'k8os_GlobalDeepSeekApiKey'; providerName = 'DeepSeek'; globalVarSetter = (k) => window.GLOBAL_DEEPSEEK_API_KEY = k; break;
                case 'huggingface': storageKey = 'k8os_GlobalHfToken'; providerName = 'Hugging Face'; globalVarSetter = (k) => window.GLOBAL_HF_TOKEN = k; break;
                case 'custom': storageKey = 'k8os_GlobalCustomApiKey'; providerName = 'Custom Endpoint'; globalVarSetter = (k) => window.GLOBAL_CUSTOM_API_KEY = k; break;
            }
            if (key) { globalVarSetter(key); localStorage.setItem(storageKey, key); apiKeyStatus.textContent = `Status: ${providerName} Key/Token Saved!`; enableAppButtons(); initAllAiApps(); localStorage.setItem('k8os_assistant_enabled', 'true'); initAndShowAssistant(); initSparkyDynamicBehavior(); updateAssistantSpeech(`Hi! I'm Sparky. Ready to create!`); }
            else { globalVarSetter(null); localStorage.removeItem(storageKey); apiKeyStatus.textContent = `Status: ${providerName} Key/Token cleared.`; disableAppButtons(); localStorage.removeItem('k8os_assistant_enabled'); hideAssistant(); stopAssistantSummaryTimer(); stopSparkyMovement(); }
        });
    }
    function logK8osActivity(toolName, actionDescription) { const now = Date.now(); k8osActivityLog = k8osActivityLog.filter(entry => now - entry.timestamp < ACTIVITY_LOG_MAX_AGE); k8osActivityLog.push({ timestamp: now, tool: toolName, action: actionDescription.substring(0, 100) }); }
    function startAssistantSummaryTimer() {
        if (assistantSummaryIntervalId) clearInterval(assistantSummaryIntervalId);
        assistantSummaryIntervalId = setInterval(async () => {
            if (!assistantIsVisible || assistantIsThinking || assistantIsProcessingCommand || !localStorage.getItem('k8os_assistant_enabled')) return;
            const threeMinutesAgo = Date.now() - ASSISTANT_SUMMARY_INTERVAL; const recentActivities = k8osActivityLog.filter(entry => entry.timestamp >= threeMinutesAgo);
            if (recentActivities.length === 0) { return; }
            let activitySummaryForPrompt = "User's recent k8OS activities (last 3 mins):\n"; const distinctRecentActivities = []; const activityTexts = new Set();
            for (let i = recentActivities.length - 1; i >= 0 && distinctRecentActivities.length < 4; i--) { const activityText = `In ${recentActivities[i].tool}: ${recentActivities[i].action}`; if (!activityTexts.has(activityText)) { distinctRecentActivities.unshift(activityText); activityTexts.add(activityText); } }
            distinctRecentActivities.forEach(text => { activitySummaryForPrompt += `- ${text}\n`; });
            if (recentActivities.length > distinctRecentActivities.length) { activitySummaryForPrompt += "- And perhaps a few more creative sparks!\n"; }
            const summaryPrompt = `You are Sparky, a friendly k8OS assistant.\n${activitySummaryForPrompt}\nGive a very short, cheerful, and slightly playful summary of their recent activity (1-2 brief sentences, max 20 words). Be encouraging. Don't list items.\nExamples: "Wow, busy bee! Creating cool stuff!", "Looks like you're on a creative roll! Keep it up!", "Lots of awesome things happening! Nice work!"\nOutput ONLY the summary, no extra formatting.`;
            assistantIsThinking = true;
            let summaryComment = "You've been busy!";
            try {
                const statusUpdater = (msg) => { /* Sparky doesn't need detailed model loading status here */ };
                summaryComment = await callCurrentAiProviderForText(summaryPrompt, 30, 0.8, statusUpdater);
            } catch (error) { console.warn(`Assistant summary generation error:`, error); summaryComment = "You're doing great things!"; }  finally { assistantIsThinking = false; }
            summaryComment = summaryComment.replace(/^["']|["']$/g, '').replace(/\n/g, ' ').trim();
            if (summaryComment) updateAssistantSpeech(summaryComment, false);
        }, ASSISTANT_SUMMARY_INTERVAL);
    }
    function stopAssistantSummaryTimer() { if (assistantSummaryIntervalId) { clearInterval(assistantSummaryIntervalId); assistantSummaryIntervalId = null; } }

    function initAndShowAssistant() {
        if (!assistantContainer) {
            assistantContainer = document.getElementById('k8osAssistant');
            assistantSpeechBubble = document.getElementById('k8osAssistant_speechBubble');
            assistantSpeechText = document.getElementById('k8osAssistant_speechText');
            assistantAvatarSVG = document.getElementById('assistantAvatarSVG');
            if (assistantAvatarSVG) { assistantSparkyMouth = assistantAvatarSVG.querySelector('#sparkyMouth'); }

            const assistantInputContainer = document.getElementById('k8osAssistant_inputContainer');
            const assistantCommandInput = document.getElementById('k8osAssistant_commandInput');
            const assistantSendCommandButton = document.getElementById('k8osAssistant_sendCommandButton');

            if (assistantContainer && assistantAvatarSVG && assistantInputContainer && assistantCommandInput && assistantSendCommandButton) {
                 assistantAvatarSVG.addEventListener('click', () => {
                    if (assistantIsProcessingCommand) {
                        updateAssistantSpeech("Working...", true, false);
                        return;
                    }
                    promptSparkyForCommand();
                });
            }
        }
        if (assistantContainer) {
            assistantContainer.style.display = 'flex';
            assistantIsVisible = true;
            if (!localStorage.getItem('k8os_assistant_has_greeted')) {
                updateAssistantSpeech("Sparky online!", false, false, true);
                localStorage.setItem('k8os_assistant_has_greeted', 'true');
            }
            startAssistantSummaryTimer();
        }
    }
    function hideAssistant() {
        if (assistantContainer) { assistantContainer.style.display = 'none'; }
        assistantIsVisible = false;
        if (assistantSpeechBubble) assistantSpeechBubble.classList.remove('visible');
        const inputContainer = document.getElementById('k8osAssistant_inputContainer');
        if (inputContainer) inputContainer.style.display = 'none';
        if (assistantSparkyMouth) assistantSparkyMouth.classList.remove('talking');
        clearTimeout(assistantSpeechTimeout);
        stopAssistantSummaryTimer();
        stopSparkyMovement();
    }
    function updateAssistantSpeech(message, autoHide = true, isTemporaryThinkingMessage = false, keepVisibleLonger = false) {
        if (!assistantIsVisible || !assistantSpeechBubble || !assistantSpeechText) return;

        const inputContainer = document.getElementById('k8osAssistant_inputContainer');
        if (inputContainer && inputContainer.style.display === 'flex' && !isTemporaryThinkingMessage) {
            // Don't immediately show speech bubble if input is active, unless it's a thinking message
        } else {
            assistantSpeechText.textContent = message;
            assistantSpeechBubble.classList.add('visible');
        }

        if (assistantSparkyMouth) { if (!isTemporaryThinkingMessage && message.length > 0) { assistantSparkyMouth.classList.add('talking'); } else { assistantSparkyMouth.classList.remove('talking'); } }
        clearTimeout(assistantSpeechTimeout);
        if (autoHide && !isTemporaryThinkingMessage) { assistantSpeechTimeout = setTimeout(() => { assistantSpeechBubble.classList.remove('visible'); if (assistantSparkyMouth) assistantSparkyMouth.classList.remove('talking'); }, keepVisibleLonger ? 10000 : 5000); } // Reduced duration
    }


    async function ensureTransformersJsPipeline(modelId, progressFn) {
        if (isTransformersJsModelLoading && currentLoadedTransformersJsModel === modelId) {
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => {
                    if (!isTransformersJsModelLoading) {
                        clearInterval(interval);
                        if (transformersJsPipelineInstance && currentLoadedTransformersJsModel === modelId) {
                            resolve(transformersJsPipelineInstance);
                        } else {
                            reject(new Error(`Failed to get pipeline for ${modelId} after waiting.`));
                        }
                    }
                }, 100);
            });
        }
        if (!transformersJsPipelineInstance || currentLoadedTransformersJsModel !== modelId) {
            if(isTransformersJsModelLoading) {
                 throw new Error("Transformers.js: Cannot load a new model while another is already loading.");
            }
            isTransformersJsModelLoading = true;
            currentLoadedTransformersJsModel = modelId;
            try {
                if (progressFn) progressFn({ status: 'loading', file: modelId, progress: 0 });
                transformersJsPipelineInstance = await transformersPipeline('text-generation', modelId, {
                    progress_callback: (progress) => {
                        if (progressFn) progressFn(progress);
                        if (systemSettings_transformersjs_status && document.getElementById('systemSettingsWindow')?.style.display === 'flex') {
                             systemSettings_transformersjs_status.textContent = `Loading ${modelId}: ${Math.round(progress.progress)}% (${progress.file})`;
                        }
                    }
                });
                if (progressFn) progressFn({ status: 'loaded', file: modelId, progress: 100 });
                 if (systemSettings_transformersjs_status && document.getElementById('systemSettingsWindow')?.style.display === 'flex') {
                     systemSettings_transformersjs_status.textContent = `Model ${modelId} loaded.`;
                }
            } catch (error) {
                if (progressFn) progressFn({ status: 'error', file: modelId, message: error.message });
                 if (systemSettings_transformersjs_status && document.getElementById('systemSettingsWindow')?.style.display === 'flex') {
                     systemSettings_transformersjs_status.textContent = `Error loading ${modelId}: ${error.message.substring(0,100)}`;
                }
                transformersJsPipelineInstance = null;
                currentLoadedTransformersJsModel = null;
                throw error;
            } finally {
                isTransformersJsModelLoading = false;
            }
        }
        return transformersJsPipelineInstance;
    }

    async function callTransformersJsApi(promptContent, maxTokens, temperature, statusUpdater = null) {
        const modelId = getCurrentTransformersJsModelId();
        if (!modelId) {
            throw new Error("Transformers.js Model ID not configured in System Settings.");
        }
        const progressFnForPipeline = (progress) => {
            if (statusUpdater) {
                if (progress.status === 'loading') { statusUpdater(`Loading ${progress.file}: ${Math.round(progress.progress)}%`); }
                else if (progress.status === 'loaded') { statusUpdater(`Model ${progress.file} loaded.`); }
                else if (progress.status === 'error') { statusUpdater(`Error loading ${progress.file}: ${progress.message}`); }
                else { statusUpdater(`Loading ${modelId}: ${Math.round(progress.progress || 0)}% (${progress.file || 'model files'})`); }
            }
        };
        try {
            const generator = await ensureTransformersJsPipeline(modelId, progressFnForPipeline);
            if (statusUpdater) statusUpdater(`Generating with ${modelId}...`);
            const generationParams = { max_new_tokens: maxTokens || DEFAULT_TRANSFORMERSJS_MAX_NEW_TOKENS, num_return_sequences: 1, do_sample: true, temperature: temperature, top_k: 50, };
            if (modelId.toLowerCase().includes('coder')) { generationParams.temperature = 0.2; generationParams.top_k = 10; }
            const result = await generator(promptContent, generationParams);
            if (result && Array.isArray(result) && result.length > 0 && result[0].generated_text) { if (statusUpdater) statusUpdater("Generation complete."); return result[0].generated_text; }
            else if (typeof result === 'string') { if (statusUpdater) statusUpdater("Generation complete."); return result; }
            else { if (statusUpdater) statusUpdater("Generation finished, but no text was returned or format unexpected."); console.warn("Unexpected result format from Transformers.js model:", result); throw new Error("No output or unexpected format received from Transformers.js model.");}
        } catch (error) { if (statusUpdater) statusUpdater(`Error: ${error.message.substring(0,150)}`); throw error; }
    }

    async function callCustomEndpointApi(endpointUrl, apiKey, modelId, promptContent, maxTokens, temperature) {
        if (!endpointUrl) {
            throw new Error("Custom Endpoint URL not configured.");
        }
        if (!apiKey && selectedApiProvider !== 'transformersjs') { // Transformers.js doesn't use this API key path
            throw new Error("Custom Endpoint API Key not set.");
        }

        const payload = {
            prompt: promptContent,
            model: modelId || undefined, // Send model ID if provided
            max_tokens: maxTokens,
            temperature: temperature,
        };

        try {
            const headers = {
                'Content-Type': 'application/json',
            };
            if (apiKey) { // Only add auth header if API key is present
                headers['Authorization'] = `Bearer ${apiKey}`;
            }

            const response = await fetch(endpointUrl, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error("Custom Endpoint API Error Response Text:", errorText);
                let errorMessage = `Custom Endpoint request failed: ${response.status} ${response.statusText}. URL: ${endpointUrl}.`;
                try {
                    const errorData = JSON.parse(errorText);
                    errorMessage += ` ${errorData?.error || errorData?.message || ''}`;
                } catch (e) {
                    errorMessage += ` Response: ${errorText.substring(0, 100)}...`;
                }
                throw new Error(errorMessage);
            }

            const data = await response.json();
            if (data && data.response) { // Expecting a { "response": "text output" } structure
                return data.response;
            } else if (data && typeof data.text === 'string') { // Fallback for { "text": "..." }
                return data.text;
            } else if (data && typeof data === 'string'){ // Fallback for raw string
                return data;
            }
             else {
                console.warn("Custom Endpoint API response format unexpected:", data);
                throw new Error("Custom Endpoint API response format unexpected. Expected { \"response\": \"...\" }.");
            }
        } catch (error) {
            console.error("Error calling Custom Endpoint API:", error);
            throw error;
        }
    }


    async function callCurrentAiProviderForText(promptContent, maxTokens = 50, temperature = 0.8, statusUpdater = null) {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());

        if (!keyAvailable) {
            let missingInfo = "API key/Model ID";
            if (selectedApiProvider === 'custom' && !getCurrentCustomEndpointUrl()) missingInfo = "Custom Endpoint URL";
            else if (selectedApiProvider === 'custom' && !window.GLOBAL_CUSTOM_API_KEY) missingInfo = "Custom API Key";
            throw new Error(`${missingInfo} for current provider not available/configured.`);
        }

        if (selectedApiProvider === 'gemini') {
            if (!assistant_gemini_model) {
                const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                assistant_gemini_model = genAI.getGenerativeModel({
                    model: getCurrentGeminiModel(),
                    safetySettings: [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ],
                });
            }
            const result = await assistant_gemini_model.generateContent({
                contents: [{role: "user", parts: [{text: promptContent}]}],
                generationConfig: { temperature: temperature, maxOutputTokens: maxTokens }
            });
            return result.response.text().trim();
        } else if (selectedApiProvider === 'groq') {
            const messages = [{ role: "user", content: promptContent }];
            return await callGroqApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'openrouter') {
            const messages = [{ role: "user", content: promptContent }];
            return await callOpenRouterApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'deepseek') {
            const messages = [{ role: "user", content: promptContent }];
            return await callDeepSeekApi(messages, temperature, maxTokens);
        } else if (selectedApiProvider === 'huggingface') {
            return await callHuggingFaceApi(getCurrentHfModelId(), { inputs: promptContent, parameters: { max_new_tokens: maxTokens, temperature: temperature } });
        } else if (selectedApiProvider === 'transformersjs') {
            return await callTransformersJsApi(promptContent, maxTokens, temperature, statusUpdater);
        } else if (selectedApiProvider === 'custom') {
            return await callCustomEndpointApi(
                getCurrentCustomEndpointUrl(),
                window.GLOBAL_CUSTOM_API_KEY,
                getCurrentCustomModelId(),
                promptContent,
                maxTokens || DEFAULT_CUSTOM_MAX_TOKENS,
                temperature
            );
        }
        return "AI provider not supported for this operation yet.";
    }

    function promptSparkyForCommand() {
        const inputContainer = document.getElementById('k8osAssistant_inputContainer');
        const commandInput = document.getElementById('k8osAssistant_commandInput');
        const sendButton = document.getElementById('k8osAssistant_sendCommandButton');
        const speechBubble = document.getElementById('k8osAssistant_speechBubble');

        if (inputContainer && commandInput && sendButton && speechBubble) {
            speechBubble.classList.remove('visible');
            inputContainer.style.display = 'flex';
            commandInput.value = '';
            commandInput.focus();

            const newSendButton = sendButton.cloneNode(true);
            sendButton.parentNode.replaceChild(newSendButton, sendButton);
            const newCommandInput = commandInput.cloneNode(true);
            commandInput.parentNode.replaceChild(newCommandInput, commandInput);

            const handleSendCommand = () => {
                const userInput = newCommandInput.value.trim();
                inputContainer.style.display = 'none';
                if (userInput) {
                    processSparkyCommand(userInput);
                } else {
                    updateAssistantSpeech("?", true);
                }
            };
            const handleEnterKey = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleSendCommand(); } };

            newSendButton.addEventListener('click', handleSendCommand);
            newCommandInput.addEventListener('keypress', handleEnterKey);
        } else {
            console.error("Sparky input UI elements not found!");
            const userInput = prompt("Sparky: What's up?");
            if (userInput && userInput.trim() !== "") processSparkyCommand(userInput.trim());
        }
    }

    function createSparkyHtmlPopupWindowHTML(instanceId, initialTitle = "✨ Sparky's Creation") {
        return `
            <div class="title-bar">
                <span class="title-bar-text" id="${instanceId}_titleBarText">${initialTitle}</span>
                <div class="title-bar-controls">
                    <button class="minimize-button" title="Minimize">0</button>
                    <button class="fullscreen-button" title="Toggle Fullscreen">1</button>
                    <button class="close-button" title="Close">r</button>
                </div>
            </div>
            <div class="window-content">
                <iframe id="${instanceId}_iframeContent" class="sparkyHtmlPopupWindow_iframeContent" sandbox="allow-scripts allow-forms allow-popups allow-same-origin"></iframe>
            </div>
            <div id="${instanceId}_status" class="status-bar">Status: Idle</div>
        `;
    }

    async function createSparkyHtmlPopupWindow(htmlContent, userRequest) {
        sparkyHtmlPopupCounter++;
        const instanceId = `sparkyHtmlPopup-${sparkyHtmlPopupCounter}`;
        const windowEl = document.createElement('div');
        windowEl.id = instanceId;
        windowEl.className = 'window sparkyHtmlPopupWindow';
        windowEl.dataset.isPopup = "true"; // Mark as popup to exclude from taskbar

        const randomWidth = Math.floor(Math.random() * 200) + 400;
        const randomHeight = Math.floor(Math.random() * 150) + 300;
        windowEl.style.width = `${randomWidth}px`;
        windowEl.style.height = `${randomHeight}px`;

        const desktopWidth = desktopElement.clientWidth;
        const desktopHeight = desktopElement.clientHeight;
        const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;
        windowEl.style.top = `${Math.random() * (desktopHeight - randomHeight - taskbarHeight - 20) + 10}px`;
        windowEl.style.left = `${Math.random() * (desktopWidth - randomWidth - 20) + 10}px`;

        const title = `✨ Sparky: ${userRequest.substring(0, 25)}${userRequest.length > 25 ? '...' : ''}`;
        windowEl.innerHTML = createSparkyHtmlPopupWindowHTML(instanceId, title);
        desktopElement.appendChild(windowEl);
        initializeWindowBehavior(windowEl);

        const iframe = document.getElementById(`${instanceId}_iframeContent`);
        const status = document.getElementById(`${instanceId}_status`);

        if (iframe && status) {
            if (htmlContent && (htmlContent.toLowerCase().includes("<html") || htmlContent.toLowerCase().includes("<body")) ) {
                iframe.srcdoc = htmlContent;
                status.textContent = "Content loaded.";

                // Save to VFS in Sparky's Creations folder
                const sparkyFolderId = ensureSparkyCreationsFolder();
                const filename = `sparky-${userRequest.substring(0,15).replace(/[^a-z0-9]/gi, '_') || 'creation'}-${sparkyHtmlPopupCounter}.html`;
                createVFSEntry({ type: 'file', name: filename, mimeType: 'text/html', content: htmlContent, parentId: sparkyFolderId });

                if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === sparkyFolderId)) {
                    renderVFSFileList(currentFEVfsPathId); // Refresh FE if viewing root or Sparky's folder
                }
                updateAssistantSpeech(`I've also saved "${filename}" to your "${SPARKY_CREATIONS_FOLDER_NAME}" folder!`, true, false, true);

            } else {
                iframe.srcdoc = `<p style="color:red; padding:10px;">Sorry, I couldn't generate valid HTML for that request.<br>Raw AI output: <pre>${(htmlContent || "None").replace(/</g, "&lt;")}</pre></p>`;
                status.textContent = "Error: Invalid HTML generated.";
            }
        }
        openWindow(instanceId, {}, true); // Pass true for isPopup
        return windowEl;
    }

    async function processSparkyCommand(command, baseParentIdOverride = null) {
        logK8osActivity("Sparky Command", command);
        assistantIsProcessingCommand = true;
        const sparkyStatusUpdater = (msg) => updateAssistantSpeech(msg, true, true);
        updateAssistantSpeech("Working on it...", false, true);

        const lowerCommand = command.toLowerCase();
        let baseParentIdForSparkyPlan = baseParentIdOverride || ensureSparkyCreationsFolder();

        if (lowerCommand.startsWith("sparky, create game")) {
             try {
                const ideaMatch = command.match(/Idea:\s*(.+?)\s*(Player SVG:|Item SVG:|Music:|$)/i);
                const playerSvgMatch = command.match(/Player SVG:\s*(.+?)\s*(Item SVG:|Music:|$)/i);
                const itemSvgMatch = command.match(/Item SVG:\s*(.+?)\s*(Music:|$)/i);
                const musicMatch = command.match(/Music:\s*(.+?)\s*$/i);

                const gameIdea = ideaMatch ? ideaMatch[1].trim() : "a simple game";
                const playerSvgDesc = playerSvgMatch ? playerSvgMatch[1].trim() : "player object";
                const itemSvgDesc = itemSvgMatch ? itemSvgMatch[1].trim() : "item object";
                const musicDesc = musicMatch ? musicMatch[1].trim() : "background music";

                updateAssistantSpeech(`Making game: "${gameIdea.substring(0,20)}..."`, false, false, true);

                const playerSvgCode = await internal_generateSingleSvg(playerSvgDesc, false, sparkyStatusUpdater);
                if (!playerSvgCode) { updateAssistantSpeech("Player SVG failed. Stopping.", false, false, true); assistantIsProcessingCommand = false; return; }

                const itemSvgCode = await internal_generateSingleSvg(itemSvgDesc, false, sparkyStatusUpdater);
                if (!itemSvgCode) { updateAssistantSpeech("Item SVG failed. Stopping.", false, false, true); assistantIsProcessingCommand = false; return; }

                const soundJsCode = await internal_generateSingleSoundJs(musicDesc, sparkyStatusUpdater);
                if (!soundJsCode) { updateAssistantSpeech("Music code failed. Stopping.", false, false, true); assistantIsProcessingCommand = false; return; }

                const gamePlan = {
                    game_mechanic: gameIdea,
                    svg_assets: [ { description: playerSvgDesc, animated: false }, { description: itemSvgDesc, animated: false } ],
                    sound_effects: [ musicDesc ]
                };
                const svgAssetsArray = [playerSvgCode, itemSvgCode];
                const soundJsArray = [soundJsCode];

                const gameHtml = await executeGameGenerationFromPlan(gameIdea, gamePlan, svgAssetsArray, soundJsArray, sparkyStatusUpdater);

                if (gameHtml) {
                    await processAndDisplayGameCode(gameHtml, gameIdea);
                    updateAssistantSpeech("Game ready! (And saved to Sparky's Creations)", false, false, true);
                } else {
                    updateAssistantSpeech("Game creation failed.", false, false, true);
                }
            } catch (e) {
                console.error("Error in Sparky 'create game' command:", e);
                updateAssistantSpeech("Error creating game: " + e.message.substring(0,100), false, false, true);
            }
        } else if (lowerCommand.startsWith("sparky, create file system based on editor content") || lowerCommand.startsWith("sparky, create file system. plan:") || lowerCommand.startsWith("sparky, create file system.")) {
            let userRequestForAISystemPlan = command;
            let explicitBaseParentId = baseParentIdForSparkyPlan;

            if (lowerCommand.startsWith("sparky, create file system based on editor content")) {
                updateAssistantSpeech("Processing editor content for file system structure...", false, true, true);
                explicitBaseParentId = baseParentIdOverride || ensureSparkyCreationsFolder();
            } else if (lowerCommand.startsWith("sparky, create file system. plan:")) {
                 updateAssistantSpeech("Creating file system from plan...", false, true, true);
                 const planContentMatch = command.match(/plan:\s*([\s\S]+)$/i);
                 if (planContentMatch && planContentMatch[1]) {
                     userRequestForAISystemPlan = planContentMatch[1].trim();
                     explicitBaseParentId = baseParentIdForSparkyPlan;
                 } else {
                     updateAssistantSpeech("File system plan not found or invalid.", true, false, true);
                     assistantIsProcessingCommand = false; return;
                 }
            } else if (lowerCommand.startsWith("sparky, create file system.")){
                 updateAssistantSpeech("Interpreting file system request...", false, true, true);
                 userRequestForAISystemPlan = command.substring("sparky, create file system.".length).trim();
                 explicitBaseParentId = baseParentIdForSparkyPlan;
            }


            if (explicitBaseParentId !== 'root' && !getVFSEntry(explicitBaseParentId)) {
                 updateAssistantSpeech(`Error: Specified base parent folder ID '${explicitBaseParentId}' does not exist. Defaulting to Sparky's Creations folder.`, true, false, true);
                 explicitBaseParentId = ensureSparkyCreationsFolder();
            }


            const finalSparkyFileSystemPrompt = DEFAULT_SPARKY_FILESYSTEM_GENERATOR_PROMPT
                .replace("{USER_REQUEST}", userRequestForAISystemPlan)
                .replace(/{BASE_PARENT_ID}/g, explicitBaseParentId);

            let aiPlanResponseText;
            try {
                aiPlanResponseText = await callCurrentAiProviderForText(finalSparkyFileSystemPrompt, 4000, 0.3, sparkyStatusUpdater);
                let cleanedJsonString = aiPlanResponseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
                const jsonStart = cleanedJsonString.indexOf('['); const jsonEnd = cleanedJsonString.lastIndexOf(']');
                if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) { cleanedJsonString = cleanedJsonString.substring(jsonStart, jsonEnd + 1); }

                const planActions = JSON.parse(cleanedJsonString);
                if (Array.isArray(planActions)) {
                    const tempIdToVfsIdMap = {};
                    tempIdToVfsIdMap[explicitBaseParentId] = explicitBaseParentId;
                    if (explicitBaseParentId !== 'root') { tempIdToVfsIdMap['root'] = 'root'; }


                    let successCount = 0;
                    for (const action of planActions) {
                        if (!action.action || !action.name || !action.parentId || !action.id) {
                            updateAssistantSpeech(`Skipping invalid action in plan: ${JSON.stringify(action).substring(0,50)}...`, true, false, true);
                            continue;
                        }
                        let resolvedActionParentId = action.parentId === "{BASE_PARENT_ID}" ? explicitBaseParentId : action.parentId;
                        const actualParentId = tempIdToVfsIdMap[resolvedActionParentId] || resolvedActionParentId;

                        if (!getVFSEntry(actualParentId) && actualParentId !== 'root') {
                             updateAssistantSpeech(`Error: Parent ID '${actualParentId}' (from AI's '${action.parentId}') for '${action.name}' not found. Skipping.`, true, false, true);
                             continue;
                        }

                        let newEntry;
                        if (action.action === "create_folder") {
                            newEntry = createVFSEntry({ type: 'folder', name: action.name, parentId: actualParentId });
                        } else if (action.action === "create_file") {
                            newEntry = createVFSEntry({
                                type: 'file',
                                name: action.name,
                                parentId: actualParentId,
                                content: action.content || "",
                                mimeType: action.mimeType || "text/plain"
                            });
                        }
                        if (newEntry) {
                            tempIdToVfsIdMap[action.id] = newEntry.id;
                            successCount++;
                        }
                    }
                    renderDesktopVFSIcons();
                    if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === explicitBaseParentId || getVFSChildren(explicitBaseParentId).length > 0)) {
                        renderVFSFileList(currentFEVfsPathId);
                    }
                    const parentFolder = getVFSEntry(explicitBaseParentId);
                    const parentFolderName = parentFolder ? parentFolder.name : (explicitBaseParentId === 'root' ? "Files (Root)" : SPARKY_CREATIONS_FOLDER_NAME);
                    updateAssistantSpeech(`File system created in "${parentFolderName}"! ${successCount} items processed.`, true, false, true);
                } else {
                    updateAssistantSpeech("Invalid plan format from AI. Expected a JSON array.", true, false, true);
                }
            } catch (e) {
                console.error("Error processing Sparky file system plan:", e, "Raw AI:", aiPlanResponseText);
                updateAssistantSpeech("Error processing file system plan: " + e.message.substring(0,100), true, false, true);
            }
        }
        else if (lowerCommand.startsWith("sparky, write html")) {
            try {
                const filenameMatch = command.match(/Filename:\s*([\w.-]+)\s*Content:/i);
                const contentMatch = command.match(/Content:\s*([\s\S]+)$/i);

                if (filenameMatch && contentMatch) {
                    const filename = filenameMatch[1].trim();
                    const htmlContent = contentMatch[1].trim();
                    updateAssistantSpeech(`Creating HTML file "${filename}"...`, false, true, true);

                    const sparkyFolderId = ensureSparkyCreationsFolder();
                    const newFile = createVFSEntry({ type: 'file', name: filename, mimeType: 'text/html', content: htmlContent, parentId: sparkyFolderId });
                    if(fe_fileListElement && (currentFEVfsPathId === 'root' || currentFEVfsPathId === sparkyFolderId)) {
                         renderVFSFileList(currentFEVfsPathId);
                    }
                    updateAssistantSpeech(`Done! Saved "${filename}" to your "${SPARKY_CREATIONS_FOLDER_NAME}" folder.`, false, false, true);
                } else {
                    updateAssistantSpeech("Usage: Sparky, write html. Filename: page.html. Content: <h1>Hello</h1>", false, false, true);
                }
            } catch(e) {
                 console.error("Error in Sparky 'write html' command:", e);
                 updateAssistantSpeech("Error making HTML file: " + e.message.substring(0,100), false, false, true);
            }
        }
        else {
            updateAssistantSpeech("Let me try to make that into HTML...", false, true, true);
            const htmlPrompt = DEFAULT_SPARKY_HTML_GENERATOR_PROMPT.replace("{USER_REQUEST}", command);
            let generatedHtml = "";
            try {
                generatedHtml = await callCurrentAiProviderForText(htmlPrompt, 4000, 0.7, sparkyStatusUpdater);
                if (generatedHtml.startsWith("```html")) generatedHtml = generatedHtml.substring(7).trim();
                else if (generatedHtml.startsWith("```")) generatedHtml = generatedHtml.substring(3).trim();
                if (generatedHtml.endsWith("```")) generatedHtml = generatedHtml.substring(0, generatedHtml.length - 3).trim();

                await createSparkyHtmlPopupWindow(generatedHtml, command);
                updateAssistantSpeech(`Here's what I came up with! (And saved to your "${SPARKY_CREATIONS_FOLDER_NAME}" folder)`, true, false, true);

            } catch (error) {
                console.error("Sparky generic HTML generation error:", error);
                await createSparkyHtmlPopupWindow(`<p style="color:red;">Sorry, I had trouble generating HTML for that: ${error.message}</p>`, command);
                updateAssistantSpeech("Oops, couldn't make HTML for that.", true, false, true);
            }
        }
        assistantIsProcessingCommand = false;
    }

    async function executeGameGenerationFromPlan(userGameIdea, gamePlan, svgAssetsArray, soundJsArray, statusUpdater = null) {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (!keyAvailable) {
            if(statusUpdater) statusUpdater("API Key/Model ID/Endpoint URL missing for game gen.");
            else updateAssistantSpeech("API Key/Model ID/Endpoint URL missing for game gen.", false, false, true);
            return null;
        }

        const finalGamePromptInstruction = getAppInstruction('gameGen_final', DEFAULT_GAMEGEN_FINAL_INSTRUCTION);
        const finalGamePrompt = finalGamePromptInstruction
            .replace("{USER_GAME_IDEA}", userGameIdea)
            .replace("{GAME_PLAN_JSON}", JSON.stringify(gamePlan))
            .replace("{SVG_ASSETS_ARRAY_OF_STRINGS}", JSON.stringify(svgAssetsArray))
            .replace("{SOUND_EFFECTS_JS_ARRAY_OF_STRINGS}", JSON.stringify(soundJsArray));

        let gameHtml;
        try {
             if (selectedApiProvider === 'gemini') {
                if (!gameGen_main_model) { initGameGeneratorApp(); if (!gameGen_main_model) throw new Error("Gemini game model not ready.");}
                const gameCodeResult = await gameGen_main_model.generateContent(finalGamePrompt);
                gameHtml = gameCodeResult.response.text().trim();
             } else if (['groq', 'openrouter', 'deepseek', 'huggingface', 'transformersjs', 'custom'].includes(selectedApiProvider)) {
                 if(statusUpdater) statusUpdater(`Generating final game code with ${selectedApiProvider}...`);
                 gameHtml = await callCurrentAiProviderForText(finalGamePrompt, 8192, 0.7, statusUpdater);
             }
            if (gameHtml && gameHtml.startsWith("```html")) gameHtml = gameHtml.substring(7).trim(); else if (gameHtml && gameHtml.startsWith("```")) gameHtml = gameHtml.substring(3).trim(); if (gameHtml && gameHtml.endsWith("```")) gameHtml = gameHtml.substring(0, gameHtml.length - 3).trim();
            return gameHtml;
        } catch (e) {
            console.error(`Game Generation (from plan) Error (${selectedApiProvider}):`, e);
            const errorMsg = `Game code generation failed: ${e.message.substring(0,100)}`;
            if(statusUpdater) statusUpdater(errorMsg);
            else updateAssistantSpeech(errorMsg, false, false, true);
            return null;
        }
    }

    function enableAppButtons() {
        let keyAvailable = false;
        switch (selectedApiProvider) {
            case 'gemini': keyAvailable = !!window.GLOBAL_GEMINI_API_KEY; break;
            case 'groq': keyAvailable = !!window.GLOBAL_GROQ_API_KEY; break;
            case 'openrouter': keyAvailable = !!window.GLOBAL_OPENROUTER_API_KEY; break;
            case 'deepseek': keyAvailable = !!window.GLOBAL_DEEPSEEK_API_KEY; break;
            case 'huggingface': keyAvailable = !!window.GLOBAL_HF_TOKEN; break;
            case 'transformersjs': keyAvailable = !!window.GLOBAL_TRANSFORMERSJS_MODEL_ID; break;
            case 'custom': keyAvailable = !!window.GLOBAL_CUSTOM_API_KEY && !!getCurrentCustomEndpointUrl(); break;
        }
        if (svg_generateButton) svg_generateButton.disabled = !keyAvailable;
        if (gameGen_generateButton) gameGen_generateButton.disabled = !keyAvailable;
        if (musicStudio_generateButton) musicStudio_generateButton.disabled = !keyAvailable;
        if (gifCreator_generateButton) gifCreator_generateButton.disabled = !keyAvailable;
        if (textEditor_sparkyAssistButton) textEditor_sparkyAssistButton.disabled = !keyAvailable;
    }

    function disableAppButtons() {
        if (svg_generateButton) svg_generateButton.disabled = true;
        if (gameGen_generateButton) gameGen_generateButton.disabled = true;
        if (musicStudio_generateButton) musicStudio_generateButton.disabled = true;
        if (gifCreator_generateButton) gifCreator_generateButton.disabled = true;
        if (textEditor_sparkyAssistButton) textEditor_sparkyAssistButton.disabled = true;
    }

    async function callGroqApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_GROQ_API_KEY) { throw new Error("Groq API Key not set."); }
        const GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions";
        const modelToUse = getCurrentGroqModel(); const maxTokensToUse = maxTokensOverride !== null ? maxTokensOverride : getCurrentGroqMaxTokens();
        try {
            const response = await fetch(GROQ_API_URL, { method: 'POST', headers: { 'Authorization': `Bearer ${window.GLOBAL_GROQ_API_KEY}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ messages: messages, model: modelToUse, temperature: temperature, max_tokens: maxTokensToUse, }) });
            if (!response.ok) { const errorData = await response.json().catch(() => ({})); console.error("Groq API Error Response:", errorData); throw new Error(`Groq API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`); }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) { return data.choices[0].message.content; }
            else { console.warn("Groq API response missing expected content:", data); throw new Error("Groq API response format unexpected."); }
        } catch (error) { console.error("Error calling Groq API:", error); throw error; }
    }

    async function callOpenRouterApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_OPENROUTER_API_KEY) { throw new Error("OpenRouter API Key not set."); }
        const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";
        const modelToUse = getCurrentOpenRouterModel();
        const httpReferer = getCurrentOpenRouterHttpReferer();
        const headers = {
            'Authorization': `Bearer ${window.GLOBAL_OPENROUTER_API_KEY}`,
            'Content-Type': 'application/json'
        };
        if (httpReferer) {
            headers['HTTP-Referer'] = httpReferer;
        }
        try {
            const body = {
                model: modelToUse,
                messages: messages,
                temperature: temperature,
            };
            if (maxTokensOverride !== null) {
                body.max_tokens = maxTokensOverride;
            }
            const response = await fetch(OPENROUTER_API_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(body)
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("OpenRouter API Error Response:", errorData);
                throw new Error(`OpenRouter API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`);
            }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            } else {
                console.warn("OpenRouter API response missing expected content:", data);
                throw new Error("OpenRouter API response format unexpected.");
            }
        } catch (error) {
            console.error("Error calling OpenRouter API:", error);
            throw error;
        }
    }


    async function callDeepSeekApi(messages, temperature = 0.5, maxTokensOverride = null) {
        if (!window.GLOBAL_DEEPSEEK_API_KEY) { throw new Error("DeepSeek API Key not set."); }
        const DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions";
        const modelToUse = getCurrentDeepSeekModel();
        const maxTokensToUse = maxTokensOverride !== null ? maxTokensOverride : getCurrentDeepSeekMaxTokens();

        try {
            const response = await fetch(DEEPSEEK_API_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${window.GLOBAL_DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    messages: messages,
                    model: modelToUse,
                    temperature: temperature,
                    max_tokens: maxTokensToUse,
                })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("DeepSeek API Error Response:", errorData);
                throw new Error(`DeepSeek API request failed: ${response.status} ${response.statusText}. Model: ${modelToUse}. ${errorData?.error?.message || ''}`);
            }
            const data = await response.json();
            if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                return data.choices[0].message.content;
            } else {
                console.warn("DeepSeek API response missing expected content:", data);
                throw new Error("DeepSeek API response format unexpected.");
            }
        } catch (error) {
            console.error("Error calling DeepSeek API:", error);
            throw error;
        }
    }

    async function callHuggingFaceApi(modelId, payload = {}) {
        if (!window.GLOBAL_HF_TOKEN) { throw new Error("Hugging Face API Token not set."); }
        let effectiveModelId = modelId.trim();
        if (effectiveModelId.endsWith('.')) {
            effectiveModelId = effectiveModelId.substring(0, effectiveModelId.length - 1);
        }
        const HF_API_URL = `https://api-inference.huggingface.co/models/${effectiveModelId}`;
        let requestBody;
        if (typeof payload === 'string') { requestBody = { inputs: payload, parameters: { max_new_tokens: DEFAULT_HF_MAX_NEW_TOKENS, return_full_text: false, temperature: 0.7 }, options: { wait_for_model: true }}; }
        else { requestBody = { inputs: payload.inputs, parameters: { max_new_tokens: DEFAULT_HF_MAX_NEW_TOKENS, return_full_text: false, temperature: 0.7, ...payload.parameters }, options: { wait_for_model: true, ...payload.options }}; }
        try {
            const response = await fetch(HF_API_URL, { method: 'POST', headers: { 'Authorization': `Bearer ${window.GLOBAL_HF_TOKEN}`, 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) { const errorText = await response.text(); console.error("Hugging Face API Error Response Text:", errorText); let errorMessage = `HF API request failed: ${response.status} ${response.statusText}. Model: ${effectiveModelId}.`; try { const errorData = JSON.parse(errorText); errorMessage += ` ${errorData?.error || ''}`; } catch (e) { errorMessage += ` ${errorText}`; } throw new Error(errorMessage); }
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0 && data[0].generated_text) { return data[0].generated_text; }
            else if (typeof data === 'string') { return data; } else if (data.generated_text) { return data.generated_text; }
            else { console.warn("Hugging Face API response format unexpected:", data); return typeof data === 'string' ? data : JSON.stringify(data); }
        } catch (error) { console.error("Error calling Hugging Face API:", error); throw error; }
    }

    // --- Window Management ---
    function openWindow(appId, options = {}, isPopup = false) {
        const windowEl = document.getElementById(appId);
        if (windowEl) {
            windowEl.style.display = 'flex';
            windowEl.classList.remove('minimized'); 

            if(window.innerWidth <= 768 && !windowEl.classList.contains('fullscreen') && !isPopup && appId !== 'setupGuideModal') { // Don't fullscreen the setup guide modal on mobile by default
                windowEl.classList.add('mobile-default-fullscreen');
            } else if (appId !== 'setupGuideModal') { // Don't remove if it is the setup guide
                windowEl.classList.remove('mobile-default-fullscreen');
            }


            const titleTextEl = windowEl.querySelector('.title-bar-text');
            if (options.title && titleTextEl) { titleTextEl.textContent = options.title; }
            else if (options.fileId && appId === 'textEditorWindow' && titleTextEl) { /* handled by openTextEditorWindow */ }
            else if (options.vfsPathId && appId === 'fileExplorerWindow' && titleTextEl) {
                const folder = getVFSEntry(options.vfsPathId);
                titleTextEl.textContent = `📁 ${folder ? folder.name : (options.vfsPathId === 'root' ? 'Files' : 'File Explorer')}`;
            }

            bringToFront(windowEl);
            if (appId === 'fileExplorerWindow' && options.vfsPathId) { initFileExplorerAppForVFS(options); }
            else if (appId === 'textEditorWindow') { openTextEditorWindow(options); }

            if (!isPopup && !windowEl.dataset.isPopup && appId !== 'setupGuideModal') { 
                 createTaskbarButton(windowEl);
                 updateTaskbarButtonState(windowEl.id, 'active');
            }
            return windowEl;
        }
        return null;
    }

    function closeWindow(windowEl) {
        if (windowEl) {
            const windowId = windowEl.id;
            if (windowId.startsWith('webBrowserWindow-') && browserInstances[windowId]) {
                browserInstances[windowId].iframe.srcdoc = ''; browserInstances[windowId].iframe.src = 'about:blank';
                delete browserInstances[windowId]; windowEl.remove();
            } else if (windowId.startsWith('sparkyAdPopup-') || windowId.startsWith('sparkyHtmlPopup-')) {
                windowEl.remove();
            } else if (windowId === 'setupGuideModal') { // Specific handling for setup guide modal
                windowEl.style.display = 'none';
            }
            else {
                 windowEl.style.display = 'none';
                 windowEl.classList.remove('active', 'fullscreen', 'minimized', 'mobile-default-fullscreen');
                 if (windowId === 'gamePlayerWindow' && gamePlayerWindow_iframe) { gamePlayerWindow_iframe.srcdoc = ''; gamePlayerWindow_iframe.src = 'about:blank'; }
                 if (windowId === 'textEditorWindow') { currentTextEditorFileId = null; if(textEditor_contentArea) textEditor_contentArea.value = ""; if(textEditor_currentFileName) textEditor_currentFileName.textContent = ""; }
            }
            if (windowId !== 'setupGuideModal') {
                removeTaskbarButton(windowId);
            }
            if (activeWindow === windowEl) activeWindow = null;
        }
    }

    function handleMinimizeWindow(windowEl) {
        if (windowEl && !windowEl.classList.contains('minimized')) {
            windowEl.style.display = 'none';
            windowEl.classList.add('minimized');
            windowEl.classList.remove('active');
            updateTaskbarButtonState(windowEl.id, 'minimized');
            if (activeWindow === windowEl) {
                activeWindow = null;
                let maxZ = -1;
                document.querySelectorAll('.window:not(.minimized)').forEach(win => {
                    if (win.id === 'setupGuideModal' && win.style.display === 'flex') return; // Skip setup modal if it's visible but not active focus
                    const z = parseInt(win.style.zIndex || '0');
                    if (z > maxZ && win.style.display !== 'none') {
                        maxZ = z; activeWindow = win;
                    }
                });
                if(activeWindow) activeWindow.classList.add('active');
            }
            updateAllTaskbarButtonStates();
        }
    }

    function bringToFront(windowEl) {
        if (!windowEl || windowEl.classList.contains('minimized')) return;
        if (activeWindow && activeWindow !== windowEl) { activeWindow.classList.remove('active'); updateTaskbarButtonState(activeWindow.id, 'normal'); }
        highestZIndex++; windowEl.style.zIndex = highestZIndex;
        windowEl.classList.add('active');
        windowEl.style.display = 'flex';
        activeWindow = windowEl;
        if (windowEl.id !== 'setupGuideModal') { // Don't create taskbar button for setup guide modal
            updateTaskbarButtonState(windowEl.id, 'active');
        }
        document.querySelectorAll('.taskbar-button').forEach(btn => {
            if (btn.dataset.windowId !== windowEl.id) {
                const linkedWin = document.getElementById(btn.dataset.windowId);
                if(linkedWin && !linkedWin.classList.contains('minimized')) {
                    btn.classList.remove('active');
                }
            }
        });
    }

    initializeDesktopIconBehaviors();

    if(desktopElement) { desktopElement.addEventListener('click', (e) => { if (!e.target.closest('.start-button') && !e.target.closest('.start-menu') && !e.target.closest('.context-menu') && !e.target.closest('#setupGuideModal')) { if(startMenu) startMenu.style.display = 'none'; if(desktopContextMenu) desktopContextMenu.style.display = 'none'; if(setupGuideModal && !e.target.closest('#customSetupLink')) closeSetupGuideModal(); } if (!e.target.closest('.desktop-icon')) { document.querySelectorAll('.desktop-icon.selected').forEach(i => i.classList.remove('selected')); contextMenuTargetVFSId = null; } }); }

    function initializeWindowBehavior(windowEl) {
        const titleBar = windowEl.querySelector('.title-bar');
        const closeButton = windowEl.querySelector('.close-button');
        const fullscreenButton = windowEl.querySelector('.fullscreen-button');
        const minimizeButton = windowEl.querySelector('.minimize-button');

        // Do not attach bringToFront if it's the setup guide modal, it's handled by openSetupGuideModal
        if (windowEl.id !== 'setupGuideModal') {
            windowEl.addEventListener('mousedown', () => bringToFront(windowEl), true);
        }

        if (titleBar && windowEl.id !== 'setupGuideModal') { // No dragging for setup guide modal
            titleBar.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('close-button') || e.target.classList.contains('fullscreen-button') || e.target.classList.contains('minimize-button') ||
                    e.target.closest('.title-bar-controls button') || e.target.tagName === 'BUTTON' ||
                    windowEl.classList.contains('fullscreen') || windowEl.classList.contains('mobile-default-fullscreen') || windowEl.classList.contains('minimized')) {
                    return;
                }
                bringToFront(windowEl);
                const startX = e.clientX; const startY = e.clientY; const initialLeft = windowEl.offsetLeft; const initialTop = windowEl.offsetTop;
                function onMouseMove(moveEvent) {
                    let newX = initialLeft + (moveEvent.clientX - startX); let newY = initialTop + (moveEvent.clientY - startY);
                    const desktopRect = desktopElement.getBoundingClientRect(); const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;
                    newX = Math.max(0, Math.min(newX, desktopRect.width - windowEl.offsetWidth));
                    newY = Math.max(0, Math.min(newY, desktopRect.height - windowEl.offsetHeight - taskbarHeight + 20));
                    windowEl.style.left = newX + 'px'; windowEl.style.top = newY + 'px';
                }
                function onMouseUp() { document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }
                document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp);
            });
        }
        // Close button for setupGuideModal is handled separately
        if (closeButton && windowEl.id !== 'setupGuideModal') { closeButton.addEventListener('click', () => closeWindow(windowEl)); }
        if (fullscreenButton) { fullscreenButton.addEventListener('click', () => { windowEl.classList.remove('mobile-default-fullscreen','minimized'); windowEl.classList.toggle('fullscreen'); windowEl.style.display = 'flex'; bringToFront(windowEl); });}
        if (minimizeButton) { minimizeButton.addEventListener('click', () => handleMinimizeWindow(windowEl)); }
    }

    document.querySelectorAll('.window').forEach(windowEl => initializeWindowBehavior(windowEl));

    function updateClock() { if (taskbarClock) taskbarClock.textContent = new Date().toLocaleTimeString(); }
    setInterval(updateClock, 1000); updateClock();

    // --- Taskbar Management ---
    function createTaskbarButton(windowEl) {
        if (!windowEl || !taskbarButtonsContainer || windowEl.dataset.isPopup === "true" || windowEl.id === 'setupGuideModal') return;
        const windowId = windowEl.id;
        const existingBtn = taskbarButtonsContainer.querySelector(`.taskbar-button[data-window-id="${windowId}"]`);
        if (existingBtn) existingBtn.remove();

        const button = document.createElement('button');
        button.className = 'taskbar-button';
        button.dataset.windowId = windowId;

        const titleTextEl = windowEl.querySelector('.title-bar-text');
        button.textContent = titleTextEl ? titleTextEl.textContent.substring(0,20) + (titleTextEl.textContent.length > 20 ? '...' : '') : windowId;
        button.title = titleTextEl ? titleTextEl.textContent : windowId;

        button.addEventListener('click', () => handleTaskbarButtonClick(windowId));
        taskbarButtonsContainer.appendChild(button);
    }

    function removeTaskbarButton(windowId) {
        if (!taskbarButtonsContainer || windowId === 'setupGuideModal') return;
        const button = taskbarButtonsContainer.querySelector(`.taskbar-button[data-window-id="${windowId}"]`);
        if (button) button.remove();
    }

    function updateTaskbarButtonState(windowId, state) { 
        if (!taskbarButtonsContainer || windowId === 'setupGuideModal') return;
        const button = taskbarButtonsContainer.querySelector(`.taskbar-button[data-window-id="${windowId}"]`);
        if (button) {
            button.classList.remove('active', 'minimized'); 
            if (state === 'active') button.classList.add('active');
            else if (state === 'minimized') button.classList.add('minimized');
        }
    }
    function updateAllTaskbarButtonStates() {
        document.querySelectorAll('.taskbar-button').forEach(btn => {
            const winId = btn.dataset.windowId;
            if (winId === 'setupGuideModal') return;
            const win = document.getElementById(winId);
            if (win) {
                if (win.classList.contains('minimized')) {
                    updateTaskbarButtonState(winId, 'minimized');
                } else if (win === activeWindow) {
                    updateTaskbarButtonState(winId, 'active');
                } else {
                    updateTaskbarButtonState(winId, 'normal');
                }
            }
        });
    }


    function handleTaskbarButtonClick(windowId) {
        const windowEl = document.getElementById(windowId);
        if (windowEl) {
            if (windowEl.classList.contains('minimized')) {
                windowEl.style.display = 'flex';
                windowEl.classList.remove('minimized');
                bringToFront(windowEl);
            } else if (windowEl === activeWindow) {
                handleMinimizeWindow(windowEl);
            } else { 
                bringToFront(windowEl);
            }
        }
    }

    // --- Context Menu ---
    function handleDesktopContextMenu(event, specificItemId = null) {
        event.preventDefault();
        event.stopPropagation();
        if (!desktopContextMenu || !desktopElement) return;

        hideContextMenu();

        const target = event.target;
        let menuItems = [];
        let parentIdForNewItems = 'root';

        const clickedIcon = target.closest('.desktop-icon');
        const clickedFileExplorerItem = target.closest('#fe_fileList li');
        const isFilesDesktopIcon = clickedIcon && clickedIcon.dataset.appId === 'fileExplorerWindow' && clickedIcon.dataset.vfsPathId === 'root';


        if (isFilesDesktopIcon) {
             contextMenuTargetVFSId = 'root';
             menuItems.push({ label: "Open Files", action: () => { handleDesktopIconDblClick(clickedIcon); hideContextMenu(); } });
             menuItems.push({ type: 'separator' });
             menuItems.push({ label: "Download All Files as ZIP", action: () => { downloadVFSEntryAsZip('root'); hideContextMenu(); } });
        } else if (specificItemId || (clickedIcon && clickedIcon.dataset.itemId) || (clickedFileExplorerItem && clickedFileExplorerItem.dataset.itemId)) {
            contextMenuTargetVFSId = specificItemId || (clickedIcon ? clickedIcon.dataset.itemId : clickedFileExplorerItem.dataset.itemId);
            const itemEntry = getVFSEntry(contextMenuTargetVFSId);
            if (itemEntry) {
                menuItems.push({ label: "Open", action: () => {
                    const elementToDblClick = clickedIcon || document.querySelector(`.desktop-icon[data-item-id="${contextMenuTargetVFSId}"]`) || clickedFileExplorerItem;
                    if (elementToDblClick) handleDesktopIconDblClick(elementToDblClick);
                    hideContextMenu();
                }});
                menuItems.push({ label: "Rename", action: () => { renameVFSEntry(contextMenuTargetVFSId); hideContextMenu(); } });
                if (itemEntry.type === 'file') {
                    menuItems.push({ label: "Download File", action: () => { downloadVFSEntry(contextMenuTargetVFSId); hideContextMenu(); } });
                } else if (itemEntry.type === 'folder') {
                    menuItems.push({ label: "Download Folder as ZIP", action: () => { downloadVFSEntryAsZip(contextMenuTargetVFSId); hideContextMenu(); } });
                }
                menuItems.push({ type: 'separator' });
                menuItems.push({ label: "Delete", action: () => { deleteVFSEntryWithConfirmation(contextMenuTargetVFSId); hideContextMenu(); } });
            }
        } else if (target.closest('#fe_fileListContainer')) {
             contextMenuTargetVFSId = null;
             parentIdForNewItems = currentFEVfsPathId;
             menuItems.push({ label: "New Folder", action: () => { createNewVFSEntry('folder', parentIdForNewItems); hideContextMenu(); } });
             menuItems.push({ label: "New Text File", action: () => { createNewVFSEntry('file', parentIdForNewItems); hideContextMenu(); } });
        } else if (target === desktopElement || target.classList.contains('desktop')) {
            contextMenuTargetVFSId = null;
            menuItems.push({ label: "New Folder", action: () => { createNewVFSEntry('folder', 'root'); hideContextMenu(); } });
            menuItems.push({ label: "New Text File", action: () => { createNewVFSEntry('file', 'root'); hideContextMenu(); } });
        } else {
            return;
        }

        if (menuItems.length > 0) {
            populateContextMenu(menuItems);
            const menuWidth = desktopContextMenu.offsetWidth;
            const menuHeight = desktopContextMenu.offsetHeight;
            const desktopRect = desktopElement.getBoundingClientRect();
            let x = event.clientX;
            let y = event.clientY;
            if (x + menuWidth > desktopRect.right) x = desktopRect.right - menuWidth - 5;
            if (y + menuHeight > desktopRect.bottom - (document.querySelector('.taskbar')?.offsetHeight || 0)) y = desktopRect.bottom - menuHeight - 5 - (document.querySelector('.taskbar')?.offsetHeight || 0);
            desktopContextMenu.style.left = `${x}px`;
            desktopContextMenu.style.top = `${y}px`;
            desktopContextMenu.style.display = 'block';
        }
    }

    function hideContextMenu() {
        if (desktopContextMenu) desktopContextMenu.style.display = 'none';
        contextMenuTargetVFSId = null;
    }

    function populateContextMenu(items) {
        if (!desktopContextMenu) return;
        desktopContextMenu.innerHTML = '';
        items.forEach(item => {
            if (item.type === 'separator') {
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                desktopContextMenu.appendChild(separator);
            } else {
                const menuItemEl = document.createElement('div');
                menuItemEl.className = 'context-menu-item';
                menuItemEl.textContent = item.label;
                menuItemEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    item.action();
                });
                desktopContextMenu.appendChild(menuItemEl);
            }
        });
    }

    function createNewVFSEntry(type, parentId = 'root') {
        const defaultName = type === 'folder' ? "New Folder" : "New Text File.txt";
        const name = prompt(`Enter name for new ${type}:`, defaultName);
        if (name) {
            const entryData = { type: type, name: name, parentId: parentId };
            if (type === 'file') {
                entryData.content = "";
                entryData.mimeType = name.endsWith('.html') || name.endsWith('.htm') ? 'text/html' : 'text/plain';
            }
            const newEntry = createVFSEntry(entryData);
            if (parentId === 'root' && !(newEntry.name === SPARKY_CREATIONS_FOLDER_NAME)) renderDesktopVFSIcons();
            if (fe_fileListElement && parentId === currentFEVfsPathId) renderVFSFileList(parentId);
            logK8osActivity("Context Menu", `Created new ${type}: ${name} in ${parentId === 'root' ? 'Files (Root)' : getVFSEntry(parentId)?.name || 'Unknown'}`);
        }
    }

    function renameVFSEntry(itemId) {
        const item = getVFSEntry(itemId);
        if (item) {
            const newName = prompt(`Enter new name for "${item.name}":`, item.name);
            if (newName && newName !== item.name) {
                updateVFSEntry(itemId, { name: newName });
                if (item.parentId === 'root' && !(item.name === SPARKY_CREATIONS_FOLDER_NAME && newName === SPARKY_CREATIONS_FOLDER_NAME) ) renderDesktopVFSIcons();
                if (fe_fileListElement && (item.parentId === currentFEVfsPathId || itemId === currentFEVfsPathId)) renderVFSFileList(currentFEVfsPathId);
                logK8osActivity("Context Menu", `Renamed "${item.name}" to "${newName}"`);
            }
        }
    }

    function deleteVFSEntryWithConfirmation(itemId) {
        const item = getVFSEntry(itemId);
        if (item) {
            if (confirm(`Are you sure you want to delete "${item.name}"?${item.type === 'folder' ? ' This will also delete all its contents.' : ''}`)) {
                deleteVFSEntry(itemId);
                logK8osActivity("Context Menu", `Deleted ${item.type}: ${item.name}`);
            }
        }
    }

    function downloadVFSEntry(itemId) {
        const item = getVFSEntry(itemId);
        if (item && item.type === 'file') {
            downloadFile(item.content || "", item.name, item.mimeType || "application/octet-stream");
            logK8osActivity("Context Menu", `Downloaded file: ${item.name}`);
        } else if (item && item.type === 'folder') {
            downloadVFSEntryAsZip(itemId);
        }
    }
    document.addEventListener('click', (e) => {
        if (desktopContextMenu && desktopContextMenu.style.display === 'block' && !e.target.closest('.context-menu')) {
            hideContextMenu();
        }
         if (startMenu && startMenu.style.display === 'flex' && !e.target.closest('.start-button') && !e.target.closest('.start-menu')) {
            startMenu.style.display = 'none';
        }
        // Hide setup guide modal if clicking outside of it, and not on the trigger links
        if (setupGuideModal && setupGuideModal.style.display === 'flex' && !e.target.closest('#setupGuideModal') && !e.target.closest('#customSetupLink')) {
            closeSetupGuideModal();
        }
    });


    let svg_currentSvgContent = null;
    const svgStatusUpdater = (msg) => { if(svg_errorDisplay) svg_errorDisplay.textContent = `Status: ${msg}`; if(svg_loadingIndicator && msg.toLowerCase().includes("loading")) svg_loadingIndicator.style.display = 'block'; else if(svg_loadingIndicator) svg_loadingIndicator.style.display = 'none';};
    function initSvgGeneratorApp() {
        svg_genAI_internal_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());


        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    svg_genAI_internal_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.2, maxOutputTokens: 80000 } });
                    if (svg_generateButton) svg_generateButton.disabled = false; svgStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("SVG Gen Gemini AI Init Error:", error); svgStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if (svg_generateButton) svg_generateButton.disabled = true; }
            } else { if (svg_generateButton) svg_generateButton.disabled = false; svgStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { svgStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if (svg_generateButton) svg_generateButton.disabled = true; }
    }

    async function internal_generateSingleSvg(svgDescription, isAnimated = false, statusUpdaterFn = null) {
        const baseInstruction = isAnimated ? getAppInstruction('gifCreatorNew', DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION) : getAppInstruction('svg', DEFAULT_SVG_INSTRUCTION);
        const fullPrompt = baseInstruction.replace("{USER_PROMPT}", svgDescription);
        try {
            let svgText;
            if (selectedApiProvider === 'gemini') {
                let modelToUse = isAnimated ? gifCreator_genAI_model : svg_genAI_internal_model;
                if (!modelToUse) {
                    if(isAnimated) { initGifCreatorApp(); modelToUse = gifCreator_genAI_model; }
                    else { initSvgGeneratorApp(); modelToUse = svg_genAI_internal_model;}
                    if (!modelToUse) throw new Error(`Gemini model not initialized for ${isAnimated ? 'GIF' : 'SVG'} generation.`);
                }
                const result = await modelToUse.generateContent(fullPrompt); svgText = result.response.text();
            } else if (['groq', 'openrouter', 'deepseek', 'huggingface', 'transformersjs', 'custom'].includes(selectedApiProvider)) {
                 svgText = await callCurrentAiProviderForText(fullPrompt, 80000, isAnimated ? 0.4 : 0.2, statusUpdaterFn);
            } else {
                 throw new Error(`Provider ${selectedApiProvider} not supported for internal SVG generation.`);
            }

            const svgMatch = svgText ? svgText.match(/<svg[\s\S]*?<\/svg>/im) : null;
            if (svgMatch && svgMatch[0]) { const potentialSvg = svgMatch[0]; if (potentialSvg.includes('<svg') && potentialSvg.includes('</svg>')) { return potentialSvg; } }
            console.warn("Invalid or no SVG from internal call for:", svgDescription, "Provider:", selectedApiProvider, "Raw:", svgText ? svgText.substring(0,200) : "null"); return null;
        } catch (error) { console.error(`Error in internal_generateSingle(Animated)Svg with ${selectedApiProvider}:`, error); return null; }
    }

    async function svg_handleGenerateSvg() {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (!keyAvailable) { svgStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); return; }
        if (selectedApiProvider === 'gemini' && !svg_genAI_internal_model) { svgStatusUpdater("Gemini SVG AI model not initialized."); return; }

        const userPrompt = svg_promptInput.value.trim();
        if (!userPrompt) { svgStatusUpdater('Enter description.'); return; }

        if (svg_generateButton) svg_generateButton.disabled = true; if (svg_downloadButton) svg_downloadButton.style.display = 'none';
        if (svg_svgContainer) svg_svgContainer.innerHTML = '';
        svgStatusUpdater("Generating...");
        svg_currentSvgContent = null;
        try {
            svg_currentSvgContent = await internal_generateSingleSvg(userPrompt, false, svgStatusUpdater);
            if (svg_currentSvgContent) {
                if (svg_svgContainer) {
                    svg_svgContainer.innerHTML = svg_currentSvgContent;
                    const svgElement = svg_svgContainer.querySelector('svg');
                    if (svgElement) { if (!svgElement.getAttribute('xmlns')) svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg'); if (svgElement.getAttribute('viewBox')) { svgElement.style.width = '100%'; svgElement.style.height = 'auto'; svgElement.removeAttribute('width'); svgElement.removeAttribute('height'); } }
                }
                if (svg_downloadButton) svg_downloadButton.style.display = 'block';
                svgStatusUpdater("SVG Generated.");
            } else { svgStatusUpdater(`Failed to generate valid SVG using ${selectedApiProvider}. Check console for details.`); if(svg_svgContainer) svg_svgContainer.innerHTML = `<p style="color:red;">No valid SVG generated.</p>`; }
        } catch (error) { console.error("SVG Generation Error:", error); svgStatusUpdater(`Error generating SVG: ${error.message}`); if(svg_svgContainer) svg_svgContainer.innerHTML = `<p style="color:red;">Generation failed.</p>`; }
        finally { enableAppButtons(); if (svg_loadingIndicator) svg_loadingIndicator.style.display = 'none'; }
    }
    function svg_handleDownloadSvg() { if (svg_currentSvgContent) { const fileName = svg_promptInput.value.trim().toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '_') || "vector_image"; downloadFile(svg_currentSvgContent, `${fileName}.svg`, "image/svg+xml;charset=utf-8"); } else { alert("No SVG to download."); } }

   
    const gifCreatorStatusUpdater = (msg) => { if(gifCreator_errorDisplay) gifCreator_errorDisplay.textContent = `Status: ${msg}`; if(gifCreator_loadingIndicator && msg.toLowerCase().includes("loading")) gifCreator_loadingIndicator.style.display = 'block'; else if(gifCreator_loadingIndicator) gifCreator_loadingIndicator.style.display = 'none';};
    function initGifCreatorApp() {
        gifCreator_genAI_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    gifCreator_genAI_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.4, maxOutputTokens: 80000 } });
                    if(gifCreator_generateButton) gifCreator_generateButton.disabled = false; gifCreatorStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("GIF Creator Gemini AI Init Error:", error); gifCreatorStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if(gifCreator_generateButton) gifCreator_generateButton.disabled = true; }
            } else { if(gifCreator_generateButton) gifCreator_generateButton.disabled = false; gifCreatorStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { gifCreatorStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if(gifCreator_generateButton) gifCreator_generateButton.disabled = true; }
    }

    const gameGenStatusUpdater = (msg) => { if(gameGen_apiErrorDisplay) gameGen_apiErrorDisplay.textContent = `Status: ${msg}`; };
    function initGameGeneratorApp() {
        gameGen_main_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    gameGen_main_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.7, topK: 40, topP: 0.95, maxOutputTokens: 120000 } });
                    if (gameGen_generateButton) gameGen_generateButton.disabled = false; gameGenStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("Game Gen Gemini AI Init Error:", error); gameGenStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if (gameGen_generateButton) gameGen_generateButton.disabled = true; }
            } else { if (gameGen_generateButton) gameGen_generateButton.disabled = false; gameGenStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { gameGenStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if (gameGen_generateButton) gameGen_generateButton.disabled = true; }
    }
    function gameGen_showLoading(message) { if (!gameGen_loadingMessage || !gameGen_generateButton) return; gameGen_loadingMessage.textContent = message; gameGen_loadingMessage.style.display = 'block'; gameGen_generateButton.disabled = true; if(gameGen_downloadZipButton) gameGen_downloadZipButton.style.display = 'none'; gameGen_lastGameAssetPackage = null; if(gameGen_debugSection) gameGen_debugSection.style.display = 'none';}
    function gameGen_hideLoading() { if(gameGen_loadingMessage) gameGen_loadingMessage.style.display = 'none'; enableAppButtons(); }
    function gameGen_displayError(message, isRuntimeError = false) { if (!gameGen_errorMessage) return; gameGen_errorMessage.textContent = "Game Gen Error: " + message + (isRuntimeError ? " Check Browser Console (F12)." : ""); gameGen_errorMessage.style.display = 'block'; gameGenStatusUpdater(`Error: ${message.substring(0,100)}`);}
    function gameGen_clearError() { if (!gameGen_errorMessage) return; gameGen_errorMessage.textContent = ''; gameGen_errorMessage.style.display = 'none'; }

    async function internal_generateSingleSoundJs(soundDescription, statusUpdaterFn = null) {
        const baseInstruction = getAppInstruction('musicStudio', DEFAULT_MUSICSTUDIO_INSTRUCTION);
        const fullPrompt = baseInstruction.replace("{USER_PROMPT}", soundDescription);
        try {
            let jsCode;
            if (selectedApiProvider === 'gemini') {
                let modelToUse = musicStudio_genAI_model;
                if (!modelToUse) {
                    initMusicStudioApp();
                    modelToUse = musicStudio_genAI_model;
                    if (!modelToUse && gameGen_main_model) modelToUse = gameGen_main_model;
                    if (!modelToUse) throw new Error("Gemini model not initialized for sound JS.");
                }
                const result = await modelToUse.generateContent(fullPrompt); jsCode = result.response.text().trim();
            } else if (['groq', 'openrouter', 'deepseek', 'huggingface', 'transformersjs', 'custom'].includes(selectedApiProvider)) {
                 jsCode = await callCurrentAiProviderForText(fullPrompt, 8000, 0.6, statusUpdaterFn);
                 if (selectedApiProvider === 'huggingface' || selectedApiProvider === 'transformersjs' || selectedApiProvider === 'custom') {
                     jsCode = `/* WARNING: JS code generated by ${selectedApiProvider}, may not be valid Web Audio API code. */\n` + jsCode;
                 }
            } else {
                throw new Error(`Provider ${selectedApiProvider} not supported for internal sound JS generation.`);
            }
            if (jsCode && jsCode.startsWith("```javascript")) jsCode = jsCode.substring(13).trim(); else if (jsCode && jsCode.startsWith("```")) jsCode = jsCode.substring(3).trim();
            if (jsCode && jsCode.endsWith("```")) jsCode = jsCode.substring(0, jsCode.length - 3).trim(); return jsCode;
        } catch (error) { console.error(`Error in internal_generateSingleSoundJs with ${selectedApiProvider} for "${soundDescription}":`, error); return `console.warn("Failed to generate sound JS for ${soundDescription.replace(/"/g, '\\"')} in game: ${error.message || String(error)}");`; }
    }

    const musicStudioStatusUpdater = (msg) => { if(musicStudio_errorDisplay) musicStudio_errorDisplay.textContent = `Status: ${msg}`; if(musicStudio_loadingIndicator && msg.toLowerCase().includes("loading")) musicStudio_loadingIndicator.style.display = 'block'; else if(musicStudio_loadingIndicator) musicStudio_loadingIndicator.style.display = 'none';};
    function initMusicStudioApp() {
        musicStudio_genAI_model = null; // Gemini specific
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (keyAvailable) {
            if (selectedApiProvider === 'gemini') {
                try {
                    const genAI = new GoogleGenerativeAI(window.GLOBAL_GEMINI_API_KEY);
                    musicStudio_genAI_model = genAI.getGenerativeModel({ model: getCurrentGeminiModel(), safetySettings: [{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },], generationConfig: { temperature: 0.6, maxOutputTokens: 80000 } });
                    if(musicStudio_generateButton) musicStudio_generateButton.disabled = false; musicStudioStatusUpdater("Idle (Gemini)");
                } catch (error) { console.error("Music Studio Gemini AI Init Error:", error); musicStudioStatusUpdater(`Gemini AI Init Error: ${error.message}.`); if(musicStudio_generateButton) musicStudio_generateButton.disabled = true; }
            } else { if(musicStudio_generateButton) musicStudio_generateButton.disabled = false; musicStudioStatusUpdater(`Idle (${selectedApiProvider})`); }
        } else { musicStudioStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); if(musicStudio_generateButton) musicStudio_generateButton.disabled = true; }
        if (!musicStudio_promptInput || !musicStudio_generateButton || !musicStudio_generatedCode || !musicStudio_playButton || !musicStudio_stopButton) { console.error("Music Studio UI elements missing!"); musicStudioStatusUpdater("UI Error."); }
    }

    function applyCustomImageBackground(url, size, repeat, updateStatus = true) {
        if (url) {
            document.body.style.backgroundImage = `url("${CSS.escape(url)}")`; document.body.style.backgroundSize = size;
            document.body.style.backgroundRepeat = repeat; document.body.style.backgroundColor = 'transparent';
            localStorage.setItem('k8os_desktopBgImageUrl', url); localStorage.setItem('k8os_desktopBgImageSize', size); localStorage.setItem('k8os_desktopBgImageRepeat', repeat);
            if (systemSettings_status && updateStatus) systemSettings_status.textContent = `Image background applied.`;
        } else { clearCustomImageBackground(false, updateStatus); if (systemSettings_status && updateStatus) systemSettings_status.textContent = `Image URL is empty. Image cleared.`; }
    }

    function clearCustomImageBackground(restoreColor = true, updateStatus = true) {
        document.body.style.backgroundImage = 'none'; document.body.style.backgroundSize = 'auto'; document.body.style.backgroundRepeat = 'repeat';
        localStorage.removeItem('k8os_desktopBgImageUrl'); localStorage.removeItem('k8os_desktopBgImageSize'); localStorage.removeItem('k8os_desktopBgImageRepeat');
        if (restoreColor) { const savedBgColor = localStorage.getItem('k8os_desktopBgColor') || DEFAULT_BG_COLOR; document.body.style.backgroundColor = savedBgColor; }
        if (systemSettings_status && updateStatus) systemSettings_status.textContent = `Image background cleared.`;
        if (systemSettings_appearance_bgImageUrlInput) systemSettings_appearance_bgImageUrlInput.value = '';
    }

    function applyIconScale(scaleFactor) { document.documentElement.style.setProperty('--desktop-icon-scale-factor', scaleFactor); if (systemSettings_iconSizeSliderValue) systemSettings_iconSizeSliderValue.textContent = `${Number(scaleFactor).toFixed(1)}x`; }

    function initSystemSettingsApp() {
        if (systemSettings_about_version) systemSettings_about_version.textContent = `Version: ${K8OS_VERSION}`;
        if (systemSettings_transformersJsVersion) systemSettings_transformersJsVersion.textContent = TRANSFORMERS_JS_VERSION;

        const savedBgColor = localStorage.getItem('k8os_desktopBgColor') || DEFAULT_BG_COLOR;
        if (systemSettings_appearance_bgColorPicker) systemSettings_appearance_bgColorPicker.value = savedBgColor;
        if (systemSettings_appearance_colorOptions) {
            systemSettings_appearance_colorOptions.innerHTML = '';
            PRESET_BG_COLORS.forEach(color => { const button = document.createElement('button'); button.style.backgroundColor = color; button.title = color; button.addEventListener('click', () => { setDesktopBackground(color); if (systemSettings_appearance_bgColorPicker) systemSettings_appearance_bgColorPicker.value = color; }); systemSettings_appearance_colorOptions.appendChild(button); });
        }
        if (systemSettings_appearance_bgColorPicker) { systemSettings_appearance_bgColorPicker.addEventListener('input', (e) => { setDesktopBackground(e.target.value); });}
        if (systemSettings_appearance_resetButton) { systemSettings_appearance_resetButton.addEventListener('click', () => { setDesktopBackground(DEFAULT_BG_COLOR); if (systemSettings_appearance_bgColorPicker) systemSettings_appearance_bgColorPicker.value = DEFAULT_BG_COLOR; if (systemSettings_status) systemSettings_status.textContent = "Background color reset."; }); }
        const savedBgImageUrl = localStorage.getItem('k8os_desktopBgImageUrl'); const savedBgImageSize = localStorage.getItem('k8os_desktopBgImageSize') || 'cover'; const savedBgImageRepeat = localStorage.getItem('k8os_desktopBgImageRepeat') || 'no-repeat';
        if (systemSettings_appearance_bgImageUrlInput) systemSettings_appearance_bgImageUrlInput.value = savedBgImageUrl || '';
        if (systemSettings_appearance_bgSizeSelect) systemSettings_appearance_bgSizeSelect.value = savedBgImageSize;
        if (systemSettings_appearance_bgRepeatSelect) systemSettings_appearance_bgRepeatSelect.value = savedBgImageRepeat;
        if (systemSettings_appearance_applyBgImageButton) { systemSettings_appearance_applyBgImageButton.addEventListener('click', () => { const imageUrl = systemSettings_appearance_bgImageUrlInput.value.trim(); const bgSize = systemSettings_appearance_bgSizeSelect.value; const bgRepeat = systemSettings_appearance_bgRepeatSelect.value; if (imageUrl) { applyCustomImageBackground(imageUrl, bgSize, bgRepeat); } else { if (systemSettings_status) systemSettings_status.textContent = "Please enter an image URL."; } }); }
        if (systemSettings_appearance_clearBgImageButton) { systemSettings_appearance_clearBgImageButton.addEventListener('click', () => { clearCustomImageBackground(true); }); }
        const savedIconScale = parseFloat(localStorage.getItem('k8os_desktopIconScaleFactor') || '1.0'); applyIconScale(savedIconScale);
        if(systemSettings_iconSizeSlider) systemSettings_iconSizeSlider.value = savedIconScale;
        if (systemSettings_iconSizeSlider) { systemSettings_iconSizeSlider.addEventListener('input', (e) => { const newScale = e.target.value; applyIconScale(newScale); localStorage.setItem('k8os_desktopIconScaleFactor', newScale); if(systemSettings_status) systemSettings_status.textContent = `Icon scale set to ${newScale}x.`; }); }
        if (systemSettings_iconSizeResetButton) { systemSettings_iconSizeResetButton.addEventListener('click', () => { applyIconScale(1.0); localStorage.setItem('k8os_desktopIconScaleFactor', '1.0'); if(systemSettings_iconSizeSlider) systemSettings_iconSizeSlider.value = 1.0; if(systemSettings_status) systemSettings_status.textContent = "Icon scale reset to 1.0x."; }); }

        if (systemSettings_ai_modelNameInput) systemSettings_ai_modelNameInput.value = getCurrentGeminiModel();
        if (systemSettings_ai_groqModelInput) systemSettings_ai_groqModelInput.value = getCurrentGroqModel();
        if (systemSettings_ai_groqMaxTokensInput) systemSettings_ai_groqMaxTokensInput.value = getCurrentGroqMaxTokens();
        if (systemSettings_ai_openrouterModelInput) systemSettings_ai_openrouterModelInput.value = getCurrentOpenRouterModel();
        if (systemSettings_ai_openrouterHttpRefererInput) systemSettings_ai_openrouterHttpRefererInput.value = getCurrentOpenRouterHttpReferer();
        if (systemSettings_ai_deepseekModelInput) systemSettings_ai_deepseekModelInput.value = getCurrentDeepSeekModel();
        if (systemSettings_ai_deepseekMaxTokensInput) systemSettings_ai_deepseekMaxTokensInput.value = getCurrentDeepSeekMaxTokens();
        if (systemSettings_ai_hfModelIdInput) systemSettings_ai_hfModelIdInput.value = getCurrentHfModelId();
        if (systemSettings_ai_transformersjsModelIdInput) systemSettings_ai_transformersjsModelIdInput.value = getCurrentTransformersJsModelId();
        if (systemSettings_ai_customEndpointUrlInput) systemSettings_ai_customEndpointUrlInput.value = getCurrentCustomEndpointUrl();
        if (systemSettings_ai_customModelIdInput) systemSettings_ai_customModelIdInput.value = getCurrentCustomModelId();


        if (systemSettings_ai_svgInstruction) systemSettings_ai_svgInstruction.value = getAppInstruction('svg', DEFAULT_SVG_INSTRUCTION);
        if (systemSettings_ai_gameGenFinalInstruction) systemSettings_ai_gameGenFinalInstruction.value = getAppInstruction('gameGen_final', DEFAULT_GAMEGEN_FINAL_INSTRUCTION);
        if (systemSettings_ai_musicStudioInstruction) systemSettings_ai_musicStudioInstruction.value = getAppInstruction('musicStudio', DEFAULT_MUSICSTUDIO_INSTRUCTION);
        if (systemSettings_ai_gifCreatorNewInstruction) systemSettings_ai_gifCreatorNewInstruction.value = getAppInstruction('gifCreatorNew', DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION);
        if (systemSettings_ai_gifCreatorAnimateInstruction) systemSettings_ai_gifCreatorAnimateInstruction.value = getAppInstruction('gifCreatorAnimate', DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION);

        updateApiKeyUI(); // This will show/hide the correct provider settings sections
        if (systemSettings_ai_saveModelButton) { systemSettings_ai_saveModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_modelNameInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalGeminiAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `Gemini Model set: ${newModel}. Re-init AI apps...`; initAllAiApps(); } else { if (systemSettings_status) systemSettings_status.textContent = "Gemini Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveGroqModelButton) { systemSettings_ai_saveGroqModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_groqModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalGroqAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `Groq Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Groq Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveGroqMaxTokensButton) { systemSettings_ai_saveGroqMaxTokensButton.addEventListener('click', () => { const newMaxTokens = parseInt(systemSettings_ai_groqMaxTokensInput.value, 10); if (!isNaN(newMaxTokens) && newMaxTokens > 0) { localStorage.setItem('k8os_globalGroqMaxTokens', newMaxTokens.toString()); if (systemSettings_status) systemSettings_status.textContent = `Groq Max Tokens set: ${newMaxTokens}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Invalid Groq Max Tokens value."; } }); }
        if (systemSettings_ai_saveOpenrouterModelButton) { systemSettings_ai_saveOpenrouterModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_openrouterModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalOpenRouterAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `OpenRouter Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "OpenRouter Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveOpenrouterHttpRefererButton) { systemSettings_ai_saveOpenrouterHttpRefererButton.addEventListener('click', () => { const newReferer = systemSettings_ai_openrouterHttpRefererInput.value.trim(); localStorage.setItem('k8os_globalOpenRouterHttpReferer', newReferer); if (systemSettings_status) systemSettings_status.textContent = `OpenRouter Site URL saved.`; }); }
        if (systemSettings_ai_saveDeepseekModelButton) { systemSettings_ai_saveDeepseekModelButton.addEventListener('click', () => { const newModel = systemSettings_ai_deepseekModelInput.value.trim(); if (newModel) { localStorage.setItem('k8os_globalDeepSeekAiModel', newModel); if (systemSettings_status) systemSettings_status.textContent = `DeepSeek Model set: ${newModel}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "DeepSeek Model name cannot be empty."; } }); }
        if (systemSettings_ai_saveDeepseekMaxTokensButton) { systemSettings_ai_saveDeepseekMaxTokensButton.addEventListener('click', () => { const newMaxTokens = parseInt(systemSettings_ai_deepseekMaxTokensInput.value, 10); if (!isNaN(newMaxTokens) && newMaxTokens > 0) { localStorage.setItem('k8os_globalDeepSeekMaxTokens', newMaxTokens.toString()); if (systemSettings_status) systemSettings_status.textContent = `DeepSeek Max Tokens set: ${newMaxTokens}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Invalid DeepSeek Max Tokens value."; } }); }
        if (systemSettings_ai_saveHfModelButton) { systemSettings_ai_saveHfModelButton.addEventListener('click', () => { let newModelId = systemSettings_ai_hfModelIdInput.value.trim(); if (newModelId.endsWith('.')) { newModelId = newModelId.substring(0, newModelId.length - 1); console.warn("Trimmed trailing period from HF Model ID before saving. New ID:", newModelId); systemSettings_ai_hfModelIdInput.value = newModelId; } if (newModelId) { localStorage.setItem('k8os_globalHfModelId', newModelId); if (systemSettings_status) systemSettings_status.textContent = `Hugging Face Model ID set: ${newModelId}.`; } else { if (systemSettings_status) systemSettings_status.textContent = "Hugging Face Model ID cannot be empty."; } }); }
        if (systemSettings_ai_saveTransformersjsModelButton) { systemSettings_ai_saveTransformersjsModelButton.addEventListener('click', async () => {
            const newModelId = systemSettings_ai_transformersjsModelIdInput.value.trim();
            if (newModelId) {
                localStorage.setItem('k8os_globalTransformersJsModelId', newModelId);
                window.GLOBAL_TRANSFORMERSJS_MODEL_ID = newModelId;
                if (systemSettings_status) systemSettings_status.textContent = `Transformers.js Model ID set: ${newModelId}.`;
                enableAppButtons();
                if (systemSettings_transformersjs_status) systemSettings_transformersjs_status.textContent = `Preparing model ${newModelId}...`;
                try {
                    await ensureTransformersJsPipeline(newModelId, (progress) => {
                        if (systemSettings_transformersjs_status) {
                            systemSettings_transformersjs_status.textContent = `Loading ${newModelId}: ${Math.round(progress.progress)}% (${progress.file})`;
                        }
                    });
                    if (systemSettings_transformersjs_status) systemSettings_transformersjs_status.textContent = `Model ${newModelId} is ready.`;
                } catch (e) {
                    if (systemSettings_transformersjs_status) systemSettings_transformersjs_status.textContent = `Error preparing ${newModelId}: ${e.message.substring(0,100)}`;
                    console.error("Error preparing Transformers.js model from settings:", e);
                }
            } else {
                if (systemSettings_status) systemSettings_status.textContent = "Transformers.js Model ID cannot be empty.";
            }
        }); }
        if (systemSettings_ai_saveCustomSettingsButton) { systemSettings_ai_saveCustomSettingsButton.addEventListener('click', () => {
            const url = systemSettings_ai_customEndpointUrlInput.value.trim(); const modelId = systemSettings_ai_customModelIdInput.value.trim();
            if (url) { localStorage.setItem('k8os_globalCustomEndpointUrl', url); } else { localStorage.removeItem('k8os_globalCustomEndpointUrl'); }
            if (modelId) { localStorage.setItem('k8os_globalCustomModelId', modelId); } else { localStorage.removeItem('k8os_globalCustomModelId'); }
            if (systemSettings_status) systemSettings_status.textContent = `Custom Endpoint settings saved. URL: ${url || 'Not set'}. Model: ${modelId || 'Not set'}.`;
            enableAppButtons(); initAllAiApps();
        });}


        if(systemSettings_ai_saveSvgInstructionButton) systemSettings_ai_saveSvgInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_svg', systemSettings_ai_svgInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "SVG instruction saved."; initSvgGeneratorApp(); });
        if(systemSettings_ai_saveGameGenFinalInstructionButton) systemSettings_ai_saveGameGenFinalInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_gameGen_final', systemSettings_ai_gameGenFinalInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "Game Gen (Final) instruction saved."; });
        if(systemSettings_ai_saveMusicStudioInstructionButton) systemSettings_ai_saveMusicStudioInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_musicStudio', systemSettings_ai_musicStudioInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "Music Studio instruction saved."; initMusicStudioApp(); });
        if(systemSettings_ai_saveGifCreatorNewInstructionButton) systemSettings_ai_saveGifCreatorNewInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_gifCreatorNew', systemSettings_ai_gifCreatorNewInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "GIF Creator (New) instruction saved."; initGifCreatorApp(); });
        if(systemSettings_ai_saveGifCreatorAnimateInstructionButton) systemSettings_ai_saveGifCreatorAnimateInstructionButton.addEventListener('click', () => { localStorage.setItem('k8os_instr_gifCreatorAnimate', systemSettings_ai_gifCreatorAnimateInstruction.value); if(systemSettings_status) systemSettings_status.textContent = "GIF Creator (Animate) instruction saved."; initGifCreatorApp();});
        const tabs = document.querySelectorAll('#systemSettingsWindow .settings-tab'); const tabContents = document.querySelectorAll('#systemSettingsWindow .settings-tab-content');
        tabs.forEach(tab => { tab.addEventListener('click', () => { tabs.forEach(t => t.classList.remove('active')); tab.classList.add('active'); const targetContentId = "settingsContent_" + tab.dataset.tab; tabContents.forEach(content => { content.classList.toggle('active', content.id === targetContentId); }); }); });
    }
    function setDesktopBackground(color) {
        clearCustomImageBackground(false, false); document.body.style.backgroundColor = color;
        localStorage.setItem('k8os_desktopBgColor', color);
        if (systemSettings_status) systemSettings_status.textContent = `Background color set to ${color}.`;
    }
    function downloadFile(content, filename, contentType) { const blob = new Blob([content], { type: contentType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }

    if (svg_generateButton) svg_generateButton.addEventListener('click', svg_handleGenerateSvg);
    if (svg_downloadButton) svg_downloadButton.addEventListener('click', svg_handleDownloadSvg);
    if(gifCreator_importSvgButton) gifCreator_importSvgButton.addEventListener('click', () => { if (svg_currentSvgContent && gifCreator_svgInput) { gifCreator_svgInput.value = svg_currentSvgContent; gifCreatorStatusUpdater("SVG imported from SVG Creator."); } else { gifCreatorStatusUpdater("No SVG content in SVG Creator to import."); } });
    if(gifCreator_generateButton) gifCreator_generateButton.addEventListener('click', async () => {
        const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                             (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                             (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                             (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                             (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                             (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                             (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
        if (!keyAvailable) { gifCreatorStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); return; }
        if (selectedApiProvider === 'gemini' && !gifCreator_genAI_model) { gifCreatorStatusUpdater("GIF Creator Gemini AI model not initialized."); return; }
        const newGifPrompt = gifCreator_promptInput.value.trim(); const existingSvgCode = gifCreator_svgInput.value.trim(); const animationPromptForExisting = gifCreator_animationPromptInput.value.trim();
        if (!newGifPrompt && !existingSvgCode) { gifCreatorStatusUpdater("Please provide a description for a new animation or import/paste SVG and provide animation instructions."); return; }
        if (existingSvgCode && !animationPromptForExisting) { gifCreatorStatusUpdater("Please provide animation instructions for the existing SVG."); return; }

        gifCreatorStatusUpdater("Generating...");
        if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = "<p>Generating animated SVG...</p>"; gifCreator_currentAnimatedSvg = null; if(gifCreator_downloadButton) gifCreator_downloadButton.style.display = 'none';
        let fullPrompt; let baseInstruction;
        if (existingSvgCode) { baseInstruction = getAppInstruction('gifCreatorAnimate', DEFAULT_GIFCREATOR_ANIMATE_EXISTING_SVG_INSTRUCTION); fullPrompt = baseInstruction.replace("{STATIC_SVG_CODE}", existingSvgCode).replace("{ANIMATION_PROMPT}", animationPromptForExisting); }
        else { baseInstruction = getAppInstruction('gifCreatorNew', DEFAULT_GIFCREATOR_ANIMATED_SVG_INSTRUCTION); fullPrompt = baseInstruction.replace("{USER_PROMPT}", newGifPrompt); }
        try {
            let animatedSvgText = await callCurrentAiProviderForText(fullPrompt, 80000, 0.4, gifCreatorStatusUpdater);
            if (animatedSvgText && animatedSvgText.startsWith("```svg")) animatedSvgText = animatedSvgText.substring(6).trim(); else if (animatedSvgText && animatedSvgText.startsWith("```")) animatedSvgText = animatedSvgText.substring(3).trim();
            if (animatedSvgText && animatedSvgText.endsWith("```")) animatedSvgText = animatedSvgText.substring(0, animatedSvgText.length - 3).trim();
            const svgMatch = animatedSvgText ? animatedSvgText.match(/<svg[\s\S]*?<\/svg>/im) : null;
            if (svgMatch && svgMatch[0]) { gifCreator_currentAnimatedSvg = svgMatch[0]; if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = gifCreator_currentAnimatedSvg; if(gifCreator_downloadButton) gifCreator_downloadButton.style.display = 'block'; gifCreatorStatusUpdater("Animated SVG Generated.");}
            else { 
    gifCreatorStatusUpdater(`AI (${selectedApiProvider}) did not return valid SVG code for animation. Check console.`); 
    if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = "<p style='color:red'>Failed to generate animated SVG.</p>"; 
    console.warn("Raw output from API for GIF:", animatedSvgText); 
}
} catch (e) { 
    console.error(`GIF Creator AI Error (${selectedApiProvider}):`, e); 
    gifCreatorStatusUpdater(`AI Error: ${e.message || String(e)}`); 
    if(gifCreator_previewContainer) gifCreator_previewContainer.innerHTML = "<p style='color:red'>Error during generation.</p>"; 
}
finally { 
    enableAppButtons(); 
}
});

if(gifCreator_downloadButton) gifCreator_downloadButton.addEventListener('click', () => { 
    if (gifCreator_currentAnimatedSvg) { 
        let fileName = (gifCreator_promptInput.value.trim() || gifCreator_animationPromptInput.value.trim() || "animated_image").toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '_'); 
        downloadFile(gifCreator_currentAnimatedSvg, `${fileName}.svg`, "image/svg+xml;charset=utf-8"); 
    } else { 
        alert("No animated SVG to download."); 
    } 
});

function prepareGameHTMLWithLogger(htmlContent) { const errorLoggerScript = `<script> window.onerror = function(message, source, lineno, colno, error) { console.error("GameRuntimeError:", { message, source: source.substring(source.lastIndexOf('/') + 1), lineno, colno, error: error ? error.stack : 'N/A' }); return false; }; window.onunhandledrejection = function(event) { console.error("GameRuntimePromiseRejection:", { reason: event.reason ? (event.reason.message || event.reason) : 'Unknown reason', stack: event.reason ? event.reason.stack : 'N/A'}); }; <\/script>`; if (htmlContent.includes("</head>")) { return htmlContent.replace("</head>", errorLoggerScript + "</head>"); } else if (htmlContent.includes("<body>")) { return htmlContent.replace("<body>", errorLoggerScript + "<body>"); } return errorLoggerScript + htmlContent; }

    // REPLACE the old executeGameGeneration function with this one:
async function executeGameGeneration(userGameIdea, isDebugAttempt = false, existingCode = "", errorsAndHints = "") {
    const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                         (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                         (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                         (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                         (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                         (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                         (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
    if (!keyAvailable) { gameGen_displayError("API Key/Model ID/Endpoint URL not set for selected provider!"); return; }
    if (selectedApiProvider === 'gemini' && !gameGen_main_model) { gameGen_displayError("Gemini AI Model not ready!"); return; }
    gameGen_clearError(); const providerName = selectedApiProvider;

    const localGameGenStatusUpdater = (msg) => {
        if(gameGen_assetStatus) gameGen_assetStatus.textContent = msg;
        gameGenStatusUpdater(msg);
        if(msg.toLowerCase().includes("loading") || msg.toLowerCase().includes("generating")) gameGen_showLoading(msg); else gameGen_hideLoading();
    };

    if (isDebugAttempt) {
        localGameGenStatusUpdater(`Attempting to debug game code with ${providerName}...`);
        const debugInstruction = getAppInstruction('gameGen_debug', DEFAULT_GAMEGEN_DEBUG_INSTRUCTION).replace("{USER_GAME_IDEA}", gameGen_lastUserIdea || "the previously described game").replace("{ERRORS_AND_HINTS}", errorsAndHints).replace("{PROBLEM_CODE}", existingCode);
        try {
            let fixedHtml = await callCurrentAiProviderForText(debugInstruction, 8192, 0.5, localGameGenStatusUpdater);
            if (fixedHtml && fixedHtml.startsWith("```html")) fixedHtml = fixedHtml.substring(7).trim(); else if (fixedHtml && fixedHtml.startsWith("```")) fixedHtml = fixedHtml.substring(3).trim(); if (fixedHtml && fixedHtml.endsWith("```")) fixedHtml = fixedHtml.substring(0, fixedHtml.length - 3).trim();
            
            const fixedPackage = { html: fixedHtml, assets: gameGen_lastGameAssetPackage?.assets || [] };
             if (fixedPackage.html) {
                await processAndSaveGamePackage(fixedPackage, gameGen_lastUserIdea);
            } else {
                gameGen_displayError(`AI (${providerName}) did not return a valid HTML fix.`, true);
            }
        } catch (e) { console.error(`Game Debugging Error (${providerName}):`, e); let message = `Failed to debug game with ${providerName}. ${e.message || 'Unknown error.'}`; gameGen_displayError(message); }
        finally { gameGen_hideLoading(); }
    } else {
        localGameGenStatusUpdater(`Generating game plan with ${providerName}...`); if(gameGen_planDisplay) gameGen_planDisplay.textContent = "Generating game plan..."; if(gameGen_assetStatus) gameGen_assetStatus.textContent = "";
        let gamePlan; let planResponseText = "";
        try {
            const planPrompt = DEFAULT_GAMEGEN_PLAN_INSTRUCTION.replace("{USER_GAME_IDEA}", userGameIdea);
            planResponseText = await callCurrentAiProviderForText(planPrompt, 2048, 0.3, localGameGenStatusUpdater);
            let cleanedJsonString = planResponseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
            const jsonStart = cleanedJsonString.indexOf('{'); const jsonEnd = cleanedJsonString.lastIndexOf('}');
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) { cleanedJsonString = cleanedJsonString.substring(jsonStart, jsonEnd + 1); }
            gamePlan = JSON.parse(cleanedJsonString);
            if (!gamePlan.game_mechanic || !Array.isArray(gamePlan.svg_assets) || !Array.isArray(gamePlan.sound_effects) ) {
                gamePlan.svg_assets = gamePlan.svg_assets || []; gamePlan.sound_effects = gamePlan.sound_effects || [];
            }
            let planDisplayText = `Game Mechanic: ${gamePlan.game_mechanic || 'N/A'}\nSVGs:\n`;
            (gamePlan.svg_assets || []).forEach(asset => planDisplayText += ` - ${asset.description || '??'} (Animated: ${!!asset.animated})\n`);
            planDisplayText += `Sounds: ${(gamePlan.sound_effects || []).join(', ')}`;
            if(gameGen_planDisplay) gameGen_planDisplay.textContent = planDisplayText;
        } catch (e) { console.error("Error parsing game plan JSON:", e, "Raw response:", planResponseText); gameGen_displayError(`Failed to generate/parse game plan from ${providerName}. Check console. AI Response: ${(planResponseText || '').substring(0,200)}...`); gameGen_hideLoading(); return; }

        const generatedAssets = []; const assetFilenames = { svg: [], js: [] };
        localGameGenStatusUpdater(`Generating SVG assets with ${providerName}...`);
        for (let i = 0; i < gamePlan.svg_assets.length; i++) {
            const assetInfo = gamePlan.svg_assets[i]; if (!assetInfo || !assetInfo.description) continue;
            localGameGenStatusUpdater(`Generating SVG ${i+1}/${gamePlan.svg_assets.length}: ${assetInfo.description}...`);
            const svgCode = await internal_generateSingleSvg(assetInfo.description, !!assetInfo.animated, localGameGenStatusUpdater);
            const filename = `${assetInfo.description.substring(0,15).replace(/[^a-z0-9]/gi, '_') || `asset_${i}`}.svg`;
            assetFilenames.svg.push(filename);
            if (svgCode) { generatedAssets.push({ filename: filename, content: svgCode, type: 'svg' }); }
            else { generatedAssets.push({ filename: filename, content: `<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="10" height="10" fill="red"/><text x="1" y="8" font-size="5" fill="white">X</text></svg>`, type: 'svg' }); localGameGenStatusUpdater(`SVG ${i+1} [Failed for: ${assetInfo.description}]`); console.warn(`Failed to generate SVG for: ${assetInfo.description}.`); }
        }

        localGameGenStatusUpdater(`Generating sound effect JS with ${providerName}...`);
        if (gamePlan.sound_effects && gamePlan.sound_effects.length > 0) {
            for (let i = 0; i < gamePlan.sound_effects.length; i++) {
                const soundDesc = gamePlan.sound_effects[i]; if (!soundDesc) continue;
                localGameGenStatusUpdater(`Generating Sound JS ${i+1}/${gamePlan.sound_effects.length}: ${soundDesc}...`);
                const soundJsCode = await internal_generateSingleSoundJs(soundDesc, localGameGenStatusUpdater);
                const filename = `${soundDesc.substring(0,15).replace(/[^a-z0-9]/gi, '_') || `sound_${i}`}.js`;
                assetFilenames.js.push(filename);
                if (soundJsCode) { generatedAssets.push({ filename: filename, content: soundJsCode, type: 'js' }); }
                else { generatedAssets.push({ filename: filename, content: `console.warn("Failed to generate sound JS for '${soundDesc.replace(/"/g, '\\"').replace(/'/g, "\\'")}' in game.");`, type: 'js' }); localGameGenStatusUpdater(`Sound JS ${i+1} [Failed for: ${soundDesc}]`); console.warn(`Failed to generate Sound JS for: ${soundDesc}.`); }
            }
        } else { localGameGenStatusUpdater(`No sound effects requested in game plan.`); }

        localGameGenStatusUpdater(`All assets processed. Generating final game code with ${providerName}...`);
        const finalGamePrompt = getAppInstruction('gameGen_final', DEFAULT_GAMEGEN_FINAL_INSTRUCTION)
            .replace("{USER_GAME_IDEA}", userGameIdea)
            .replace("{GAME_PLAN_JSON}", JSON.stringify(gamePlan))
            .replace("{ASSET_FILENAMES_JSON}", JSON.stringify(assetFilenames));
        let gameHtml;
        try {
            if (selectedApiProvider === 'gemini') {
                if (!gameGen_main_model) { initGameGeneratorApp(); if (!gameGen_main_model) throw new Error("Gemini game model not ready.");}
                const gameCodeResult = await gameGen_main_model.generateContent(finalGamePrompt);
                gameHtml = gameCodeResult.response.text().trim();
            } else {
                gameHtml = await callCurrentAiProviderForText(finalGamePrompt, 8192, 0.7, localGameGenStatusUpdater);
            }
            
            if (gameHtml && gameHtml.startsWith("```html")) gameHtml = gameHtml.substring(7).trim(); else if (gameHtml && gameHtml.startsWith("```")) gameHtml = gameHtml.substring(3).trim(); if (gameHtml && gameHtml.endsWith("```")) gameHtml = gameHtml.substring(0, gameHtml.length - 3).trim();
            
            const gamePackage = { html: gameHtml, assets: generatedAssets };
            if (gamePackage.html) {
                await processAndSaveGamePackage(gamePackage, userGameIdea);
            } else {
                gameGen_displayError(`AI (${providerName}) did not return valid HTML. This could be due to safety filters.`, true);
            }
        } catch (e) {
            console.error(`Game Generator Final Code Error (${providerName}):`, e);
            let message = `Final code generation process failed with ${providerName}. ${e.message || 'Unknown error.'}`;
            gameGen_displayError(message);
        } finally {
            gameGen_hideLoading();
        }
    }
}

async function processAndSaveGamePackage(gamePackage, userGameIdea) {
    if (!gamePackage || !gamePackage.html || !gamePackage.html.toLowerCase().includes("<html")) {
        gameGen_displayError(`AI (${selectedApiProvider}) did not return valid HTML.`, true);
        if(gameGen_debugSection) gameGen_debugSection.style.display = 'none';
        return;
    }

    if (gameGen_generatedCodeTextarea) gameGen_generatedCodeTextarea.value = gamePackage.html;

    const gameName = userGameIdea.substring(0, 25).replace(/[^a-z0-9]/gi, '_') || 'generated-game';
    const gameFolderName = `${gameName}-${Date.now().toString(36)}`;

    const sparkyCreationsId = ensureSparkyCreationsFolder();
    const gameFolder = createVFSEntry({ type: 'folder', name: gameFolderName, parentId: sparkyCreationsId });
    const assetsFolder = createVFSEntry({ type: 'folder', name: 'assets', parentId: gameFolder.id });

    for (const asset of gamePackage.assets) {
        let mimeType = 'text/plain';
        if (asset.type === 'svg') mimeType = 'image/svg+xml';
        else if (asset.type === 'js') mimeType = 'application/javascript';
        createVFSEntry({ type: 'file', name: asset.filename, content: asset.content, mimeType: mimeType, parentId: assetsFolder.id });
    }
    const mainHtmlFile = createVFSEntry({ type: 'file', name: 'index.html', content: gamePackage.html, mimeType: 'text/html', parentId: gameFolder.id });

    gameGen_lastHtmlCode = gamePackage.html;
    gameGen_lastGameAssetPackage = { gameFolderId: gameFolder.id, assets: gamePackage.assets };
    if(gameGen_downloadZipButton) gameGen_downloadZipButton.style.display = 'block';
    if(gameGen_debugSection) gameGen_debugSection.style.display = 'block';
    
    gameGenStatusUpdater(`Game "${gameFolderName}" created in Sparky's Creations!`);
    openNewBrowserWindow(null, mainHtmlFile.id); // Automatically open the game to play
    if (fe_fileListElement && (currentFEVfsPathId === sparkyCreationsId)) {
        renderVFSFileList(sparkyCreationsId);
    }
}

if (gameGen_generateButton) gameGen_generateButton.addEventListener('click', async () => { gameGen_lastUserIdea = gameGen_promptInput.value.trim(); if (!gameGen_lastUserIdea) { gameGen_displayError("Please describe the game."); return; } const gamePackage = await executeGameGeneration(gameGen_lastUserIdea); if (gamePackage) { await processAndSaveGamePackage(gamePackage, gameGen_lastUserIdea); } });
if (gameGen_debugAttemptButton) gameGen_debugAttemptButton.addEventListener('click', async () => { const currentCode = gameGen_generatedCodeTextarea.value; const errorsAndHints = gameGen_debugCombinedInput.value.trim(); if (!currentCode) { gameGen_displayError("No game code to debug."); return; } if (!errorsAndHints) { gameGen_displayError("Please provide error messages or hints for debugging."); return; } const fixedPackage = await executeGameGeneration(gameGen_lastUserIdea, true, currentCode, errorsAndHints); if (fixedPackage) { await processAndSaveGamePackage(fixedPackage, gameGen_lastUserIdea); } });
if(gameGen_downloadZipButton) { gameGen_downloadZipButton.addEventListener('click', () => { if (gameGen_lastGameAssetPackage && gameGen_lastGameAssetPackage.gameFolderId) { downloadVFSEntryAsZip(gameGen_lastGameAssetPackage.gameFolderId); } else { alert("No game package generated to download."); } }); }

if(musicStudio_generateButton) musicStudio_generateButton.addEventListener('click', async () => {
    const keyAvailable = (selectedApiProvider === 'gemini' && window.GLOBAL_GEMINI_API_KEY) ||
                         (selectedApiProvider === 'groq' && window.GLOBAL_GROQ_API_KEY) ||
                         (selectedApiProvider === 'openrouter' && window.GLOBAL_OPENROUTER_API_KEY) ||
                         (selectedApiProvider === 'deepseek' && window.GLOBAL_DEEPSEEK_API_KEY) ||
                         (selectedApiProvider === 'huggingface' && window.GLOBAL_HF_TOKEN) ||
                         (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) ||
                         (selectedApiProvider === 'custom' && window.GLOBAL_CUSTOM_API_KEY && getCurrentCustomEndpointUrl());
    if (!keyAvailable) { musicStudioStatusUpdater("API Key/Model ID/Endpoint URL not set for selected provider."); return; }
    if (selectedApiProvider === 'gemini' && !musicStudio_genAI_model) { musicStudioStatusUpdater("Music Studio Gemini AI model not initialized."); return; }
    const userPrompt = musicStudio_promptInput.value.trim(); if (!userPrompt) { musicStudioStatusUpdater("Please describe the music."); return; }

    musicStudioStatusUpdater("Generating...");
    musicStudio_generatedCode.value = ""; musicStudio_playButton.disabled = true; musicStudio_stopButton.disabled = true; musicStudio_downloadJsButton.style.display = 'none';
    const baseInstruction = getAppInstruction('musicStudio', DEFAULT_MUSICSTUDIO_INSTRUCTION);
    const fullPrompt = baseInstruction.replace("{USER_PROMPT}", userPrompt);

    try {
        let text = await callCurrentAiProviderForText(fullPrompt, 16000, 0.6, musicStudioStatusUpdater);
        if (text && typeof text === 'string') {
            if (text.startsWith("```javascript")) text = text.substring(13).trim();
            else if (text.startsWith("```")) text = text.substring(3).trim();
            if (text.endsWith("```")) text = text.substring(0, text.length - 3).trim();
        } else {
            text = "";
        }
        if (text && text.trim().length > 10) {
            musicStudio_lastJsCode = text;
            musicStudio_generatedCode.value = text;
            musicStudio_playButton.disabled = false;
            musicStudio_downloadJsButton.style.display = 'block';
            musicStudioStatusUpdater("Music Code Generated.");
        } else {
            musicStudio_lastJsCode = "";
            musicStudio_generatedCode.value = "";
            musicStudioStatusUpdater("AI returned empty or invalid code. Check console.");
            console.warn("Music Studio: AI returned insufficient code.", text);
        }
    } catch (e) {
        console.error(`Music Studio AI Error (${selectedApiProvider}):`, e);
        musicStudioStatusUpdater(`AI Error: ${e.message || String(e)}`);
        musicStudio_lastJsCode = "";
        musicStudio_generatedCode.value = "";
    }
    finally { enableAppButtons(); }
});

// REPLACE IT WITH THIS
function stopAllMusicStudioSounds() {
    if (musicStudio_currentAudioContext && musicStudio_currentAudioContext.state !== 'closed') {
        musicStudio_currentAudioContext.close().catch(e => console.error("Error closing previous AudioContext:", e));
    }
    musicStudio_currentAudioContext = null;
    musicStudio_activeSources.forEach(source => {
        try {
            if(source && typeof source.stop === 'function') source.stop();
            if(source && typeof source.disconnect === 'function') source.disconnect();
        } catch(e){ console.warn("Error stopping/disconnecting audio source:", e); }
    });
    musicStudio_activeSources = [];
    if(musicStudio_stopButton) musicStudio_stopButton.disabled = true;
    // Re-enable play button only if there is code to be played
    if(musicStudio_playButton && musicStudio_generatedCode.value.trim()) {
        musicStudio_playButton.disabled = false;
    }
}
// REPLACE IT WITH THIS
if(musicStudio_playButton) musicStudio_playButton.addEventListener('click', () => {
    const code = musicStudio_generatedCode.value;
    if (code) {
        stopAllMusicStudioSounds(); // Stop any previous sounds first
        try {
            // IMPORTANT: Create the AudioContext on user interaction (the click)
            musicStudio_currentAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            musicStudio_activeSources = [];
            
            const soundFunction = new Function('audioContext', 'activeSources', code);
            soundFunction(musicStudio_currentAudioContext, musicStudio_activeSources);
            
            logK8osActivity("Music Studio", `Played music: ${musicStudio_promptInput.value.trim().substring(0,50)}...`);
            musicStudioStatusUpdater("Playing...");
            musicStudio_stopButton.disabled = false; // Always enable stop when play is successful
            musicStudio_playButton.disabled = true;
        } catch (e) {
            console.error("Error playing music:", e);
            musicStudioStatusUpdater("Playback Error: " + (e.message || String(e)) );
            stopAllMusicStudioSounds(); // Clean up on error
        }
    }
});
if(musicStudio_stopButton) musicStudio_stopButton.addEventListener('click', stopAllMusicStudioSounds);
if(musicStudio_downloadJsButton) musicStudio_downloadJsButton.addEventListener('click', () => { if (musicStudio_lastJsCode) { let fileName = musicStudio_promptInput.value.trim().toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '_') || "music_script"; downloadFile(musicStudio_lastJsCode, `${fileName}.js`, "application/javascript"); } else { alert("No music code generated yet."); } });

if(gamePlayer_refreshButton) gamePlayer_refreshButton.addEventListener('click', () => { if (gameGen_lastHtmlCode && gamePlayerWindow_iframe) { const htmlWithLogger = prepareGameHTMLWithLogger(gameGen_lastHtmlCode); gamePlayerWindow_iframe.srcdoc = htmlWithLogger; logK8osActivity("Game Player", `Refreshed game: ${gameGen_lastUserIdea.substring(0,50)}...`); } else { alert("No game loaded to refresh."); } });

function createBrowserWindowHTML(instanceId, initialTitle = "🌐 Web Browser") { return ` <div class="title-bar"> <span class="title-bar-text" id="${instanceId}_titleBarText">${initialTitle}</span> <div class="title-bar-controls"><button class="minimize-button" title="Minimize">0</button><button class="fullscreen-button" title="Toggle Fullscreen">1</button><button class="close-button" title="Close">r</button></div> </div> <div id="${instanceId}_navControls" class="webBrowserWindow_navControls"> <button id="${instanceId}_backButton" title="Back" disabled>3</button> <button id="${instanceId}_forwardButton" title="Forward" disabled>4</button> <button id="${instanceId}_refreshButton" title="Refresh">Q</button> <input type="text" id="${instanceId}_addressBar" class="webBrowserWindow_addressBar" placeholder="Enter URL or VFS path (/file.html)"> <button id="${instanceId}_goButton" style="width:auto;padding-left:5px;padding-right:5px;">Go</button> </div> <div class="window-content"> <iframe id="${instanceId}_iframeContent" class="webBrowserWindow_iframeContent" sandbox="allow-scripts allow-forms allow-popups allow-same-origin"></iframe> </div> <div id="${instanceId}_status" class="status-bar">Status: Idle</div> `; }
function openNewBrowserWindow(initialUrl = null, vfsFileId = null) {
    browserWindowCounter++; const instanceId = `webBrowserWindow-${browserWindowCounter}`;
    const windowEl = document.createElement('div'); windowEl.id = instanceId; windowEl.className = 'window webBrowserWindow';
    const topOffset = 40 + (browserWindowCounter % 10) * 20; const leftOffset = 300 + (browserWindowCounter % 10) * 20;
    windowEl.style.width = '800px'; windowEl.style.height = '600px'; windowEl.style.top = `${topOffset}px`; windowEl.style.left = `${leftOffset}px`;
    windowEl.innerHTML = createBrowserWindowHTML(instanceId); desktopElement.appendChild(windowEl); initializeWindowBehavior(windowEl);
    const instance = { id: instanceId, windowElement: windowEl, iframe: document.getElementById(`${instanceId}_iframeContent`), addressBar: document.getElementById(`${instanceId}_addressBar`), backButton: document.getElementById(`${instanceId}_backButton`), forwardButton: document.getElementById(`${instanceId}_forwardButton`), refreshButton: document.getElementById(`${instanceId}_refreshButton`), goButton: document.getElementById(`${instanceId}_goButton`), status: document.getElementById(`${instanceId}_status`), titleBarTextElement: document.getElementById(`${instanceId}_titleBarText`), history: [], historyIndex: -1 };
    browserInstances[instanceId] = instance;
    instance.goButton.addEventListener('click', () => navigateToUrlInBrowserInstance(instanceId, instance.addressBar.value.trim()));
    instance.addressBar.addEventListener('keypress', (e) => { if (e.key === 'Enter') navigateToUrlInBrowserInstance(instanceId, instance.addressBar.value.trim()); });
    instance.backButton.addEventListener('click', () => webBrowserNavigateInstance(instanceId, -1));
    instance.forwardButton.addEventListener('click', () => webBrowserNavigateInstance(instanceId, 1));
    instance.refreshButton.addEventListener('click', () => { if (instance.historyIndex > -1 && instance.history[instance.historyIndex]) { loadUrlInBrowserInstance(instanceId, instance.history[instance.historyIndex], false); logK8osActivity(`Browser (${instanceId})`, `Refreshed: ${instance.history[instance.historyIndex].substring(0,50)}...`); } });

    let targetUrl = initialUrl;
    if (vfsFileId) {
        const fileEntry = getVFSEntry(vfsFileId);
        if (fileEntry && (fileEntry.mimeType === 'text/html' || fileEntry.name.endsWith('.html') || fileEntry.name.endsWith('.htm'))) {
            targetUrl = `vfs://${vfsFileId}/${fileEntry.name}`;
            if (instance.titleBarTextElement) instance.titleBarTextElement.textContent = `🌐 ${fileEntry.name}`;
        }
    }
    openWindow(instanceId);
    if (targetUrl) { navigateToUrlInBrowserInstance(instanceId, targetUrl); }
    updateWebBrowserNavButtonsInstance(instanceId); return windowEl;
}
async function loadUrlInBrowserInstance(instanceId, url, addToHistory = true) {
    const instance = browserInstances[instanceId];
    if (!instance || !instance.iframe || !instance.status || !instance.addressBar) { console.error(`Browser instance ${instanceId} not found or incomplete.`); return; }
    instance.status.textContent = `Loading: ${url}...`; instance.addressBar.value = url; instance.iframe.srcdoc = '';

    try {
        if (url.startsWith('vfs://')) {
            const parts = url.substring(6).split('/');
            const fileId = parts[0];
            const fileEntry = getVFSEntry(fileId);
            if (fileEntry && (fileEntry.mimeType === 'text/html' || fileEntry.name.endsWith('.html') || fileEntry.name.endsWith('.htm'))) {
                instance.iframe.srcdoc = fileEntry.content;
                instance.status.textContent = `Loaded from VFS: ${fileEntry.name}`;
                if (instance.titleBarTextElement) instance.titleBarTextElement.textContent = `🌐 ${fileEntry.name}`;
                logK8osActivity(`Browser (${instanceId})`, `Navigated (VFS): ${fileEntry.name}`);
            } else {
                throw new Error(`VFS file not found or not HTML: ${url}`);
            }
        } else {
            let fetchUrl = url;
            const isLikelyExternal = url.startsWith('http://') || url.startsWith('https://');
            const isFileProtocol = url.startsWith('file:///'); const isK8osLocal = window.location.protocol === 'file:';
            if (isFileProtocol || (isK8osLocal && !isLikelyExternal)) {
                instance.status.textContent = `Attempting to load (direct): ${url}`; instance.iframe.src = url;
                setTimeout(() => { if (instance.status.textContent.startsWith('Attempting')) { instance.status.textContent = `Attempted direct load: ${url}`; logK8osActivity(`Browser (${instanceId})`, `Navigated (direct): ${url.substring(0,50)}...`); } }, 1000);
            } else {
                if (!isLikelyExternal && !url.startsWith('/')) { /* Potentially prepend origin or handle relative paths */ }
                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${fetchUrl}`);
                const htmlContent = await response.text(); let finalHtml = htmlContent;
                const pathSegments = fetchUrl.split('/');
                const hasSubDirs = !isLikelyExternal && pathSegments.length > 1 && !pathSegments[pathSegments.length-1].includes('.');
                if (hasSubDirs && !htmlContent.toLowerCase().includes("<base")) {
                    let basePath = pathSegments.slice(0, pathSegments[pathSegments.length -1] === '' ? -2 : -1).join('/') + '/';
                     if (fetchUrl.startsWith(window.location.origin)) { basePath = new URL(basePath, window.location.href).pathname; }
                     else if (!fetchUrl.startsWith('http')) { basePath = '/' + basePath; }
                    if (finalHtml.includes("<head>")) { finalHtml = finalHtml.replace("<head>", `<head>\n<base href="${basePath}">`); }
                    else { finalHtml = `<head><base href="${basePath}"></head>` + finalHtml; }
                }
                instance.iframe.srcdoc = finalHtml; instance.status.textContent = `Loaded: ${url}`;
                logK8osActivity(`Browser (${instanceId})`, `Navigated (fetch): ${url.substring(0,50)}...`);
            }
             if (instance.titleBarTextElement) {
                let pageTitle = url; try { const tempDoc = instance.iframe.contentDocument || instance.iframe.contentWindow.document; if (tempDoc && tempDoc.title) { pageTitle = tempDoc.title; } } catch (e) { /* ignore */ }
                instance.titleBarTextElement.textContent = `🌐 ${pageTitle.substring(0, 50)}${pageTitle.length > 50 ? '...' : ''}`;
            }
        }

        if (addToHistory) {
            if (instance.historyIndex < instance.history.length - 1) { instance.history = instance.history.slice(0, instance.historyIndex + 1); }
            instance.history.push(url); instance.historyIndex = instance.history.length - 1;
        }
    } catch (error) { console.error(`Error loading URL in browser app (${instanceId}):`, error, "URL:", url); instance.iframe.srcdoc = `<p style="color:red;padding:10px;">Error loading page: ${url}<br>${error.message || String(error)}<br><small>Note: Loading local 'file:///' URLs directly has security restrictions. For best results with local files, serve k8OS and your files from a local HTTP server.</small></p>`; instance.status.textContent = `Error: ${error.message || String(error)}`; }
    updateWebBrowserNavButtonsInstance(instanceId);
}
function navigateToUrlInBrowserInstance(instanceId, url) { if (url) loadUrlInBrowserInstance(instanceId, url, true); }
function webBrowserNavigateInstance(instanceId, direction) {
    const instance = browserInstances[instanceId]; if (!instance) return;
    const newIndex = instance.historyIndex + direction;
    if (newIndex >= 0 && newIndex < instance.history.length) { instance.historyIndex = newIndex; loadUrlInBrowserInstance(instanceId, instance.history[instance.historyIndex], false); logK8osActivity(`Browser (${instanceId})`, `Used ${direction > 0 ? 'Forward' : 'Back'} to: ${instance.history[instance.historyIndex].substring(0,50)}...`); }
}
function updateWebBrowserNavButtonsInstance(instanceId) { const instance = browserInstances[instanceId]; if (!instance) return; instance.backButton.disabled = instance.historyIndex <= 0; instance.forwardButton.disabled = instance.historyIndex >= instance.history.length - 1; }

if(startButton) startButton.addEventListener('click', (e) => { e.stopPropagation(); startMenu.style.display = startMenu.style.display === 'flex' ? 'none' : 'flex'; hideContextMenu(); });
if(startMenuShutdown) startMenuShutdown.addEventListener('click', () => { startMenu.style.display = 'none'; if (confirm("Are you sure you want to shut down k8OS?")) { document.body.innerHTML = '<div style="position:fixed;top:0;left:0;width:100%;height:100%;background:black;color:white;display:flex;justify-content:center;align-items:center;font-size:24px;">k8OS is shutting down...</div>'; setTimeout(() => { window.close(); }, 2000); } });
if(startMenuReboot) startMenuReboot.addEventListener('click', () => { startMenu.style.display = 'none'; if (confirm("Are you sure you want to reboot k8OS?")) { rebootOverlay.style.display = 'flex'; rebootProgressText.textContent = "Closing applications..."; document.querySelectorAll('.window').forEach(w => closeWindow(w)); const rebootSteps = [ { delay: 700, text: "System integrity check..." }, { delay: 1200, text: "Loading kernel modules..." }, { delay: 1000, text: "Initializing desktop..." }, { delay: 800, text: "Mounting file systems..." }, { delay: 600, text: "Starting services..." }, { delay: 500, text: "Finalizing..." }, { delay: 400, text: "System ready." } ]; let currentStepIndex = 0; function processNextStep() { if (currentStepIndex < rebootSteps.length) { rebootProgressText.textContent = rebootSteps[currentStepIndex].text; setTimeout(processNextStep, rebootSteps[currentStepIndex].delay); currentStepIndex++; } else { rebootOverlay.style.display = 'none'; document.querySelectorAll('.desktop-icon.selected').forEach(i => i.classList.remove('selected')); k8osActivityLog = []; loadApiKey(); openWindow('apiKeySettingsWindow'); } } setTimeout(processNextStep, 500); } });
if(startMenuFactoryReset) startMenuFactoryReset.addEventListener('click', () => { startMenu.style.display = 'none'; handleFactoryReset(); });

function handleFactoryReset() {
    if (!confirm("DANGER ZONE!\n\nAre you absolutely sure you want to factory reset k8OS?\n\nALL data (API keys, files, settings, Sparky's memory) will be PERMANENTLY ERASED.\nThis action cannot be undone.")) {
        return;
    }
    console.warn("FACTORY RESET INITIATED!");
    if(assistantIsVisible) updateAssistantSpeech("Resetting... Bye! :(", false, false, true);

    const keysToClear = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('k8os_') ||
            ['GlobalGeminiApiKey', 'GlobalGroqApiKey', 'GlobalOpenRouterApiKey', 'GlobalDeepSeekApiKey', 'GlobalHfToken',
             'GlobalCustomApiKey',
             'desktopBgColor', 'desktopBgImageUrl', 'desktopBgImageSize',
             'desktopBgImageRepeat', 'desktopIconScaleFactor'].includes(key))
           ) {
            keysToClear.push(key);
        }
    }
    keysToClear.forEach(key => {
        console.log("Clearing localStorage key:", key);
        localStorage.removeItem(key);
    });

    sessionStorage.clear();

    if (rebootOverlay && rebootProgressText) {
        rebootOverlay.style.display = 'flex';
        rebootProgressText.textContent = "Factory Resetting System... Wiping data...";
    }

    setTimeout(() => {
        if (rebootProgressText) rebootProgressText.textContent = "Reloading k8OS...";
        setTimeout(() => {
            location.reload(true);
        }, 1500);
    }, 2000);
}

if (textEditor_sparkyAssistButton) {
    textEditor_sparkyAssistButton.addEventListener('click', async () => {
        const editorContent = textEditor_contentArea.value.trim();
        if (!editorContent) {
            textEditor_status.textContent = "Sparky Assist: Editor is empty. Type a plan for files/folders.";
            return;
        }
        textEditor_status.textContent = "Sparky Assist: Processing request...";
        updateAssistantSpeech("Let me help with those files...", false, true, true);

        const baseParentIdForCreation = currentTextEditorFileId ? getVFSEntry(currentTextEditorFileId)?.parentId : (currentFEVfsPathId || SPARKY_CREATIONS_VFS_ID || 'root');
        await processSparkyCommand(`Sparky, create file system based on editor content. ${editorContent}`, baseParentIdForCreation);

        if (fe_fileListElement && (currentFEVfsPathId === baseParentIdForCreation || baseParentIdForCreation === 'root')) {
            renderVFSFileList(currentFEVfsPathId);
        }
        textEditor_status.textContent = "Sparky Assist: Request sent.";
    });
}


function initSparkyDynamicBehavior() {
    if (assistantContainer && assistantIsVisible) {
        const desktopWidth = desktopElement.clientWidth;
        const desktopHeight = desktopElement.clientHeight;
        const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;

        if (!assistantContainer.style.left || !assistantContainer.style.top) {
             sparkyPosX = Math.random() * (desktopWidth - SPARKY_CONTAINER_WIDTH);
             sparkyPosY = Math.random() * (desktopHeight - SPARKY_CONTAINER_HEIGHT - taskbarHeight);
             assistantContainer.style.left = sparkyPosX + 'px';
             assistantContainer.style.top = sparkyPosY + 'px';
        } else {
            sparkyPosX = parseFloat(assistantContainer.style.left) || 50;
            sparkyPosY = parseFloat(assistantContainer.style.top) || 50;
        }
        startSparkyMovement();
    }
}

function startSparkyMovement() {
    if (sparkyMoveIntervalId) clearInterval(sparkyMoveIntervalId);
    sparkyMoveIntervalId = setInterval(updateSparkyPosition, 60);
}

function stopSparkyMovement() {
    if (sparkyMoveIntervalId) clearInterval(sparkyMoveIntervalId);
    sparkyMoveIntervalId = null;
}


function updateSparkyPosition() {
    if (!sparkyIsMoving || !assistantIsVisible || !assistantContainer || !desktopElement) return;

    const desktopWidth = desktopElement.clientWidth;
    const desktopHeight = desktopElement.clientHeight;
    const taskbarHeight = document.querySelector('.taskbar')?.offsetHeight || 30;

    sparkyPosX += sparkyVelX;
    sparkyPosY += sparkyVelY;

    if (sparkyPosX + SPARKY_CONTAINER_WIDTH >= desktopWidth) { sparkyVelX = -Math.abs(sparkyVelX); sparkyPosX = desktopWidth - SPARKY_CONTAINER_WIDTH; }
    else if (sparkyPosX <= 0) { sparkyVelX = Math.abs(sparkyVelX); sparkyPosX = 0; }
    if (sparkyPosY + SPARKY_CONTAINER_HEIGHT >= desktopHeight - taskbarHeight) { sparkyVelY = -Math.abs(sparkyVelY); sparkyPosY = desktopHeight - taskbarHeight - SPARKY_CONTAINER_HEIGHT; }
    else if (sparkyPosY <= 0) { sparkyVelY = Math.abs(sparkyVelY); sparkyPosY = 0; }

    assistantContainer.style.left = sparkyPosX + 'px';
    assistantContainer.style.top = sparkyPosY + 'px';

    const sparkyBobbingGroup = assistantAvatarSVG ? assistantAvatarSVG.querySelector('#sparkyBobbingGroup') : null;
    if (sparkyBobbingGroup && Math.random() < 0.0008 && !sparkyBobbingGroup.classList.contains('rolling')) {
        sparkyBobbingGroup.classList.add('rolling');
        setTimeout(() => {
            sparkyBobbingGroup.classList.remove('rolling');
            sparkyBobbingGroup.style.transform = '';
        }, 1000);
    }

    if (Math.random() < 0.005) {
        sparkyIsMoving = false;
        setTimeout(() => {
            sparkyIsMoving = true;
        }, Math.random() * 3000 + 2000);
    }
    if (Math.random() < 0.002) {
        sparkyVelX = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 1.5 + 0.5);
        sparkyVelY = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * 1.5 + 0.5);
    }
}

function initAllAiApps(){
    initSvgGeneratorApp();
    initGameGeneratorApp();
    initMusicStudioApp();
    initGifCreatorApp();
    if (selectedApiProvider !== 'gemini' || !window.GLOBAL_GEMINI_API_KEY) { assistant_gemini_model = null; }
    if (selectedApiProvider === 'transformersjs' && window.GLOBAL_TRANSFORMERSJS_MODEL_ID) {
        ensureTransformersJsPipeline(window.GLOBAL_TRANSFORMERSJS_MODEL_ID, (progress) => {
            const statusTarget = document.getElementById('systemSettingsWindow')?.style.display === 'flex' ? systemSettings_transformersjs_status : apiKeyStatus;
            if (statusTarget) {
                if (progress.status === 'loading') {
                    statusTarget.textContent = `Pre-warming ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID}: ${Math.round(progress.progress)}% (${progress.file})`;
                } else if (progress.status === 'loaded') {
                    statusTarget.textContent = `Model ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID} ready.`;
                } else if (progress.status === 'error') {
                    statusTarget.textContent = `Error pre-warming ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID}: ${(progress.message || String(progress)).substring(0,50)}`;
                } else {
                    statusTarget.textContent = `Pre-warming ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID}: ${Math.round(progress.progress || 0)}% (${progress.file || 'model files'})`;
                }
            }
        }).then(() => {
             const statusTarget = document.getElementById('systemSettingsWindow')?.style.display === 'flex' ? systemSettings_transformersjs_status : apiKeyStatus;
             if (statusTarget) statusTarget.textContent = `Local LLM ${window.GLOBAL_TRANSFORMERSJS_MODEL_ID} ready.`;
        }).catch(e => {
            console.error("Error pre-warming Transformers.js model:", e);
             const statusTarget = document.getElementById('systemSettingsWindow')?.style.display === 'flex' ? systemSettings_transformersjs_status : apiKeyStatus;
             if (statusTarget) statusTarget.textContent = `Error pre-warming: ${(e.message || String(e)).substring(0,50)}`;
        });
    }
}

loadApiKey();
openWindow('apiKeySettingsWindow');

</script>
</body>
</html>
