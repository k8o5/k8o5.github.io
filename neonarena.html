<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>WASD vs ARROWS - NEON BATTLE</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        h1 {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            margin: 0;
        }
        .score-board {
            display: flex;
            justify-content: center;
            gap: 50px;
            font-size: 40px;
            font-weight: bold;
            margin-top: 10px;
        }
        #p1-score { color: #00f0ff; text-shadow: 0 0 20px #00f0ff; }
        #p2-score { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #666;
            font-size: 12px;
        }
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        button {
            background: transparent;
            border: 2px solid white;
            color: white;
            padding: 15px 40px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 0 15px white;
        }
        button:hover {
            background: white;
            color: black;
            box-shadow: 0 0 30px white;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Neon Arena</h1>
        <div class="score-board">
            <div id="p1-score">0</div>
            <div>:</div>
            <div id="p2-score">0</div>
        </div>
    </div>

    <div id="instructions">
        WASD to Move & Space to Shoot <span style="margin: 0 20px">|</span> Arrows to Move & Enter to Shoot
    </div>

    <div id="start-screen">
        <h1 style="font-size: 60px; margin-bottom: 40px;">WASD vs ARROWS</h1>
        <button onclick="startGame()">FIGHT!</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/** 
 * AUDIO ENGINE (Synthesizer)
 * Erzeugt Sounds ohne externe Dateien
 */
const AudioEngine = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playShoot: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    },
    playExplosion: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const p1ScoreEl = document.getElementById('p1-score');
const p2ScoreEl = document.getElementById('p2-score');

let width, height;
let animationId;
let lastTime = 0;
let shakeTime = 0;

// Game State
let scores = { p1: 0, p2: 0 };
let keys = {};

// Configuration
const CONFIG = {
    friction: 0.92,
    acceleration: 1.5,
    maxSpeed: 8,
    bulletSpeed: 12,
    fireRate: 15 // frames
};

// Resize Handling
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input Handling
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// Classes
class Player {
    constructor(x, y, color, controls) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.radius = 20;
        this.color = color;
        this.controls = controls; // {u, d, l, r, fire}
        this.cooldown = 0;
        this.angle = 0;
        this.isDead = false;
        this.respawnTimer = 0;
    }

    update() {
        if (this.isDead) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) this.respawn();
            return;
        }

        // Movement
        if (keys[this.controls.u]) this.vy -= CONFIG.acceleration;
        if (keys[this.controls.d]) this.vy += CONFIG.acceleration;
        if (keys[this.controls.l]) this.vx -= CONFIG.acceleration;
        if (keys[this.controls.r]) this.vx += CONFIG.acceleration;

        // Physics
        this.vx *= CONFIG.friction;
        this.vy *= CONFIG.friction;
        this.x += this.vx;
        this.y += this.vy;

        // Wall Collision
        if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.5; }
        if (this.x > width - this.radius) { this.x = width - this.radius; this.vx *= -0.5; }
        if (this.y < this.radius) { this.y = this.radius; this.vy *= -0.5; }
        if (this.y > height - this.radius) { this.y = height - this.radius; this.vy *= -0.5; }

        // Rotation based on movement
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        // Shooting
        if (this.cooldown > 0) this.cooldown--;
        if (keys[this.controls.fire] && this.cooldown <= 0) {
            this.shoot();
        }
    }

    shoot() {
        // Shoot in direction of movement, or default direction if standing still
        let shootAngle = this.angle;
        if (Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5) {
            shootAngle = (this.color === '#00f0ff') ? 0 : Math.PI; // P1 right, P2 left
        }

        bullets.push(new Bullet(
            this.x + Math.cos(shootAngle) * (this.radius + 5),
            this.y + Math.sin(shootAngle) * (this.radius + 5),
            shootAngle,
            this.color
        ));
        
        // Recoil
        this.vx -= Math.cos(shootAngle) * 2;
        this.vy -= Math.sin(shootAngle) * 2;
        
        this.cooldown = CONFIG.fireRate;
        AudioEngine.playShoot();
    }

    die() {
        this.isDead = true;
        this.respawnTimer = 120; // 2 seconds at 60fps
        createExplosion(this.x, this.y, this.color);
        AudioEngine.playExplosion();
        shakeTime = 15;
        
        if (this.color === '#00f0ff') scores.p2++;
        else scores.p1++;
        
        updateScore();
    }

    respawn() {
        this.isDead = false;
        this.vx = 0;
        this.vy = 0;
        if (this.color === '#00f0ff') {
            this.x = width * 0.2;
            this.y = height / 2;
        } else {
            this.x = width * 0.8;
            this.y = height / 2;
        }
    }

    draw() {
        if (this.isDead) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        
        // Body
        ctx.fillStyle = '#000';
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        
        // Triangle shape
        ctx.beginPath();
        ctx.moveTo(this.radius, 0);
        ctx.lineTo(-this.radius, -this.radius + 5);
        ctx.lineTo(-this.radius/2, 0);
        ctx.lineTo(-this.radius, this.radius - 5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, angle, color) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * CONFIG.bulletSpeed;
        this.vy = Math.sin(angle) * CONFIG.bulletSpeed;
        this.color = color;
        this.life = 100;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        // Trail particles
        if (Math.random() > 0.5) {
            particles.push(new Particle(this.x, this.y, this.color, 0.5));
        }
    }

    draw() {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * speed + 1;
        this.vx = Math.cos(angle) * velocity;
        this.vy = Math.sin(angle) * velocity;
        this.color = color;
        this.alpha = 1;
        this.decay = Math.random() * 0.03 + 0.01;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.95;
        this.vy *= 0.95;
        this.alpha -= this.decay;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// Game Objects
let p1 = new Player(100, 100, '#00f0ff', { u: 'KeyW', d: 'KeyS', l: 'KeyA', r: 'KeyD', fire: 'Space' });
let p2 = new Player(500, 100, '#ff0055', { u: 'ArrowUp', d: 'ArrowDown', l: 'ArrowLeft', r: 'ArrowRight', fire: 'Enter' });
let bullets = [];
let particles = [];

function createExplosion(x, y, color) {
    for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y, color, 5));
    }
    for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, '#ffffff', 8));
    }
}

function updateScore() {
    p1ScoreEl.innerText = scores.p1;
    p2ScoreEl.innerText = scores.p2;
}

function checkCollisions() {
    bullets.forEach((b, bIndex) => {
        // Check P1
        if (!p1.isDead && b.color !== p1.color) {
            const dx = b.x - p1.x;
            const dy = b.y - p1.y;
            if (Math.sqrt(dx*dx + dy*dy) < p1.radius + 4) {
                p1.die();
                bullets.splice(bIndex, 1);
                return;
            }
        }
        // Check P2
        if (!p2.isDead && b.color !== p2.color) {
            const dx = b.x - p2.x;
            const dy = b.y - p2.y;
            if (Math.sqrt(dx*dx + dy*dy) < p2.radius + 4) {
                p2.die();
                bullets.splice(bIndex, 1);
                return;
            }
        }
    });
}

function drawGrid() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    const gridSize = 50;
    
    // Offset grid for pseudo-motion if desired, static here for cleanliness
    for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
    }
    for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
    }
}

function loop() {
    // Trail effect (instead of clearRect)
    ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
    ctx.fillRect(0, 0, width, height);
    
    // Screen Shake
    ctx.save();
    if (shakeTime > 0) {
        const mag = shakeTime / 2;
        const dx = (Math.random() - 0.5) * mag;
        const dy = (Math.random() - 0.5) * mag;
        ctx.translate(dx, dy);
        shakeTime--;
    }

    drawGrid();

    // Logic
    p1.update();
    p2.update();
    
    bullets.forEach((b, i) => {
        b.update();
        if (b.life <= 0 || b.x < 0 || b.x > width || b.y < 0 || b.y > height) {
            bullets.splice(i, 1);
        }
    });

    particles.forEach((p, i) => {
        p.update();
        if (p.alpha <= 0) particles.splice(i, 1);
    });

    checkCollisions();

    // Render
    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());
    p1.draw();
    p2.draw();

    ctx.restore();
    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    AudioEngine.init();
    
    // Reset Positions
    p1.x = width * 0.2; p1.y = height / 2;
    p2.x = width * 0.8; p2.y = height / 2;
    p1.vx = p1.vy = p2.vx = p2.vy = 0;
    
    loop();
}

</script>
</body>
</html>
