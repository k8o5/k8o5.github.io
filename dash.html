<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dash8</title>
    <link rel="icon" href="buh/img_dash.png" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Rajdhani', sans-serif;
        }
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .hud.visible {
            opacity: 1;
        }
        .hud-panel {
            background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(30,30,50,0.6) 100%);
            border: 2px solid rgba(255,215,0,0.5);
            border-radius: 15px;
            padding: 15px 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255,215,0,0.2), inset 0 0 20px rgba(255,255,255,0.05);
        }
        .hud-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: rgba(255,215,0,0.8);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }
        .hud-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }
        .coin-counter {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .coin-icon {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle at 30% 30%, #ffd700, #b8860b);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255,215,0,0.6);
        }
        .speed-bar {
            width: 200px;
            height: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        .speed-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffff);
            border-radius: 4px;
            transition: width 0.1s;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }
        .center-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        .center-message.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            font-weight: 900;
            color: #ff4444;
            text-shadow: 0 0 50px rgba(255,68,68,0.8), 0 0 100px rgba(255,68,68,0.4);
            margin-bottom: 20px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .start-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 64px;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700, #ff6b35, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            filter: drop-shadow(0 0 30px rgba(255,215,0,0.8));
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .subtitle {
            font-size: 24px;
            color: rgba(255,255,255,0.8);
            margin-bottom: 40px;
        }
        .btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            padding: 15px 50px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            pointer-events: auto;
            background: linear-gradient(135deg, #ffd700, #ff6b35);
            color: #000;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
        }
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(255,215,0,0.6);
        }
        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .controls-hint.visible {
            opacity: 0.7;
        }
        .key {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #fff;
        }
        .key-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .key-label {
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
        }
        .combo-display {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        .combo-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #00ffff;
            text-shadow: 0 0 30px rgba(0,255,255,0.8);
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s;
        }
        .combo-text.active {
            opacity: 1;
            transform: scale(1);
        }
        .level-up {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255,215,0,0.8);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .level-up.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        #debug {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <div id="ui">
        <div class="hud" id="hud">
            <div class="hud-panel">
                <div class="hud-title">Distance</div>
                <div class="hud-value" id="distance">0</div>
                <div class="speed-bar">
                    <div class="speed-fill" id="speedBar" style="width: 0%"></div>
                </div>
            </div>
            <div class="hud-panel">
                <div class="hud-title">Level</div>
                <div class="hud-value" id="level">1</div>
            </div>
            <div class="hud-panel coin-counter">
                <div class="coin-icon"></div>
                <div class="hud-value" id="coins">0</div>
            </div>
        </div>

        <div class="center-message visible" id="startScreen">
            <div class="start-title">dash8</div>
            <div class="subtitle">Endless 3D Adventure</div>
            <button class="btn" id="startBtn">START GAME</button>
            <div style="margin-top: 30px; font-size: 14px; color: rgba(255,255,255,0.5);">
                Arrow Keys / WASD to move | Space to jump | Shift to sprint
            </div>
        </div>

        <div class="center-message" id="gameOverScreen">
            <div class="game-over-title">GAME OVER</div>
            <div class="subtitle">Distance: <span id="finalDistance">0</span>m | Coins: <span id="finalCoins">0</span></div>
            <button class="btn" id="restartBtn">PLAY AGAIN</button>
        </div>

        <div class="combo-display">
            <div class="combo-text" id="comboText">PERFECT!</div>
        </div>

        <div class="level-up" id="levelUp">LEVEL UP!</div>

        <div class="controls-hint" id="controls">
            <div class="key-group">
                <div class="key">←</div>
                <div class="key-label">Left</div>
            </div>
            <div class="key-group">
                <div class="key">→</div>
                <div class="key-label">Right</div>
            </div>
            <div class="key-group">
                <div class="key">↑</div>
                <div class="key-label">Jump</div>
            </div>
            <div class="key-group">
                <div class="key">⇧</div>
                <div class="key-label">Sprint</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // ============ GAME CONFIGURATION ============
        const CONFIG = {
            player: {
                speed: 0.3,
                sprintMultiplier: 1.8,
                jumpForce: 0.45,
                bounceMultiplier: 1.6,
                gravity: 0.02,
                size: { width: 1, height: 1.8, depth: 1 }
            },
            world: {
                renderDistance: 150,
                cleanupDistance: 80
            },
            camera: {
                height: 6,
                smoothing: 0.1
            }
        };

        // ============ GLOBAL STATE ============
        let scene, camera, renderer;
        let player;
        let platforms = [], enemies = [], coins = [], bouncyPlatforms = [], decorations = [], items = [];
        let particles = [];
        let lastPlatformX = 0, lastPlatformY = 3;
        let level = 1, coinCount = 0, combo = 0;
        let gameOver = false, gameStarted = false;
        let clock;
        let sunLight;

        const keys = { left: false, right: false, jump: false, sprint: false };

        // ============ AUDIO SYSTEM ============
        const AudioSystem = {
            context: null,
            initialized: false,
            init() {
                if (this.initialized) return;
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch(e) {
                    console.log('Audio not available');
                }
            },
            play(type) {
                if (!this.context) return;
                try {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    
                    switch(type) {
                        case 'jump':
                            osc.frequency.setValueAtTime(300, this.context.currentTime);
                            osc.frequency.exponentialRampToValueAtTime(600, this.context.currentTime + 0.1);
                            gain.gain.setValueAtTime(0.1, this.context.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
                            osc.start();
                            osc.stop(this.context.currentTime + 0.1);
                            break;
                        case 'coin':
                            osc.frequency.setValueAtTime(880, this.context.currentTime);
                            osc.frequency.setValueAtTime(1320, this.context.currentTime + 0.08);
                            gain.gain.setValueAtTime(0.1, this.context.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);
                            osc.start();
                            osc.stop(this.context.currentTime + 0.15);
                            break;
                        case 'bounce':
                            osc.frequency.setValueAtTime(200, this.context.currentTime);
                            osc.frequency.exponentialRampToValueAtTime(800, this.context.currentTime + 0.15);
                            gain.gain.setValueAtTime(0.15, this.context.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);
                            osc.start();
                            osc.stop(this.context.currentTime + 0.15);
                            break;
                        case 'stomp':
                            osc.type = 'square';
                            osc.frequency.setValueAtTime(150, this.context.currentTime);
                            osc.frequency.exponentialRampToValueAtTime(50, this.context.currentTime + 0.1);
                            gain.gain.setValueAtTime(0.15, this.context.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
                            osc.start();
                            osc.stop(this.context.currentTime + 0.1);
                            break;
                        case 'item':
                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(440, this.context.currentTime);
                            osc.frequency.linearRampToValueAtTime(880, this.context.currentTime + 0.2);
                            gain.gain.setValueAtTime(0.1, this.context.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                            osc.start();
                            osc.stop(this.context.currentTime + 0.2);
                            break;
                        case 'levelup':
                            [523, 659, 784, 1047].forEach((freq, i) => {
                                const o = this.context.createOscillator();
                                const g = this.context.createGain();
                                o.connect(g);
                                g.connect(this.context.destination);
                                o.frequency.setValueAtTime(freq, this.context.currentTime + i * 0.1);
                                g.gain.setValueAtTime(0.1, this.context.currentTime + i * 0.1);
                                g.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + i * 0.1 + 0.2);
                                o.start(this.context.currentTime + i * 0.1);
                                o.stop(this.context.currentTime + i * 0.1 + 0.2);
                            });
                            break;
                    }
                } catch(e) {}
            }
        };

        // ============ PARTICLE SYSTEM ============
        class Particle {
            constructor(position, color, velocity, life = 1) {
                const geometry = new THREE.SphereGeometry(0.1, 6, 6);
                const material = new THREE.MeshBasicMaterial({ color, transparent: true });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.velocity = velocity;
                this.life = life;
                this.maxLife = life;
                scene.add(this.mesh);
            }
            
            update(delta) {
                this.velocity.y -= 0.02;
                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta * 60));
                this.life -= delta;
                this.mesh.material.opacity = this.life / this.maxLife;
                this.mesh.scale.setScalar(this.life / this.maxLife);
                return this.life > 0;
            }
            
            destroy() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        function spawnParticles(position, color, count = 10, spread = 0.2) {
            for (let i = 0; i < count; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    Math.random() * spread * 0.5,
                    (Math.random() - 0.5) * spread
                );
                particles.push(new Particle(position.clone(), color, velocity, 0.5 + Math.random() * 0.5));
            }
        }

        // ============ CREATE PLAYER ============
        function createPlayer() {
            const group = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.4 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 });
            const blueMat = new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.4 });
            
            // Body
            const bodyGeom = new THREE.CylinderGeometry(0.35, 0.4, 0.9, 12);
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.55;
            body.castShadow = true;
            group.add(body);
            
            // Overalls
            const overallsGeom = new THREE.CylinderGeometry(0.36, 0.42, 0.5, 12);
            const overalls = new THREE.Mesh(overallsGeom, blueMat);
            overalls.position.y = 0.35;
            overalls.castShadow = true;
            group.add(overalls);
            
            // Head
            const headGeom = new THREE.SphereGeometry(0.32, 16, 12);
            const head = new THREE.Mesh(headGeom, skinMat);
            head.position.y = 1.3;
            head.castShadow = true;
            group.add(head);
            
            // Hat
            const hatGeom = new THREE.CylinderGeometry(0.22, 0.35, 0.2, 12);
            const hat = new THREE.Mesh(hatGeom, bodyMat);
            hat.position.y = 1.55;
            hat.castShadow = true;
            group.add(hat);
            
            // Hat brim
            const brimGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.06, 12);
            const brim = new THREE.Mesh(brimGeom, bodyMat);
            brim.position.y = 1.45;
            brim.position.z = 0.1;
            brim.castShadow = true;
            group.add(brim);
            
            // Eyes
            const eyeGeom = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeWhiteGeom = new THREE.SphereGeometry(0.09, 8, 8);
            const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            [-0.1, 0.1].forEach(x => {
                const eyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
                eyeWhite.position.set(x, 1.35, 0.25);
                group.add(eyeWhite);
                
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(x, 1.35, 0.3);
                group.add(eye);
            });
            
            // Nose
            const noseGeom = new THREE.SphereGeometry(0.08, 8, 8);
            const nose = new THREE.Mesh(noseGeom, skinMat);
            nose.position.set(0, 1.25, 0.3);
            group.add(nose);
            
            // Mustache
            const mustacheGeom = new THREE.BoxGeometry(0.25, 0.04, 0.08);
            const mustacheMat = new THREE.MeshBasicMaterial({ color: 0x4a3728 });
            const mustache = new THREE.Mesh(mustacheGeom, mustacheMat);
            mustache.position.set(0, 1.18, 0.28);
            group.add(mustache);
            
            return group;
        }

        // ============ PLAYER OBJECT ============
        class Player {
            constructor() {
                this.position = new THREE.Vector3(5, 8, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.onGround = false;
                this.size = CONFIG.player.size;
                this.powerupTimer = 0;
                this.powerupType = null;
                
                this.mesh = createPlayer();
                this.mesh.position.copy(this.position);
                
                this.light = new THREE.PointLight(0xffaa44, 0.5, 8);
            }
            
            reset() {
                this.position.set(5, 8, 0);
                this.velocity.set(0, 0, 0);
                this.onGround = false;
                this.powerupTimer = 0;
                this.powerupType = null;
                this.mesh.position.copy(this.position);
                this.mesh.rotation.set(0, 0, 0);
                this.mesh.scale.set(1, 1, 1);
            }
            
            update(delta) {
                let speed = CONFIG.player.speed;
                let jump = CONFIG.player.jumpForce;

                // Apply Powerups
                if (this.powerupTimer > 0) {
                    this.powerupTimer -= delta;
                    if (this.powerupType === 'speed') speed *= 1.5;
                    if (this.powerupType === 'jump') jump *= 1.4;
                    
                    // Visual feedback for powerup
                    this.mesh.rotation.y += delta * 5;
                    if (this.powerupTimer <= 0) {
                        this.powerupType = null;
                        this.mesh.rotation.y = 0;
                    }
                }

                if (keys.sprint) speed *= CONFIG.player.sprintMultiplier;
                
                // Horizontal movement
                if (keys.right) {
                    this.velocity.x = speed;
                } else if (keys.left) {
                    this.velocity.x = -speed;
                } else {
                    this.velocity.x *= 0.85;
                }
                
                // Gravity
                this.velocity.y -= CONFIG.player.gravity;
                
                // Clamp velocity
                this.velocity.y = Math.max(this.velocity.y, -1);
                
                // Update position
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                
                // Jump
                if (keys.jump && this.onGround) {
                    this.velocity.y = jump;
                    this.onGround = false;
                    AudioSystem.play('jump');
                    spawnParticles(this.position.clone(), 0xffffff, 8, 0.2);
                }
                
                // Update mesh
                this.mesh.position.copy(this.position);
                this.light.position.set(this.position.x, this.position.y + 1.5, this.position.z + 2);
                
                // Tilt based on movement
                this.mesh.rotation.z = -this.velocity.x * 0.3;
                
                // Squash/stretch
                if (!this.onGround) {
                    const stretch = 1 + Math.abs(this.velocity.y) * 0.15;
                    this.mesh.scale.set(1/Math.sqrt(stretch), stretch, 1/Math.sqrt(stretch));
                } else {
                    this.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.2);
                }
                
                // Fall death
                if (this.position.y < -15) {
                    endGame();
                }
            }
            
            getBoundingBox() {
                return new THREE.Box3(
                    new THREE.Vector3(this.position.x - 0.4, this.position.y, this.position.z - 0.4),
                    new THREE.Vector3(this.position.x + 0.4, this.position.y + 1.7, this.position.z + 0.4)
                );
            }
        }

        // ============ ITEM CREATION ============
        function createItemBox(x, y) {
            const group = new THREE.Group();
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                metalness: 0.8, 
                roughness: 0.2,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);

            // Add a "?" sign roughly
            const signGeom = new THREE.BoxGeometry(0.2, 0.5, 1.05);
            const signMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const sign = new THREE.Mesh(signGeom, signMat);
            group.add(sign);

            group.position.set(x, y, 0);
            scene.add(group);

            return {
                mesh: group,
                x, y,
                active: true,
                update() {
                    if (this.active) {
                        this.mesh.rotation.y += 0.05;
                    }
                },
                getBoundingBox() {
                    return new THREE.Box3(
                        new THREE.Vector3(this.x - 0.5, this.y - 0.5, -0.5),
                        new THREE.Vector3(this.x + 0.5, this.y + 0.5, 0.5)
                    );
                }
            };
        }

        // ============ PLATFORM CREATION ============
        function createPlatform(x, y, width, height, depth, type = 'normal') {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            let color;
            switch(type) {
                case 'bouncy': color = 0x9b59b6; break;
                case 'stone': color = 0x7f8c8d; break;
                case 'wood': color = 0xd35400; break;
                default: color = 0x8B4513;
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x + width/2, y - height/2, 0);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Grass top for normal platforms
            if (type === 'normal') {
                const grassGeom = new THREE.BoxGeometry(width + 0.1, 0.3, depth + 0.1);
                const grassMat = new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 0.9 });
                const grass = new THREE.Mesh(grassGeom, grassMat);
                grass.position.y = height/2;
                grass.castShadow = true;
                mesh.add(grass);
            }
            
            // Glow for bouncy
            if (type === 'bouncy') {
                const glowGeom = new THREE.BoxGeometry(width + 0.3, height + 0.3, depth + 0.3);
                const glowMat = new THREE.MeshBasicMaterial({ color: 0x9b59b6, transparent: true, opacity: 0.3 });
                mesh.add(new THREE.Mesh(glowGeom, glowMat));
            }
            
            scene.add(mesh);
            
            const platform = {
                mesh, x, y, width, height, depth, type,
                getBoundingBox() {
                    return new THREE.Box3(
                        new THREE.Vector3(x, y - height, -depth/2),
                        new THREE.Vector3(x + width, y, depth/2)
                    );
                }
            };
            
            return platform;
        }

        // ============ ENEMY CREATION ============
        function createEnemy(x, y, velocityX) {
            const group = new THREE.Group();
            
            // Body
            const bodyGeom = new THREE.SphereGeometry(0.45, 12, 10);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xc0392b, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.45;
            body.scale.y = 0.85;
            body.castShadow = true;
            group.add(body);
            
            // Eyes
            const eyeGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const pupilGeom = new THREE.SphereGeometry(0.05, 6, 6);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            [-0.15, 0.15].forEach(xOff => {
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(xOff, 0.55, 0.35);
                group.add(eye);
                
                const pupil = new THREE.Mesh(pupilGeom, pupilMat);
                pupil.position.set(xOff, 0.55, 0.42);
                group.add(pupil);
            });
            
            // Eyebrows
            const browGeom = new THREE.BoxGeometry(0.18, 0.04, 0.04);
            const browMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            [-0.15, 0.15].forEach((xOff, i) => {
                const brow = new THREE.Mesh(browGeom, browMat);
                brow.position.set(xOff, 0.68, 0.38);
                brow.rotation.z = i === 0 ? -0.4 : 0.4;
                group.add(brow);
            });
            
            // Feet
            const footGeom = new THREE.SphereGeometry(0.15, 8, 6);
            const footMat = new THREE.MeshStandardMaterial({ color: 0x2c1810 });
            [-0.2, 0.2].forEach(xOff => {
                const foot = new THREE.Mesh(footGeom, footMat);
                foot.position.set(xOff, 0.1, 0.1);
                foot.castShadow = true;
                group.add(foot);
            });
            
            group.position.set(x, y, 0);
            scene.add(group);
            
            return {
                mesh: group,
                x, y,
                baseY: y,
                velocityX,
                time: Math.random() * 10,
                update(delta) {
                    this.x += this.velocityX;
                    this.time += delta * 8;
                    this.mesh.position.x = this.x;
                    this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.time)) * 0.15;
                    this.mesh.rotation.z = Math.sin(this.time) * 0.15;
                },
                getBoundingBox() {
                    return new THREE.Box3(
                        new THREE.Vector3(this.x - 0.4, this.mesh.position.y, -0.4),
                        new THREE.Vector3(this.x + 0.4, this.mesh.position.y + 0.9, 0.4)
                    );
                }
            };
        }

        // ============ COIN CREATION ============
        function createCoin(x, y) {
            const geometry = new THREE.TorusGeometry(0.25, 0.08, 8, 20);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.9,
                emissive: 0xffaa00,
                emissiveIntensity: 0.3
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, 0);
            mesh.rotation.x = Math.PI / 2;
            mesh.castShadow = true;
            
            scene.add(mesh);
            
            return {
                mesh, x,
                baseY: y,
                time: Math.random() * 10,
                update() {
                    this.time += 0.08;
                    this.mesh.rotation.z += 0.1;
                    this.mesh.position.y = this.baseY + Math.sin(this.time) * 0.15;
                },
                getBoundingBox() {
                    return new THREE.Box3(
                        new THREE.Vector3(this.x - 0.3, this.mesh.position.y - 0.3, -0.3),
                        new THREE.Vector3(this.x + 0.3, this.mesh.position.y + 0.3, 0.3)
                    );
                }
            };
        }

        // ============ DECORATIONS ============
        function createTree(x, y) {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeom = new THREE.CylinderGeometry(0.15, 0.25, 2, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Foliage
            for (let i = 0; i < 3; i++) {
                const size = 1.2 - i * 0.25;
                const foliageGeom = new THREE.ConeGeometry(size, 1.2, 8);
                const foliageMat = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22, 
                    roughness: 0.8,
                    flatShading: true
                });
                const foliage = new THREE.Mesh(foliageGeom, foliageMat);
                foliage.position.y = 2.2 + i * 0.7;
                foliage.castShadow = true;
                group.add(foliage);
            }
            
            group.position.set(x, y, -4 - Math.random() * 8);
            group.scale.setScalar(0.7 + Math.random() * 0.5);
            scene.add(group);
            
            return { mesh: group, x };
        }

        function createCloud(x, y, z) {
            const group = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 1,
                transparent: true,
                opacity: 0.9
            });
            
            for (let i = 0; i < 4; i++) {
                const size = 1 + Math.random() * 1.2;
                const geom = new THREE.SphereGeometry(size, 8, 6);
                const cloud = new THREE.Mesh(geom, cloudMat);
                cloud.position.set((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 0.8, (Math.random() - 0.5) * 1.5);
                group.add(cloud);
            }
            
            group.position.set(x, y, z);
            scene.add(group);
            
            return { mesh: group, x, baseX: x, speed: 0.005 + Math.random() * 0.01 };
        }

        function createMountain(x, z) {
            const group = new THREE.Group();
            
            const height = 15 + Math.random() * 25;
            const radius = 8 + Math.random() * 12;
            
            const mountainGeom = new THREE.ConeGeometry(radius, height, 6);
            const mountainMat = new THREE.MeshStandardMaterial({
                color: 0x4a5568,
                roughness: 0.9,
                flatShading: true
            });
            const mountain = new THREE.Mesh(mountainGeom, mountainMat);
            mountain.position.y = height / 2 - 5;
            group.add(mountain);
            
            // Snow
            const snowGeom = new THREE.ConeGeometry(radius * 0.3, height * 0.15, 6);
            const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const snow = new THREE.Mesh(snowGeom, snowMat);
            snow.position.y = height - 5;
            group.add(snow);
            
            group.position.set(x, 0, z);
            scene.add(group);
            
            return { mesh: group, x };
        }

        // ============ WORLD GENERATION ============
        const chunkGenerators = [
            // Flat run
            function(startX, startY, progress) {
                const length = Math.max(8, 18 - progress / 600);
                platforms.push(createPlatform(startX, startY, length, 2, 4));
                
                if (Math.random() < 0.4) {
                    decorations.push(createTree(startX + Math.random() * length, startY));
                }
                
                if (Math.random() < 0.25 + progress / 15000) {
                    enemies.push(createEnemy(startX + length / 2, startY + 0.9, -(0.03 + progress / 40000)));
                }

                if (Math.random() < 0.15) {
                    items.push(createItemBox(startX + length / 2, startY + 4));
                }
                
                if (Math.random() < 0.4) {
                    coins.push(createCoin(startX + 2 + Math.random() * (length - 4), startY + 2));
                }
                
                return { newX: startX + length, newY: startY };
            },
            
            // Stairs up
            function(startX, startY, progress) {
                let currentX = startX;
                let currentY = startY;
                const steps = 2 + Math.floor(Math.random() * 2);
                
                for (let i = 0; i < steps; i++) {
                    currentX += 3;
                    currentY += 1.2;
                    platforms.push(createPlatform(currentX, currentY, 3.5, 1.2, 4, 'stone'));
                    
                    if (Math.random() < 0.6) {
                        coins.push(createCoin(currentX + 1.75, currentY + 1.5));
                    }
                }
                
                return { newX: currentX + 3.5, newY: currentY };
            },
            
            // Floating blocks
            function(startX, startY, progress) {
                let currentX = startX;
                const blockCount = 2 + Math.floor(Math.random() * 3);
                const gap = 2.5 + Math.min(2, progress / 1500);
                
                for (let i = 0; i < blockCount; i++) {
                    currentX += gap;
                    const width = Math.max(2.5, 4.5 - progress / 1500);
                    platforms.push(createPlatform(currentX, startY, width, 1, 4, 'wood'));
                    
                    if (Math.random() < 0.6) {
                        coins.push(createCoin(currentX + width/2, startY + 1.8));
                    }
                }
                
                return { newX: currentX + 4, newY: startY };
            },
            
            // Pit jump
            function(startX, startY, progress) {
                const pitWidth = 3 + Math.min(3.5, progress / 600);
                const newX = startX + pitWidth;
                const landingWidth = Math.max(5, 12 - progress / 500);
                
                platforms.push(createPlatform(newX, startY, landingWidth, 2, 4));
                
                // Coins over pit
                coins.push(createCoin(startX + pitWidth / 2, startY + 2.5));
                
                return { newX: newX + landingWidth, newY: startY };
            },
            
            // Bouncy path
            function(startX, startY, progress) {
                const newY = startY + 2.5;
                const highPlatformX = startX + 7;
                
                bouncyPlatforms.push(createPlatform(startX + 2, startY, 2, 0.8, 4, 'bouncy'));
                platforms.push(createPlatform(highPlatformX, newY, 7, 1.5, 4));
                
                for (let i = 0; i < 4; i++) {
                    coins.push(createCoin(highPlatformX + 1.5 + i * 1.5, newY + 1.8));
                }
                
                return { newX: highPlatformX + 7, newY: newY };
            }
        ];

        function generateWorld() {
            while (lastPlatformX < player.position.x + CONFIG.world.renderDistance) {
                const progress = player.position.x;
                const generator = chunkGenerators[Math.floor(Math.random() * chunkGenerators.length)];
                
                let nextY = lastPlatformY + (Math.random() - 0.5) * 1.5;
                nextY = Math.max(2, Math.min(7, nextY));
                
                const { newX, newY } = generator(lastPlatformX, nextY, progress);
                lastPlatformX = newX;
                lastPlatformY = newY;
                
                if (Math.random() < 0.12) {
                    decorations.push(createCloud(
                        lastPlatformX + Math.random() * 25,
                        14 + Math.random() * 8,
                        -25 - Math.random() * 35
                    ));
                }
                
                if (Math.random() < 0.04) {
                    decorations.push(createMountain(
                        lastPlatformX + Math.random() * 40,
                        -45 - Math.random() * 40
                    ));
                }
            }
        }

        function cleanupWorld() {
            const cleanupX = player.position.x - CONFIG.world.cleanupDistance;
            
            [platforms, enemies, coins, bouncyPlatforms, decorations, items].forEach(arr => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    const objX = arr[i].x !== undefined ? arr[i].x : arr[i].mesh.position.x;
                    if (objX < cleanupX) {
                        scene.remove(arr[i].mesh);
                        arr.splice(i, 1);
                    }
                }
            });
        }

        // ============ COLLISION DETECTION ============
        function checkCollisions() {
            const playerBox = player.getBoundingBox();
            let groundedThisFrame = false;
            
            // Use predictive collision for platforms to prevent falling through
            [...platforms, ...bouncyPlatforms].forEach(platform => {
                const platBox = platform.getBoundingBox();
                
                if (playerBox.intersectsBox(platBox)) {
                    // Check if player is falling onto the platform
                    const playerBottom = player.position.y;
                    const platformTop = platBox.max.y;
                    
                    // If player is falling and was previously above platform (or very close to top)
                    if (player.velocity.y <= 0 && playerBottom >= platformTop - 0.6) {
                        player.position.y = platformTop;
                        player.velocity.y = 0;
                        groundedThisFrame = true;
                        
                        if (platform.type === 'bouncy') {
                            player.velocity.y = CONFIG.player.jumpForce * CONFIG.player.bounceMultiplier;
                            groundedThisFrame = false;
                            AudioSystem.play('bounce');
                            spawnParticles(player.position.clone(), 0x9b59b6, 12, 0.25);
                        }
                    }
                }
            });

            player.onGround = groundedThisFrame;
            
            // Item Box Collisions (Hitting from bottom)
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (!item.active) continue;
                const itemBox = item.getBoundingBox();
                
                if (playerBox.intersectsBox(itemBox)) {
                    // Check if hit from below
                    if (player.velocity.y > 0 && player.position.y < item.y - 0.4) {
                        item.active = false;
                        scene.remove(item.mesh);
                        triggerPowerup();
                        items.splice(i, 1);
                        player.velocity.y = 0; // stop upward momentum
                        AudioSystem.play('item');
                    }
                }
            }
            
            // Enemy collisions
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyBox = enemy.getBoundingBox();
                
                if (playerBox.intersectsBox(enemyBox)) {
                    const playerBottom = player.position.y;
                    const enemyTop = enemyBox.max.y;
                    
                    if (player.velocity.y < 0 && playerBottom > enemyTop - 0.3) {
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                        player.velocity.y = CONFIG.player.jumpForce * 0.6;
                        combo++;
                        coinCount += combo;
                        showCombo();
                        AudioSystem.play('stomp');
                        spawnParticles(new THREE.Vector3(enemy.x, enemy.mesh.position.y + 0.4, 0), 0xe74c3c, 15, 0.35);
                    } else {
                        endGame();
                    }
                }
            }
            
            // Coin collisions
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                const coinBox = coin.getBoundingBox();
                
                if (playerBox.intersectsBox(coinBox)) {
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                    coinCount++;
                    AudioSystem.play('coin');
                    spawnParticles(new THREE.Vector3(coin.x, coin.mesh.position.y, 0), 0xffd700, 12, 0.25);
                }
            }
        }

        function triggerPowerup() {
            const rand = Math.random();
            const comboText = document.getElementById('comboText');
            comboText.classList.add('active');
            
            if (rand < 0.33) {
                player.powerupType = 'speed';
                player.powerupTimer = 8;
                comboText.textContent = "SUPER SPEED!";
                comboText.style.color = "#00ff88";
            } else if (rand < 0.66) {
                player.powerupType = 'jump';
                player.powerupTimer = 10;
                comboText.textContent = "MEGA JUMP!";
                comboText.style.color = "#ff00ff";
            } else {
                coinCount += 50;
                comboText.textContent = "+50 COINS!";
                comboText.style.color = "#ffd700";
            }
            
            setTimeout(() => {
                comboText.classList.remove('active');
                comboText.style.color = "#00ffff";
            }, 1500);
        }

        // ============ UI ============
        function updateUI() {
            document.getElementById('distance').textContent = Math.floor(player.position.x * 10);
            document.getElementById('coins').textContent = coinCount;
            
            const newLevel = 1 + Math.floor(player.position.x / 100);
            if (newLevel > level) {
                level = newLevel;
                showLevelUp();
                AudioSystem.play('levelup');
            }
            document.getElementById('level').textContent = level;
            
            const speed = Math.abs(player.velocity.x) / (CONFIG.player.speed * CONFIG.player.sprintMultiplier);
            document.getElementById('speedBar').style.width = Math.min(100, speed * 100) + '%';
        }

        function showCombo() {
            const comboText = document.getElementById('comboText');
            const messages = ['NICE!', 'GREAT!', 'AWESOME!', 'PERFECT!', 'INCREDIBLE!'];
            comboText.textContent = messages[Math.min(combo - 1, messages.length - 1)] + ` +${combo}`;
            comboText.classList.add('active');
            setTimeout(() => comboText.classList.remove('active'), 700);
        }

        function showLevelUp() {
            const el = document.getElementById('levelUp');
            el.textContent = `LEVEL ${level}!`;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1800);
        }

        // ============ GAME STATE ============
        function startGame() {
            AudioSystem.init();
            gameStarted = true;
            gameOver = false;
            
            document.getElementById('startScreen').classList.remove('visible');
            document.getElementById('hud').classList.add('visible');
            document.getElementById('controls').classList.add('visible');
            
            player.reset();
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;
            document.getElementById('finalDistance').textContent = Math.floor(player.position.x * 10);
            document.getElementById('finalCoins').textContent = coinCount;
            document.getElementById('gameOverScreen').classList.add('visible');
        }

        function restartGame() {
            [...platforms, ...enemies, ...coins, ...bouncyPlatforms, ...decorations, ...items].forEach(obj => {
                if (obj.mesh) scene.remove(obj.mesh);
            });
            particles.forEach(p => p.destroy());
            
            platforms = [];
            enemies = [];
            coins = [];
            bouncyPlatforms = [];
            decorations = [];
            particles = [];
            items = [];
            
            lastPlatformX = 0;
            lastPlatformY = 3;
            level = 1;
            coinCount = 0;
            combo = 0;
            gameOver = false;
            
            player.reset();
            
            platforms.push(createPlatform(0, 3, 12, 2, 4));
            lastPlatformX = 12;
            
            document.getElementById('gameOverScreen').classList.remove('visible');
            updateUI();
        }

        // ============ INITIALIZATION ============
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 40, 180);
            
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 10, 18);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            const ambient = new THREE.AmbientLight(0x6688cc, 0.5);
            scene.add(ambient);
            
            sunLight = new THREE.DirectionalLight(0xffffee, 1.3);
            sunLight.position.set(40, 80, 40);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 250;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            scene.add(sunLight.target);
            
            const hemisphere = new THREE.HemisphereLight(0x87CEEB, 0x3d5c3d, 0.5);
            scene.add(hemisphere);
            
            const groundGeom = new THREE.PlaneGeometry(2000, 200);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a5276, roughness: 0.4, metalness: 0.5 });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -10;
            ground.receiveShadow = true;
            scene.add(ground);
            
            player = new Player();
            scene.add(player.mesh);
            scene.add(player.light);
            
            platforms.push(createPlatform(0, 3, 12, 2, 4));
            lastPlatformX = 12;
            
            clock = new THREE.Clock();
            
            document.getElementById('startBtn').addEventListener('click', (e) => {
                e.preventDefault();
                startGame();
            });
            
            document.getElementById('restartBtn').addEventListener('click', (e) => {
                e.preventDefault();
                restartGame();
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
                if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') {
                    e.preventDefault();
                    keys.jump = true;
                }
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.sprint = true;
                if (e.code === 'KeyR' && gameOver) restartGame();
                if (e.code === 'Enter' && !gameStarted) startGame();
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
                if (e.code === 'ArrowUp' || e.code === 'Space' || e.code === 'KeyW') keys.jump = false;
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.sprint = false;
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ============ GAME LOOP ============
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.05);
            
            if (gameStarted && !gameOver) {
                generateWorld();
                cleanupWorld();
                
                player.update(delta);
                checkCollisions();
                
                enemies.forEach(enemy => enemy.update(delta));
                coins.forEach(coin => coin.update());
                items.forEach(item => item.update());
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    if (!particles[i].update(delta)) {
                        particles[i].destroy();
                        particles.splice(i, 1);
                    }
                }
                
                decorations.forEach(dec => {
                    if (dec.speed) {
                        dec.mesh.position.x = dec.baseX + player.position.x * 0.08;
                    }
                });
                
                updateUI();
                if (player.onGround) combo = 0;
            }
            
            const targetX = player.position.x + 6;
            const targetY = Math.max(player.position.y + CONFIG.camera.height, 9);
            camera.position.x += (targetX - camera.position.x) * CONFIG.camera.smoothing;
            camera.position.y += (targetY - camera.position.y) * CONFIG.camera.smoothing * 0.6;
            camera.lookAt(player.position.x + 10, player.position.y + 1.5, 0);
            
            if (sunLight) {
                sunLight.position.x = player.position.x + 25;
                sunLight.target.position.set(player.position.x, 0, 0);
                sunLight.target.updateMatrixWorld();
            }
            
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
